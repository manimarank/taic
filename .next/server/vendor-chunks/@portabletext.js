"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   createMarkdownBehaviors: () => (/* binding */ createMarkdownBehaviors),\n/* harmony export */   defineBehavior: () => (/* binding */ defineBehavior),\n/* harmony export */   editorMachine: () => (/* binding */ editorMachine),\n/* harmony export */   keyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/./node_modules/lodash/noop.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.esm.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-38475d87.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-5ea71f04.development.esm.js\");\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/./node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/./node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/./node_modules/lodash/omitBy.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! is-hotkey-esm */ \"(ssr)/./node_modules/is-hotkey-esm/dist/index.js\");\n/* harmony import */ var _sanity_block_tools__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @sanity/block-tools */ \"(ssr)/./node_modules/@sanity/block-tools/lib/index.mjs\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/./node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/throttle.js */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash/debounce.js */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var _sanity_util_content__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @sanity/util/content */ \"(ssr)/./node_modules/@sanity/util/lib/content.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction defineBehavior(behavior) {\n  return behavior;\n}\nfunction selectionIsCollapsed(context) {\n  return context.selection?.anchor.path.join() === context.selection?.focus.path.join() && context.selection?.anchor.offset === context.selection?.focus.offset;\n}\nfunction getFocusBlock(context) {\n  const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getFocusTextBlock(context) {\n  const focusBlock = getFocusBlock(context);\n  return focusBlock && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}\nfunction getFocusBlockObject(context) {\n  const focusBlock = getFocusBlock(context);\n  return focusBlock && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}\nfunction getFocusChild(context) {\n  const focusBlock = getFocusTextBlock(context);\n  if (!focusBlock)\n    return;\n  const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(context.selection.focus.path[2]) ? context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [...focusBlock.path, \"children\", {\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getFocusSpan(context) {\n  const focusChild = getFocusChild(context);\n  return focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}\nfunction getSelectionStartBlock(context) {\n  const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getSelectionEndBlock(context) {\n  const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getPreviousBlock(context) {\n  let previousBlock;\n  const selectionStartBlock = getSelectionStartBlock(context);\n  if (!selectionStartBlock)\n    return;\n  let foundSelectionStartBlock = !1;\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = !0;\n      break;\n    }\n    previousBlock = {\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    };\n  }\n  if (foundSelectionStartBlock && previousBlock)\n    return previousBlock;\n}\nfunction getNextBlock(context) {\n  let nextBlock;\n  const selectionEndBlock = getSelectionEndBlock(context);\n  if (!selectionEndBlock)\n    return;\n  let foundSelectionEndBlock = !1;\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = !0;\n      continue;\n    }\n    if (foundSelectionEndBlock) {\n      nextBlock = {\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      };\n      break;\n    }\n  }\n  if (foundSelectionEndBlock && nextBlock)\n    return nextBlock;\n}\nfunction isEmptyTextBlock(block) {\n  return block.children.length === 1 && block.children[0].text === \"\";\n}\nfunction createMarkdownBehaviors(config) {\n  const automaticStyleOnSpace = {\n    on: \"insert text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const looksLikeMarkdownHeading = /^#+/.test(focusSpan.node.text), headingStyle = config.mapHeadingStyle(context.schema, focusSpan.node.text.length), looksLikeMarkdownQuote = /^>/.test(focusSpan.node.text), blockquoteStyle = config.mapBlockquoteStyle(context.schema);\n      return looksLikeMarkdownHeading && headingStyle !== void 0 ? {\n        focusTextBlock,\n        focusSpan,\n        style: headingStyle\n      } : looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {\n        focusTextBlock,\n        focusSpan,\n        style: blockquoteStyle\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert text\",\n      text: \" \"\n    }], (_, {\n      focusTextBlock,\n      focusSpan,\n      style\n    }) => [{\n      type: \"set block\",\n      style,\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"delete\",\n      selection: {\n        anchor: {\n          path: focusSpan.path,\n          offset: 0\n        },\n        focus: {\n          path: focusSpan.path,\n          offset: focusSpan.node.text.length + 1\n        }\n      }\n    }]]\n  }, clearStyleOnBackspace = {\n    on: \"delete backward\",\n    guard: ({\n      context\n    }) => {\n      const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const defaultStyle = config.mapDefaultStyle(context.schema);\n      return defaultStyle && focusTextBlock.node.children.length === 1 && focusTextBlock.node.style !== config.mapDefaultStyle(context.schema) && focusSpan.node.text === \"\" ? {\n        defaultStyle,\n        focusTextBlock\n      } : !1;\n    },\n    actions: [(_, {\n      defaultStyle,\n      focusTextBlock\n    }) => [{\n      type: \"set block\",\n      style: defaultStyle,\n      paths: [focusTextBlock.path]\n    }]]\n  }, automaticListOnSpace = {\n    on: \"insert text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const looksLikeUnorderedList = /^-/.test(focusSpan.node.text), unorderedListStyle = config.mapUnorderedListStyle(context.schema);\n      if (looksLikeUnorderedList && unorderedListStyle !== void 0)\n        return {\n          focusTextBlock,\n          focusSpan,\n          listItem: unorderedListStyle\n        };\n      const looksLikeOrderedList = /^1./.test(focusSpan.node.text), orderedListStyle = config.mapOrderedListStyle(context.schema);\n      return looksLikeOrderedList && orderedListStyle !== void 0 ? {\n        focusTextBlock,\n        focusSpan,\n        listItem: orderedListStyle\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert text\",\n      text: \" \"\n    }], (_, {\n      focusTextBlock,\n      focusSpan,\n      listItem\n    }) => [{\n      type: \"unset block\",\n      props: [\"style\"],\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"set block\",\n      listItem,\n      level: 1,\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"delete\",\n      selection: {\n        anchor: {\n          path: focusSpan.path,\n          offset: 0\n        },\n        focus: {\n          path: focusSpan.path,\n          offset: focusSpan.node.text.length + 1\n        }\n      }\n    }]]\n  };\n  return [automaticStyleOnSpace, clearStyleOnBackspace, automaticListOnSpace];\n}\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_4__(rootName);\nfunction debugWithName(name) {\n  const namespace = `${rootName}${name}`;\n  return debug__WEBPACK_IMPORTED_MODULE_4__ && debug__WEBPACK_IMPORTED_MODULE_4__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_4__(namespace) : debug__WEBPACK_IMPORTED_MODULE_4__(rootName);\n}\nfunction createKeyedPath(point, value, types) {\n  const blockPath = [point.path[0]];\n  if (!value)\n    return null;\n  const block = value[blockPath[0]];\n  if (!block)\n    return null;\n  const keyedBlockPath = [{\n    _key: block._key\n  }];\n  if (block._type !== types.block.name)\n    return keyedBlockPath;\n  let keyedChildPath;\n  const childPath = point.path.slice(0, 2), child = Array.isArray(block.children) && block.children[childPath[1]];\n  return child && (keyedChildPath = [\"children\", {\n    _key: child._key\n  }]), keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;\n}\nfunction createArrayedPath(point, editor) {\n  if (!editor)\n    return [];\n  const [block, blockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: [],\n    match: (n) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(point.path[0]) && n._key === point.path[0]._key\n  }))[0] || [void 0, void 0];\n  if (!block || !slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block))\n    return [];\n  if (editor.isVoid(block))\n    return [blockPath[0], 0];\n  const childPath = [point.path[2]], childIndex = block.children.findIndex((child) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__([{\n    _key: child._key\n  }], childPath));\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex];\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);\n  }\n  return blockPath;\n}\nfunction toPortableTextRange(value, range, types) {\n  if (!range)\n    return null;\n  let anchor = null, focus = null;\n  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);\n  anchorPath && range.anchor && (anchor = {\n    path: anchorPath,\n    offset: range.anchor.offset\n  });\n  const focusPath = range.focus && createKeyedPath(range.focus, value, types);\n  focusPath && range.focus && (focus = {\n    path: focusPath,\n    offset: range.focus.offset\n  });\n  const backward = !!(slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(range) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(range));\n  return anchor && focus ? {\n    anchor,\n    focus,\n    backward\n  } : null;\n}\nfunction toSlateRange(selection, editor) {\n  if (!selection || !editor)\n    return null;\n  const anchor = {\n    path: createArrayedPath(selection.anchor, editor),\n    offset: selection.anchor.offset\n  }, focus = {\n    path: createArrayedPath(selection.focus, editor),\n    offset: selection.focus.offset\n  };\n  return focus.path.length === 0 || anchor.path.length === 0 ? null : anchor && focus ? {\n    anchor,\n    focus\n  } : null;\n}\nfunction moveRangeByOperation(range, operation) {\n  const anchor = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.focus, operation);\n  return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(focus, range.focus) ? range : {\n    anchor,\n    focus\n  };\n}\nfunction normalizePoint(point, value) {\n  if (!point || !value)\n    return null;\n  const newPath = [];\n  let newOffset = point.offset || 0;\n  const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);\n  if (block)\n    newPath.push({\n      _key: block._key\n    });\n  else\n    return null;\n  if (block && point.path[1] === \"children\") {\n    if (!block.children || Array.isArray(block.children) && block.children.length === 0)\n      return null;\n    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);\n    if (child)\n      newPath.push(\"children\"), newPath.push({\n        _key: child._key\n      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n    else\n      return null;\n  }\n  return {\n    path: newPath,\n    offset: newOffset\n  };\n}\nfunction normalizeSelection(selection, value) {\n  if (!selection || !value || value.length === 0)\n    return null;\n  let newAnchor = null, newFocus = null;\n  const {\n    anchor,\n    focus\n  } = selection;\n  return anchor && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({\n    _key: blk._key\n  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({\n    _key: blk._key\n  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {\n    anchor: newAnchor,\n    focus: newFocus,\n    backward: selection.backward\n  } : null;\n}\nconst VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n  const value = keyMap[object._key];\n  return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, {\n  schemaTypes\n}, keyMap = {}) {\n  return value && Array.isArray(value) ? value.map((block) => {\n    const {\n      _type,\n      _key,\n      ...rest\n    } = block, voidChildren = [{\n      _key: VOID_CHILD_KEY,\n      _type: \"span\",\n      text: \"\",\n      marks: []\n    }];\n    if (block && block._type === schemaTypes.block.name) {\n      const textBlock = block;\n      let hasInlines = !1;\n      const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child) => {\n        const {\n          _type: cType,\n          _key: cKey,\n          ...cRest\n        } = child;\n        return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality({\n          _type: cType,\n          _key: cKey,\n          children: voidChildren,\n          value: cRest,\n          __inline: !0\n        }, keyMap)) : child;\n      });\n      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].value), keepObjectEquality({\n        _type,\n        _key,\n        ...rest,\n        children\n      }, keyMap));\n    }\n    return keepObjectEquality({\n      _type,\n      _key,\n      children: voidChildren,\n      value: rest\n    }, keyMap);\n  }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n  return value.map((block) => {\n    const {\n      _key,\n      _type\n    } = block;\n    if (!_key || !_type)\n      throw new Error(\"Not a valid block\");\n    if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n      let hasInlines = !1;\n      const children = block.children.map((child) => {\n        const {\n          _type: _cType\n        } = child;\n        if (\"value\" in child && _cType !== \"span\") {\n          hasInlines = !0;\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child;\n          return keepObjectEquality({\n            ...rest,\n            ...v,\n            _key: k,\n            _type: t\n          }, keyMap);\n        }\n        return child;\n      });\n      return hasInlines ? keepObjectEquality({\n        ...block,\n        children,\n        _key,\n        _type\n      }, keyMap) : block;\n    }\n    const blockValue = \"value\" in block && block.value;\n    return keepObjectEquality({\n      _key,\n      _type,\n      ...typeof blockValue == \"object\" ? blockValue : {}\n    }, keyMap);\n  });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].value && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !children[0].children[0].marks?.join(\"\") && children[0].children[0].text === \"\";\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), IS_PROCESSING_LOCAL_CHANGES = /* @__PURE__ */ new WeakMap(), IS_DRAGGING = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), DefaultObject = (props) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(4);\n  let t0;\n  $[0] !== props.value ? (t0 = JSON.stringify(props.value, null, 2), $[0] = props.value, $[1] = t0) : t0 = $[1];\n  let t1;\n  return $[2] !== t0 ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { children: t0 }) }), $[2] = t0, $[3] = t1) : t1 = $[3], t1;\n};\nDefaultObject.displayName = \"DefaultObject\";\nconst DefaultBlockObject = styled_components__WEBPACK_IMPORTED_MODULE_16__.styled.div`\n  user-select: none;\n  border: ${(props) => props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nstyled_components__WEBPACK_IMPORTED_MODULE_16__.styled.span`\n  background: #999;\n  border: ${(props) => props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nconst DefaultListItem = styled_components__WEBPACK_IMPORTED_MODULE_16__.styled.div`\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ${(props) => getLeftPositionForListLevel(props.listLevel)};\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '${(props) => getContentForListLevelAndStyle(props.listLevel, props.listStyle)}';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ${(props) => getCounterIncrementForListLevel(props.listLevel)};\n    counter-reset: ${(props) => getCounterResetForListLevel(props.listLevel)};\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ${(props) => getCounterContentForListLevel(props.listLevel)};\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n`, DefaultListItemInner = styled_components__WEBPACK_IMPORTED_MODULE_16__.styled.div``;\nfunction getLeftPositionForListLevel(level) {\n  switch (Number(level)) {\n    case 1:\n      return \"1.5em\";\n    case 2:\n      return \"3em\";\n    case 3:\n      return \"4.5em\";\n    case 4:\n      return \"6em\";\n    case 5:\n      return \"7.5em\";\n    case 6:\n      return \"9em\";\n    case 7:\n      return \"10.5em\";\n    case 8:\n      return \"12em\";\n    case 9:\n      return \"13.5em\";\n    case 10:\n      return \"15em\";\n    default:\n      return \"0em\";\n  }\n}\nconst bullets = [\"\\u25CF\", \"\\u25CB\", \"\\u25A0\"];\nfunction getContentForListLevelAndStyle(level, style) {\n  const normalizedLevel = (level - 1) % 3;\n  return style === \"bullet\" ? bullets[normalizedLevel] : \"*\";\n}\nfunction getCounterIncrementForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"listItemNumber\";\n    case 2:\n      return \"listItemAlpha\";\n    case 3:\n      return \"listItemRoman\";\n    case 4:\n      return \"listItemNumberNext\";\n    case 5:\n      return \"listItemLetterNext\";\n    case 6:\n      return \"listItemRomanNext\";\n    case 7:\n      return \"listItemNumberNextNext\";\n    case 8:\n      return \"listItemAlphaNextNext\";\n    case 9:\n      return \"listItemRomanNextNext\";\n    default:\n      return \"listItemNumberNextNextNext\";\n  }\n}\nfunction getCounterResetForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"listItemAlpha\";\n    case 2:\n      return \"listItemRoman\";\n    case 3:\n      return \"listItemNumberNext\";\n    case 4:\n      return \"listItemLetterNext\";\n    case 5:\n      return \"listItemRomanNext\";\n    case 6:\n      return \"listItemNumberNextNext\";\n    case 7:\n      return \"listItemAlphaNextNext\";\n    case 8:\n      return \"listItemRomanNextNext\";\n    case 9:\n      return \"listItemNumberNextNextNext\";\n    default:\n      return \"listItemNumberNextNextNext\";\n  }\n}\nfunction getCounterContentForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"counter(listItemNumber) '. '\";\n    case 2:\n      return \"counter(listItemAlpha, lower-alpha) '. '\";\n    case 3:\n      return \"counter(listItemRoman, lower-roman) '. '\";\n    case 4:\n      return \"counter(listItemNumberNext) '. '\";\n    case 5:\n      return \"counter(listItemLetterNext, lower-alpha) '. '\";\n    case 6:\n      return \"counter(listItemRomanNext, lower-roman) '. '\";\n    case 7:\n      return \"counter(listItemNumberNextNext) '. '\";\n    case 8:\n      return \"counter(listItemAlphaNextNext, lower-alpha) '. '\";\n    case 9:\n      return \"counter(listItemRomanNextNext, lower-roman) '. '\";\n    default:\n      return \"counter(listItemNumberNextNextNext) '. '\";\n  }\n}\nconst debug$l = debugWithName(\"components:DraggableBlock\"), DraggableBlock = (t0) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(51), {\n    children,\n    element,\n    readOnly,\n    blockRef\n  } = t0, editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlateStatic)(), dragGhostRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(), [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1);\n  let t1, t2;\n  $[0] !== editor || $[1] !== element ? (t2 = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, element), $[0] = editor, $[1] = element, $[2] = t2) : t2 = $[2], t1 = t2;\n  const isVoid = t1;\n  let t3, t4;\n  $[3] !== editor || $[4] !== element ? (t4 = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isInline(editor, element), $[3] = editor, $[4] = element, $[5] = t4) : t4 = $[5], t3 = t4;\n  const isInline = t3, [blockElement, setBlockElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n  let t5, t6;\n  $[6] !== blockRef || $[7] !== editor || $[8] !== element ? (t5 = () => setBlockElement(blockRef ? blockRef.current : slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(editor, element)), t6 = [editor, element, blockRef], $[6] = blockRef, $[7] = editor, $[8] = element, $[9] = t5, $[10] = t6) : (t5 = $[9], t6 = $[10]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t5, t6);\n  let t7;\n  $[11] !== editor || $[12] !== blockElement || $[13] !== element ? (t7 = (event) => {\n    const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);\n    if (!isMyDragOver || !blockElement)\n      return;\n    event.preventDefault(), event.dataTransfer.dropEffect = \"move\", IS_DRAGGING_ELEMENT_TARGET.set(editor, element);\n    const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);\n    if (element === editor.children[0] || (loc < height / 2 ? IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"top\") : IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"bottom\")), isMyDragOver === element) {\n      event.dataTransfer.dropEffect = \"none\";\n      return;\n    }\n    setIsDragOver(!0);\n  }, $[11] = editor, $[12] = blockElement, $[13] = element, $[14] = t7) : t7 = $[14];\n  const handleDragOver = t7;\n  let t8;\n  $[15] === Symbol.for(\"react.memo_cache_sentinel\") ? (t8 = () => {\n    setIsDragOver(!1);\n  }, $[15] = t8) : t8 = $[15];\n  const handleDragLeave = t8;\n  let t9;\n  $[16] !== editor || $[17] !== element ? (t9 = (event_0) => {\n    const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);\n    if (targetBlock) {\n      IS_DRAGGING.set(editor, !1), event_0.preventDefault(), event_0.stopPropagation(), IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$l(\"Removing drag ghost\"), document.body.removeChild(dragGhostRef.current));\n      const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);\n      IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);\n      let targetPath = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findPath(editor, targetBlock);\n      const myPath = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findPath(editor, element), isBefore = slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(myPath, targetPath);\n      if (dragPosition === \"bottom\" && !isBefore) {\n        if (targetPath[0] >= editor.children.length - 1) {\n          debug$l(\"target is already at the bottom, not moving\");\n          return;\n        }\n        const originalPath = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(targetPath), debug$l(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (dragPosition === \"top\" && isBefore && targetPath[0] !== editor.children.length - 1) {\n        const originalPath_0 = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(targetPath), debug$l(`Adjusting targetPath from ${JSON.stringify(originalPath_0)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(targetPath, myPath)) {\n        event_0.preventDefault(), debug$l(\"targetPath and myPath is the same, not moving\");\n        return;\n      }\n      debug$l(`Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(editor, {\n        at: myPath,\n        to: targetPath\n      }), editor.onChange();\n      return;\n    }\n    debug$l(\"No target element, not doing anything\");\n  }, $[16] = editor, $[17] = element, $[18] = t9) : t9 = $[18];\n  const handleDragEnd = t9;\n  let t10;\n  $[19] !== editor || $[20] !== element ? (t10 = (event_1) => {\n    IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$l(\"On drop (prevented)\", element), event_1.preventDefault(), event_1.stopPropagation(), setIsDragOver(!1));\n  }, $[19] = editor, $[20] = element, $[21] = t10) : t10 = $[21];\n  const handleDrop = t10;\n  let t11;\n  $[22] !== isVoid || $[23] !== editor || $[24] !== element ? (t11 = (event_2) => {\n    if (!isVoid) {\n      IS_DRAGGING_BLOCK_ELEMENT.delete(editor);\n      return;\n    }\n    IS_DRAGGING.set(editor, !0), IS_DRAGGING_BLOCK_ELEMENT.set(editor, element), event_2.stopPropagation();\n    const target = event_2.target;\n    target instanceof HTMLElement && (target.style.opacity = \"1\");\n  }, $[22] = isVoid, $[23] = editor, $[24] = element, $[25] = t11) : t11 = $[25];\n  const handleDrag = t11;\n  let t12;\n  $[26] !== isVoid || $[27] !== isInline || $[28] !== editor || $[29] !== blockElement || $[30] !== handleDrag ? (t12 = (event_3) => {\n    if (!isVoid || isInline) {\n      debug$l(\"Not dragging block\"), IS_DRAGGING_BLOCK_ELEMENT.delete(editor), IS_DRAGGING.set(editor, !1);\n      return;\n    }\n    if (debug$l(\"Drag start\"), IS_DRAGGING.set(editor, !0), event_3.dataTransfer && (event_3.dataTransfer.setData(\"application/portable-text\", \"something\"), event_3.dataTransfer.effectAllowed = \"move\"), blockElement && blockElement instanceof HTMLElement) {\n      let dragGhost = blockElement.cloneNode(!0);\n      const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n      if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), document.body) {\n        dragGhostRef.current = dragGhost, dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n        const rect = blockElement.getBoundingClientRect(), x = event_3.clientX - rect.left, y = event_3.clientY - rect.top;\n        dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event_3.dataTransfer.setDragImage(dragGhost, x, y);\n      }\n    }\n    handleDrag(event_3);\n  }, $[26] = isVoid, $[27] = isInline, $[28] = editor, $[29] = blockElement, $[30] = handleDrag, $[31] = t12) : t12 = $[31];\n  const handleDragStart = t12;\n  let t13;\n  $[32] !== isDragOver || $[33] !== editor ? (t13 = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[32] = isDragOver, $[33] = editor, $[34] = t13) : t13 = $[34];\n  const isDraggingOverFirstBlock = t13;\n  let t14;\n  $[35] !== isDragOver || $[36] !== editor ? (t14 = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[35] = isDragOver, $[36] = editor, $[37] = t14) : t14 = $[37];\n  const isDraggingOverLastBlock = t14, dragPosition_0 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"top\", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"bottom\";\n  let t15, t16;\n  $[38] === Symbol.for(\"react.memo_cache_sentinel\") ? (t16 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"pt-drop-indicator\", style: {\n    position: \"absolute\",\n    width: \"100%\",\n    height: 1,\n    borderBottom: \"1px solid currentColor\",\n    zIndex: 5\n  } }), $[38] = t16) : t16 = $[38], t15 = t16;\n  const dropIndicator = t15;\n  if (readOnly) {\n    let t172;\n    return $[39] !== children ? (t172 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children }), $[39] = children, $[40] = t172) : t172 = $[40], t172;\n  }\n  const t17 = isDraggingOverTop && dropIndicator, t18 = isDraggingOverBottom && dropIndicator;\n  let t19;\n  return $[41] !== isVoid || $[42] !== handleDragStart || $[43] !== handleDrag || $[44] !== handleDragOver || $[45] !== handleDragEnd || $[46] !== handleDrop || $[47] !== t17 || $[48] !== children || $[49] !== t18 ? (t19 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop, children: [\n    t17,\n    children,\n    t18\n  ] }), $[41] = isVoid, $[42] = handleDragStart, $[43] = handleDrag, $[44] = handleDragOver, $[45] = handleDragEnd, $[46] = handleDrop, $[47] = t17, $[48] = children, $[49] = t18, $[50] = t19) : t19 = $[50], t19;\n};\nDraggableBlock.displayName = \"DraggableBlock\";\ndebugWithName(\"components:Element\");\nconst EMPTY_ANNOTATIONS = [], inlineBlockStyle = {\n  display: \"inline-block\"\n}, Element = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck\n}) => {\n  const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSelected)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), inlineBlockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), focused = selected && editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection) || !1, value = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], [editor, element, schemaTypes.block.name]);\n  let renderedBlock = children, className;\n  const blockPath = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => [{\n    _key: element._key\n  }], [element]);\n  if (typeof element._type != \"string\")\n    throw new Error(\"Expected element to have a _type property\");\n  if (typeof element._key != \"string\")\n    throw new Error(\"Expected element to have a _key property\");\n  if (editor.isInline(element)) {\n    const path = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findPath(editor, element), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n      depth: 1\n    }), schemaType = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);\n    if (!schemaType)\n      throw new Error(\"Could not find type for inline block element\");\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block)) {\n      const elmPath = [{\n        _key: block._key\n      }, \"children\", {\n        _key: element._key\n      }];\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { ...attributes, children: [\n        children,\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { draggable: !readOnly, className: \"pt-inline-object\", \"data-testid\": \"pt-inline-object\", ref: inlineBlockObjectRef, style: inlineBlockStyle, contentEditable: !1, children: [\n          renderChild && renderChild({\n            annotations: EMPTY_ANNOTATIONS,\n            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value }),\n            editorElementRef: inlineBlockObjectRef,\n            focused,\n            path: elmPath,\n            schemaType,\n            selected,\n            type: schemaType,\n            value\n          }),\n          !renderChild && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value })\n        ] }, element._key)\n      ] });\n    }\n    throw new Error(\"Block not found!\");\n  }\n  if (element._type === schemaTypes.block.name) {\n    className = \"pt-block pt-text-block\";\n    const isListItem = \"listItem\" in element, style = \"style\" in element && element.style || \"normal\";\n    className = `pt-block pt-text-block pt-text-block-style-${style}`;\n    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);\n    renderStyle && blockStyleType && (renderedBlock = renderStyle({\n      block: element,\n      children,\n      focused,\n      selected,\n      value: style,\n      path: blockPath,\n      schemaType: blockStyleType,\n      editorElementRef: blockRef\n    }));\n    let level;\n    if (isListItem && (typeof element.level == \"number\" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find((item_0) => item_0.value === element.listItem);\n      renderListItem && listType ? renderedBlock = renderListItem({\n        block: value,\n        children: renderedBlock,\n        focused,\n        selected,\n        value: element.listItem,\n        path: blockPath,\n        schemaType: listType,\n        level: value.level || 1,\n        editorElementRef: blockRef\n      }) : renderedBlock = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultListItem, { listStyle: value.listItem || schemaTypes.lists[0].value, listLevel: value.level || 1, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultListItemInner, { children: renderedBlock }) });\n    }\n    const renderProps = Object.defineProperty({\n      children: renderedBlock,\n      editorElementRef: blockRef,\n      focused,\n      level,\n      listItem: isListItem ? element.listItem : void 0,\n      path: blockPath,\n      selected,\n      style,\n      schemaType: schemaTypes.block,\n      value\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.block;\n      }\n    }), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ...attributes, className, spellCheck, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: blockRef, children: propsOrDefaultRendered }) }) }, element._key);\n  }\n  const schemaType_0 = schemaTypes.blockObjects.find((_type_0) => _type_0.name === element._type);\n  if (!schemaType_0)\n    throw new Error(`Could not find schema type for block element of _type ${element._type}`);\n  className = \"pt-block pt-object-block\";\n  const block_0 = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n  let renderedBlockFromProps;\n  if (renderBlock) {\n    const _props = Object.defineProperty({\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value }),\n      editorElementRef: blockRef,\n      focused,\n      path: blockPath,\n      schemaType: schemaType_0,\n      selected,\n      value: block_0\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n      }\n    });\n    renderedBlockFromProps = renderBlock(_props);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { ...attributes, className, children: [\n    children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(DraggableBlock, { element, readOnly, blockRef, children: [\n      renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps }),\n      !renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultBlockObject, { selected, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value }) })\n    ] })\n  ] }, element._key);\n};\nElement.displayName = \"Element\";\nconst PortableTextEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null), usePortableTextEditor = () => {\n  const editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(PortableTextEditorContext);\n  if (!editor)\n    throw new Error(\"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\");\n  return editor;\n};\nfunction DefaultAnnotation(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(6);\n  let t0;\n  $[0] !== props.annotation ? (t0 = () => alert(JSON.stringify(props.annotation)), $[0] = props.annotation, $[1] = t0) : t0 = $[1];\n  const handleClick = t0;\n  let t1;\n  $[2] === Symbol.for(\"react.memo_cache_sentinel\") ? (t1 = {\n    color: \"blue\"\n  }, $[2] = t1) : t1 = $[2];\n  let t2;\n  return $[3] !== handleClick || $[4] !== props.children ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: t1, onClick: handleClick, children: props.children }), $[3] = handleClick, $[4] = props.children, $[5] = t2) : t2 = $[5], t2;\n}\nDefaultAnnotation.displayName = \"DefaultAnnotation\";\nfunction getPortableTextMemberSchemaTypes(portableTextType) {\n  if (!portableTextType)\n    throw new Error(\"Parameter 'portabletextType' missing (required)\");\n  const blockType = portableTextType.of?.find(findBlockType);\n  if (!blockType)\n    throw new Error(\"Block type is not defined in this schema (required)\");\n  const childrenField = blockType.fields?.find((field) => field.name === \"children\");\n  if (!childrenField)\n    throw new Error(\"Children field for block type found in schema (required)\");\n  const ofType = childrenField.type.of;\n  if (!ofType)\n    throw new Error(\"Valid types for block children not found in schema (required)\");\n  const spanType = ofType.find((memberType) => memberType.name === \"span\");\n  if (!spanType)\n    throw new Error(\"Span type not found in schema (required)\");\n  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== \"span\") || [], blockObjectTypes = portableTextType.of?.filter((field) => field.name !== blockType.name) || [];\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: spanType.annotations\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields?.find((btField) => btField.name === \"style\");\n  if (!styleField)\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\");\n  const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter((style) => style.value);\n  if (!textStyles || textStyles.length === 0)\n    throw new Error(\"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\");\n  return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields?.find((btField) => btField.name === \"listItem\");\n  if (!listField)\n    throw new Error(\"A field with name 'listItem' is not defined in the block type (required).\");\n  const listItems = listField.type.options?.list && listField.type.options.list.filter((list) => list.value);\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_18__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType]\n  }).get(rawType.name);\n}\nconst debug$k = debugWithName(\"operationToPatches\");\nfunction createOperationToPatches(types) {\n  const textBlockName = types.block.name;\n  function insertTextPatch(editor, operation, beforeValue) {\n    debug$k.enabled && debug$k(\"Operation\", JSON.stringify(operation, null, 2));\n    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.diffMatchPatch)(prevText, textChild.text, path);\n    return patch.value.length ? [patch] : [];\n  }\n  function removeTextPatch(editor, operation, beforeValue) {\n    const block = editor && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;\n    if (child && !textChild)\n      throw new Error(\"Expected span\");\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n    return patch.value ? [patch] : [];\n  }\n  function setNodePatch(editor, operation) {\n    if (operation.path.length === 1) {\n      const block = editor.children[operation.path[0]];\n      if (typeof block._key != \"string\")\n        throw new Error(\"Expected block to have a _key\");\n      const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_9__({\n        ...editor.children[operation.path[0]],\n        ...operation.newProperties\n      }, lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_8__);\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(fromSlateValue([setNode], textBlockName)[0], [{\n        _key: block._key\n      }])];\n    } else if (operation.path.length === 2) {\n      const block = editor.children[operation.path[0]];\n      if (editor.isTextBlock(block)) {\n        const child = block.children[operation.path[1]];\n        if (child) {\n          const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n          return keys.forEach((keyName) => {\n            if (keys.length === 1 && keyName === \"_key\") {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_7__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(val, [{\n                _key: blockKey\n              }, \"children\", block.children.indexOf(child), keyName]));\n            } else {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_7__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(val, [{\n                _key: blockKey\n              }, \"children\", {\n                _key: childKey\n              }, keyName]));\n            }\n          }), patches;\n        }\n        throw new Error(\"Could not find a valid child\");\n      }\n      throw new Error(\"Could not find a valid block\");\n    } else\n      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n  }\n  function insertNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]], isTextBlock = editor.isTextBlock(block);\n    if (operation.path.length === 1) {\n      const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;\n      return targetKey ? [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([fromSlateValue([operation.node], textBlockName)[0]], position, [{\n        _key: targetKey\n      }])] : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.setIfMissing)(beforeValue, []), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([fromSlateValue([operation.node], textBlockName)[0]], \"before\", [operation.path[0]])];\n    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {\n      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = {\n        ...operation.node\n      };\n      !node._type && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n      const child = fromSlateValue([{\n        _key: \"bogus\",\n        _type: textBlockName,\n        children: [node]\n      }], textBlockName)[0].children[0];\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([child], position, [{\n        _key: block._key\n      }, \"children\", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {\n        _key: block.children[operation.path[1] - 1]._key\n      }])];\n    }\n    return debug$k(\"Something was inserted into a void block. Not producing editor patches.\"), [];\n  }\n  function splitNodePatch(editor, operation, beforeValue) {\n    const patches = [], splitBlock = editor.children[operation.path[0]];\n    if (!editor.isTextBlock(splitBlock))\n      throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);\n    if (operation.path.length === 1) {\n      const oldBlock = beforeValue[operation.path[0]];\n      if (editor.isTextBlock(oldBlock)) {\n        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];\n        targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([targetValue], \"after\", [{\n          _key: splitBlock._key\n        }])), oldBlock.children.slice(operation.position).forEach((span) => {\n          const path = [{\n            _key: oldBlock._key\n          }, \"children\", {\n            _key: span._key\n          }];\n          patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)(path));\n        }));\n      }\n      return patches;\n    }\n    if (operation.path.length === 2) {\n      const splitSpan = splitBlock.children[operation.path[1]];\n      if (editor.isTextSpan(splitSpan)) {\n        const targetSpans = fromSlateValue([{\n          ...splitBlock,\n          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n        }], textBlockName)[0].children;\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)(targetSpans, \"after\", [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(splitSpan.text, [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }, \"text\"]));\n      }\n      return patches;\n    }\n    return patches;\n  }\n  function removeNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]];\n    if (operation.path.length === 1) {\n      if (block && block._key)\n        return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: block._key\n        }])];\n      throw new Error(\"Block not found\");\n    } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n      const spanToRemove = block.children[operation.path[1]];\n      return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: spanToRemove._key\n      }])] : (debug$k(\"Span not found in editor trying to remove node\"), []);\n    } else\n      return debug$k(\"Not creating patch inside object block\"), [];\n  }\n  function mergeNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], updatedBlock = editor.children[operation.path[0]];\n    if (operation.path.length === 1)\n      if (block?._key) {\n        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(newBlock, [{\n          _key: newBlock._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: block._key\n        }]));\n      } else\n        throw new Error(\"Target key not found!\");\n    else if (editor.isTextBlock(block) && editor.isTextBlock(updatedBlock) && operation.path.length === 2) {\n      const updatedSpan = updatedBlock.children[operation.path[1] - 1] && editor.isTextSpan(updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && editor.isTextSpan(block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;\n      updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(updatedSpan.text, [{\n        _key: block._key\n      }, \"children\", {\n        _key: updatedSpan._key\n      }, \"text\"])) : console.warn(`Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: removedSpan._key\n      }])) : console.warn(`Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));\n    } else\n      debug$k(\"Void nodes can't be merged, not creating any patches\");\n    return patches;\n  }\n  function moveNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n    if (operation.path.length === 1) {\n      const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([fromSlateValue([block], textBlockName)[0]], position, [{\n        _key: targetBlock._key\n      }]));\n    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {\n      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: child._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([childToInsert], position, [{\n        _key: targetBlock._key\n      }, \"children\", {\n        _key: targetChild._key\n      }]));\n    }\n    return patches;\n  }\n  return {\n    insertNodePatch,\n    insertTextPatch,\n    mergeNodePatch,\n    moveNodePatch,\n    removeNodePatch,\n    removeTextPatch,\n    setNodePatch,\n    splitNodePatch\n  };\n}\nfunction createWithEventListeners(editorActor) {\n  return function(editor) {\n    return editor.deleteBackward = (unit) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete backward\",\n          unit\n        },\n        editor\n      });\n    }, editor.deleteForward = (unit) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete forward\",\n          unit\n        },\n        editor\n      });\n    }, editor.insertBreak = () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert break\"\n        },\n        editor\n      });\n    }, editor.insertSoftBreak = () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert soft break\"\n        },\n        editor\n      });\n    }, editor.insertText = (text, options) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert text\",\n          text,\n          options\n        },\n        editor\n      });\n    }, editor;\n  };\n}\nconst debug$j = debugWithName(\"API:editable\");\nfunction createWithEditableAPI(editorActor, portableTextEditor, types) {\n  return function(editor) {\n    return portableTextEditor.setEditable({\n      focus: () => {\n        slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.focus(editor);\n      },\n      blur: () => {\n        slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.blur(editor);\n      },\n      toggleMark: (mark) => {\n        editor.pteToggleMark(mark);\n      },\n      toggleList: (listStyle) => {\n        editor.pteToggleListItem(listStyle);\n      },\n      toggleBlockStyle: (blockStyle) => {\n        editor.pteToggleBlockStyle(blockStyle);\n      },\n      isMarkActive: (mark) => {\n        try {\n          return editor.pteIsMarkActive(mark);\n        } catch (err) {\n          return console.warn(err), !1;\n        }\n      },\n      marks: () => ({\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n      }).marks || [],\n      undo: () => editor.undo(),\n      redo: () => editor.redo(),\n      select: (selection) => {\n        const slateSelection = toSlateRange(selection, editor);\n        slateSelection ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.onChange();\n      },\n      focusBlock: () => {\n        if (editor.selection) {\n          const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n          if (block)\n            return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n        }\n      },\n      focusChild: () => {\n        if (editor.selection) {\n          const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n          if (block && editor.isTextBlock(block))\n            return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];\n        }\n      },\n      insertChild: (type, value) => {\n        if (!editor.selection)\n          throw new Error(\"The editor has no selection\");\n        const [focusBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n          at: editor.selection.focus.path.slice(0, 1),\n          match: (n) => n._type === types.block.name\n        }))[0] || [void 0];\n        if (!focusBlock)\n          throw new Error(\"No focused text block\");\n        if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))\n          throw new Error(\"This type cannot be inserted as a child to a text block\");\n        const child = toSlateValue([{\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          _type: types.block.name,\n          children: [{\n            _key: editorActor.getSnapshot().context.keyGenerator(),\n            _type: type.name,\n            ...value || {}\n          }]\n        }], portableTextEditor)[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_15__.Node.get(editor, focusChildPath);\n        return isSpanNode && focusNode._type !== types.span.name && (debug$j(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({\n          distance: 1,\n          unit: \"character\"\n        })), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, child, {\n          select: !0,\n          at: editor.selection\n        }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path || [];\n      },\n      insertBlock: (type, value) => {\n        const block = toSlateValue([{\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          _type: type.name,\n          ...value || {}\n        }], portableTextEditor)[0];\n        if (!editor.selection) {\n          const lastBlock = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            match: (n) => !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(n),\n            at: [],\n            reverse: !0\n          }))[0];\n          return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block), lastBlock && isEqualToEmptyEditor([lastBlock[0]], types) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: lastBlock[1]\n          }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? [];\n        }\n        const focusBlock = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n          at: editor.selection.focus.path.slice(0, 1),\n          match: (n) => n._type === types.block.name\n        }))[0];\n        return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block), focusBlock && isEqualToEmptyEditor([focusBlock[0]], types) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n          at: focusBlock[1]\n        }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path || [];\n      },\n      hasBlockStyle: (style) => {\n        try {\n          return editor.pteHasBlockStyle(style);\n        } catch {\n          return !1;\n        }\n      },\n      hasListStyle: (listStyle) => {\n        try {\n          return editor.pteHasListStyle(listStyle);\n        } catch {\n          return !1;\n        }\n      },\n      isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),\n      findByPath: (path) => {\n        const slatePath = toSlateRange({\n          focus: {\n            path,\n            offset: 0\n          },\n          anchor: {\n            path,\n            offset: 0\n          }\n        }, editor);\n        if (slatePath) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n          if (block && blockPath && typeof block._key == \"string\") {\n            if (path.length === 1 && slatePath.focus.path.length === 1)\n              return [fromSlateValue([block], types.block.name)[0], [{\n                _key: block._key\n              }]];\n            const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n            if (editor.isTextBlock(ptBlock)) {\n              const ptChild = ptBlock.children[slatePath.focus.path[1]];\n              if (ptChild)\n                return [ptChild, [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: ptChild._key\n                }]];\n            }\n          }\n        }\n        return [void 0, void 0];\n      },\n      findDOMNode: (element) => {\n        let node;\n        try {\n          const [item] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: [],\n            match: (n) => n._key === element._key\n          }) || [])[0] || [void 0];\n          node = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(editor, item);\n        } catch {\n        }\n        return node;\n      },\n      activeAnnotations: () => {\n        if (!editor.selection || editor.selection.focus.path.length < 2)\n          return [];\n        try {\n          const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n          });\n          for (const [span, path] of spans) {\n            const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n              depth: 1\n            });\n            editor.isTextBlock(block) && block.markDefs?.forEach((def) => {\n              slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n            });\n          }\n          return activeAnnotations;\n        } catch {\n          return [];\n        }\n      },\n      isAnnotationActive: (annotationType) => {\n        if (!editor.selection || editor.selection.focus.path.length < 2)\n          return !1;\n        try {\n          const spans = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node)\n          })];\n          if (spans.length === 0 || spans.some(([span]) => !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(span) || !span.marks || span.marks?.length === 0)) return !1;\n          const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n            const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n              depth: 1\n            });\n            return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;\n          }, []);\n          return spans.every(([span]) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(span) ? span.marks?.map((markKey) => selectionMarkDefs.find((def) => def?._key === markKey)?._type)?.includes(annotationType) : !1);\n        } catch {\n          return !1;\n        }\n      },\n      addAnnotation: (type, value) => {\n        const {\n          selection: originalSelection\n        } = editor;\n        let returnValue;\n        if (originalSelection && (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(originalSelection) && (editor.pteExpandToWord(), editor.onChange()), editor.selection)) {\n          let spanPath, markDefPath;\n          const markDefPaths = [];\n          slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n            if (!editor.selection)\n              return;\n            const selectedBlocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n              at: editor.selection,\n              match: (node) => editor.isTextBlock(node),\n              reverse: slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection)\n            });\n            for (const [block, blockPath] of selectedBlocks) {\n              if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === \"\")\n                continue;\n              const annotationKey = editorActor.getSnapshot().context.keyGenerator(), markDefs = block.markDefs ?? [];\n              markDefs.find((markDef) => markDef._type === type.name && markDef._key === annotationKey) === void 0 && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                markDefs: [...markDefs, {\n                  _type: type.name,\n                  _key: annotationKey,\n                  ...value\n                }]\n              }, {\n                at: blockPath\n              }), markDefPath = [{\n                _key: block._key\n              }, \"markDefs\", {\n                _key: annotationKey\n              }], slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n                match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n                split: !0\n              });\n              const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n              for (const [span, path] of children) {\n                if (!editor.isTextSpan(span) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, path))\n                  continue;\n                const marks = span.marks ?? [], existingSameTypeAnnotations = marks.filter((mark) => markDefs.some((markDef) => markDef._key === mark && markDef._type === type.name));\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                  marks: [...marks.filter((mark) => !existingSameTypeAnnotations.includes(mark)), annotationKey]\n                }, {\n                  at: path\n                }), spanPath = [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: span._key\n                }];\n              }\n            }\n            markDefPath && spanPath && (returnValue = {\n              markDefPath,\n              markDefPaths,\n              spanPath\n            });\n          }), editor.onChange();\n        }\n        return returnValue;\n      },\n      delete: (selection, options) => {\n        if (selection) {\n          const range = toSlateRange(selection, editor);\n          if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))\n            throw new Error(\"Invalid range\");\n          if (range) {\n            if (!options?.mode || options?.mode === \"selected\") {\n              debug$j(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(editor, {\n                at: range,\n                hanging: !0,\n                voids: !0\n              }), editor.onChange();\n              return;\n            }\n            options?.mode === \"blocks\" && (debug$j(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n              at: range,\n              voids: !0,\n              match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n            })), options?.mode === \"children\" && (debug$j(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n              at: range,\n              voids: !0,\n              match: (node) => node._type === types.span.name || // Text children\n              !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n            })), editor.children.length === 0 && (editor.children = [editor.pteCreateTextBlock({\n              decorators: []\n            })]), editor.onChange();\n          }\n        }\n      },\n      removeAnnotation: (type) => {\n        debug$j(\"Removing annotation\", type), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n          if (editor.selection)\n            if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n              const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n                depth: 1\n              });\n              if (!editor.isTextBlock(block))\n                return;\n              const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === type.name), [selectedChild, selectedChildPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n                depth: 2\n              });\n              if (!editor.isTextSpan(selectedChild))\n                return;\n              const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));\n              if (!annotationToRemove)\n                return;\n              const previousSpansWithSameAnnotation = [];\n              for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n                reverse: !0\n              }))\n                if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, selectedChildPath))\n                  if (child.marks?.includes(annotationToRemove))\n                    previousSpansWithSameAnnotation.push([child, childPath]);\n                  else\n                    break;\n              const nextSpansWithSameAnnotation = [];\n              for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))\n                if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, selectedChildPath))\n                  if (child.marks?.includes(annotationToRemove))\n                    nextSpansWithSameAnnotation.push([child, childPath]);\n                  else\n                    break;\n              for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                  marks: child.marks?.filter((mark) => mark !== annotationToRemove)\n                }, {\n                  at: childPath\n                });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n                match: (node) => editor.isTextSpan(node),\n                split: !0,\n                hanging: !0\n              });\n              const blocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                at: editor.selection,\n                match: (node) => editor.isTextBlock(node)\n              });\n              for (const [block, blockPath] of blocks) {\n                const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n                for (const [child, childPath] of children) {\n                  if (!editor.isTextSpan(child) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, childPath))\n                    continue;\n                  const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== type.name);\n                  marksWithoutAnnotation.length !== marks.length && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    marks: marksWithoutAnnotation\n                  }, {\n                    at: childPath\n                  });\n                }\n              }\n            }\n        }), editor.onChange();\n      },\n      getSelection: () => {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          if (existing)\n            return existing;\n          ptRange = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n        }\n        return ptRange;\n      },\n      getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n      isCollapsedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection),\n      isExpandedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection),\n      insertBreak: () => {\n        editor.insertBreak(), editor.onChange();\n      },\n      getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),\n      isSelectionsOverlapping: (selectionA, selectionB) => {\n        const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);\n        return slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(rangeA, rangeB);\n      }\n    }), editor;\n  };\n}\nfunction withRemoteChanges(editor, fn) {\n  const prev = isChangingRemotely(editor) || !1;\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nfunction isChangingLocally(editor) {\n  return IS_PROCESSING_LOCAL_CHANGES.get(editor);\n}\nconst IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();\nfunction withUndoing(editor, fn) {\n  const prev = isUndoing(editor);\n  IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);\n}\nfunction isUndoing(editor) {\n  return IS_UDOING.get(editor) ?? !1;\n}\nfunction setIsUndoing(editor, isUndoing2) {\n  IS_UDOING.set(editor, isUndoing2);\n}\nfunction withRedoing(editor, fn) {\n  const prev = isRedoing(editor);\n  IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);\n}\nfunction isRedoing(editor) {\n  return IS_REDOING.get(editor) ?? !1;\n}\nfunction setIsRedoing(editor, isRedoing2) {\n  IS_REDOING.set(editor, isRedoing2);\n}\nfunction createWithMaxBlocks(maxBlocks) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (operation) => {\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      const rows = maxBlocks;\n      rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n    }, editor;\n  };\n}\nfunction createWithObjectKeys(editorActor, schemaTypes) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor;\n    return editor.apply = (operation) => {\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (operation.type === \"split_node\") {\n        apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }\n        });\n        return;\n      }\n      if (operation.type === \"insert_node\" && !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(operation.node)) {\n        apply2({\n          ...operation,\n          node: {\n            ...operation.node,\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }\n        });\n        return;\n      }\n      apply2(operation);\n    }, editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node) && node._type === schemaTypes.block.name) {\n        if (!node._key) {\n          editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))\n          if (!child._key) {\n            editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              _key: editorActor.getSnapshot().context.keyGenerator()\n            }, {\n              at: childPath\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0)\n    return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2)\n    return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1)\n      return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two)\n      return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; )\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_EQUAL:\n        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation\");\n    }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; )\n    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)\n    args[_key] = arguments[_key];\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs) {\n  let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++)\n    v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )\n        x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length)\n        k1end += 2;\n      else if (y1 > text2Length)\n        k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )\n        x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length)\n        k2end += 2;\n      else if (y2 > text2Length)\n        k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n    checkLines: !1,\n    deadline\n  }), diffsb = doDiff(text1b, text2b, {\n    checkLines: !1,\n    deadline\n  });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2) {\n  if ((arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1) <= 0)\n    return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length)\n    return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2)\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2)\n      return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch)\n    throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || \"\", bestLongTextB || \"\", bestShortTextA || \"\", bestShortTextB || \"\", bestCommon || \"\"] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++)\n      text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return {\n    chars1,\n    chars2,\n    lineArray\n  };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1)\n    return [[DIFF_INSERT, text2]];\n  if (!text2)\n    return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1)\n    return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1)\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null)\n    throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2)\n    return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return {\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1),\n    ...opts\n  };\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText2, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText2, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++)\n    diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return {\n    ...DEFAULT_OPTIONS,\n    ...options\n  };\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc) {\n  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n  if (pattern.length > MAX_BITS$1)\n    throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; )\n      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold)\n          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)\n            start = Math.max(1, 2 * loc - bestLoc);\n          else\n            break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold)\n      break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation) {\n  if (text === null || pattern === null || searchLocation === null)\n    throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern)\n    return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern)\n      return loc;\n  } else return -1;\n  return bitap(text, pattern, loc);\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\")\n      throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base) {\n  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\")\n        return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target)\n      throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches)\n    adjusted.push({\n      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2\n    });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, loc) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)\n    lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);\n}\nfunction addPadding(patches) {\n  const paddingLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (const p of patches)\n    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)\n    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)\n    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction splitMax(patches) {\n  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText) {\n  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  if (typeof patches == \"string\")\n    throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0)\n    return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)\n      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)\n        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, {\n          checkLines: !1\n        });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)\n          results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline)\n    return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(\"Invalid patch string: \".concat(lines[textPointer]));\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\")\n        break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch {\n        throw new Error(\"Illegal escape in parse: \".concat(currentLine));\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\")\n        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\")\n        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \")\n        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else\n        throw new Error('Invalid patch mode \"'.concat(sign, '\" in: ').concat(line));\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nconst debug$i = debugWithName(\"applyPatches\"), debugVerbose$4 = debug$i.enabled && !0;\nfunction createApplyPatch(schemaTypes) {\n  return (editor, patch) => {\n    let changed = !1;\n    debugVerbose$4 && (debug$i(`\n\nNEW PATCH =============================================================`), debug$i(JSON.stringify(patch, null, 2)));\n    try {\n      switch (patch.type) {\n        case \"insert\":\n          changed = insertPatch(editor, patch, schemaTypes);\n          break;\n        case \"unset\":\n          changed = unsetPatch(editor, patch);\n          break;\n        case \"set\":\n          changed = setPatch(editor, patch);\n          break;\n        case \"diffMatchPatch\":\n          changed = diffMatchPatch(editor, patch);\n          break;\n        default:\n          debug$i(\"Unhandled patch\", patch.type);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return changed;\n  };\n}\nfunction diffMatchPatch(editor, patch) {\n  const {\n    block,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$i(\"Block not found\"), !1;\n  if (!child || !childPath)\n    return debug$i(\"Child not found\"), !1;\n  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child))\n    return !1;\n  const patches = parse(patch.value), [newValue] = apply(patches, child.text, {\n    allowExceedingIndices: !0\n  }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);\n  debugState(editor, \"before\");\n  let offset = 0;\n  for (const [op, text] of diff$1)\n    op === DIFF_INSERT ? (editor.apply({\n      type: \"insert_text\",\n      path: childPath,\n      offset,\n      text\n    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({\n      type: \"remove_text\",\n      path: childPath,\n      offset,\n      text\n    }) : op === DIFF_EQUAL && (offset += text.length);\n  return debugState(editor, \"after\"), !0;\n}\nfunction insertPatch(editor, patch, schemaTypes) {\n  const {\n    block: targetBlock,\n    child: targetChild,\n    blockPath: targetBlockPath,\n    childPath: targetChildPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!targetBlock || !targetBlockPath)\n    return debug$i(\"Block not found\"), !1;\n  if (patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$i(\"Ignoring patch targeting void value\"), !1;\n  if (patch.path.length === 1) {\n    const {\n      items: items2,\n      position: position2\n    } = patch, blocksToInsert = toSlateValue(items2, {\n      schemaTypes\n    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex;\n    return debug$i(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, blocksToInsert, {\n      at: [normalizedIdx2]\n    }), debugState(editor, \"after\"), !0;\n  }\n  const {\n    items,\n    position\n  } = patch;\n  if (!targetChild || !targetChildPath)\n    return debug$i(\"Child not found\"), !1;\n  const childrenToInsert = targetBlock && toSlateValue([{\n    ...targetBlock,\n    children: items\n  }], {\n    schemaTypes\n  }, KEY_TO_SLATE_ELEMENT.get(editor)), targetChildIndex = targetChildPath[1], normalizedIdx = position === \"after\" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];\n  return debug$i(`Inserting children at path ${childInsertPath}`), debugState(editor, \"before\"), childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, childrenToInsert[0].children, {\n    at: childInsertPath\n  }), debugState(editor, \"after\"), !0;\n}\nfunction setPatch(editor, patch) {\n  let value = patch.value;\n  typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$i(\"Block not found\"), !1;\n  const isTextBlock = editor.isTextBlock(block);\n  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$i(\"Ignoring setting void value\"), !1;\n  if (debugState(editor, \"before\"), isTextBlock && child && childPath) {\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(value) && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child)) {\n      const newText = child.text;\n      value.text !== newText && (debug$i(\"Setting text property\"), editor.apply({\n        type: \"remove_text\",\n        path: childPath,\n        offset: 0,\n        text: newText\n      }), editor.apply({\n        type: \"insert_text\",\n        path: childPath,\n        offset: 0,\n        text: value.text\n      }), editor.onChange());\n    } else\n      debug$i(\"Setting non-text property\"), editor.apply({\n        type: \"set_node\",\n        path: childPath,\n        properties: {},\n        newProperties: value\n      });\n    return !0;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && patch.path.length === 1 && blockPath) {\n    debug$i(\"Setting block property\");\n    const {\n      children,\n      ...nextRest\n    } = value, {\n      children: prevChildren,\n      ...prevRest\n    } = block || {\n      children: void 0\n    };\n    editor.apply({\n      type: \"set_node\",\n      path: blockPath,\n      properties: {\n        ...prevRest\n      },\n      newProperties: nextRest\n    }), debug$i(\"Setting children\"), block.children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"remove_node\",\n        path: blockPath.concat(block.children.length - 1 - cIndex),\n        node: c2\n      });\n    }), Array.isArray(children) && children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"insert_node\",\n        path: blockPath.concat(cIndex),\n        node: c2\n      });\n    });\n  } else if (block && \"value\" in block) {\n    const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.applyAll)([block.value], [patch])[0];\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n      ...block,\n      value: newVal\n    }, {\n      at: blockPath\n    }), !0;\n  }\n  return debugState(editor, \"after\"), !0;\n}\nfunction unsetPatch(editor, patch) {\n  if (patch.path.length === 0) {\n    debug$i(\"Removing everything\"), debugState(editor, \"before\");\n    const previousSelection = editor.selection;\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.children.forEach((_child, i) => {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n        at: [i]\n      });\n    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n      decorators: []\n    })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), editor.onChange(), debugState(editor, \"after\"), !0;\n  }\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (patch.path.length === 1) {\n    if (!block || !blockPath)\n      return debug$i(\"Block not found\"), !1;\n    const blockIndex = blockPath[0];\n    return debug$i(`Removing block at path [${blockIndex}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: [blockIndex]\n    }), debugState(editor, \"after\"), !0;\n  }\n  return editor.isTextBlock(block) && patch.path[1] === \"children\" && patch.path.length === 3 ? !child || !childPath ? (debug$i(\"Child not found\"), !1) : (debug$i(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, \"before\"), debugVerbose$4 && debug$i(`Removing child at path ${JSON.stringify(childPath)}`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n    at: childPath\n  }), debugState(editor, \"after\"), !0) : !1;\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction debugState(editor, stateName) {\n  debugVerbose$4 && (debug$i(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$i(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));\n}\nfunction findBlockFromPath(editor, path) {\n  let blockIndex = -1;\n  const block = editor.children.find((node, index2) => {\n    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index2 === path[0];\n    return isMatch && (blockIndex = index2), isMatch;\n  });\n  return block ? {\n    block,\n    path: [blockIndex]\n  } : {};\n}\nfunction findBlockAndChildFromPath(editor, path) {\n  const {\n    block,\n    path: blockPath\n  } = findBlockFromPath(editor, path);\n  if (!(slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && path[1] === \"children\"))\n    return {\n      block,\n      blockPath,\n      child: void 0,\n      childPath: void 0\n    };\n  let childIndex = -1;\n  const child = block.children.find((node, index2) => {\n    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index2 === path[2];\n    return isMatch && (childIndex = index2), isMatch;\n  });\n  return child ? {\n    block,\n    child,\n    blockPath,\n    childPath: blockPath?.concat(childIndex)\n  } : {\n    block,\n    blockPath,\n    child: void 0,\n    childPath: void 0\n  };\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n  const prev = isPatching(editor);\n  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n  return PATCHING.get(editor);\n}\nconst debug$h = debugWithName(\"plugin:withUndoRedo\"), debugVerbose$3 = debug$h.enabled && !1, SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {\n  const state = SAVING.get(editor);\n  return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n  const {\n    editorActor,\n    readOnly,\n    blockSchemaType\n  } = options;\n  return (editor) => {\n    let previousSnapshot = fromSlateValue(editor.children, blockSchemaType.name);\n    const remotePatches = getRemotePatches(editor);\n    editor.subscriptions.push(() => {\n      debug$h(\"Subscribing to patches\");\n      const sub = editorActor.on(\"patches\", ({\n        patches,\n        snapshot\n      }) => {\n        let reset = !1;\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== \"local\" && remotePatches) {\n            if (patch.type === \"unset\" && patch.path.length === 0) {\n              debug$h(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = {\n                undos: [],\n                redos: []\n              }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n              return;\n            }\n            remotePatches.push({\n              patch,\n              time: /* @__PURE__ */ new Date(),\n              snapshot,\n              previousSnapshot\n            });\n          }\n        }), previousSnapshot = snapshot;\n      });\n      return () => {\n        debug$h(\"Unsubscribing to patches\"), sub.unsubscribe();\n      };\n    }), editor.history = {\n      undos: [],\n      redos: []\n    };\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (readOnly) {\n        apply2(op);\n        return;\n      }\n      const {\n        operations,\n        history\n      } = editor, {\n        undos\n      } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor);\n      let merge = !0;\n      if (save) {\n        if (step ? operations.length === 0 && (merge = shouldMerge(op, lastOp) || overwrite) : merge = !1, step && merge)\n          step.operations.push(op);\n        else {\n          const newStep = {\n            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],\n            timestamp: /* @__PURE__ */ new Date()\n          };\n          undos.push(newStep), debug$h(\"Created new undo step\", step);\n        }\n        for (; undos.length > UNDO_STEP_LIMIT; )\n          undos.shift();\n        shouldClear(op) && (history.redos = []);\n      }\n      apply2(op);\n    }, editor.undo = () => {\n      if (readOnly)\n        return;\n      const {\n        undos\n      } = editor.history;\n      if (undos.length > 0) {\n        const step = undos[undos.length - 1];\n        if (debug$h(\"Undoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n          });\n          const reversedOperations = transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_15__.Operation.inverse).reverse();\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n              withUndoing(editor, () => {\n                withoutSaving(editor, () => {\n                  reversedOperations.forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$h(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n              undos: [],\n              redos: []\n            }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();\n            return;\n          }\n          editor.history.redos.push(step), editor.history.undos.pop();\n        }\n      }\n    }, editor.redo = () => {\n      if (readOnly)\n        return;\n      const {\n        redos\n      } = editor.history;\n      if (redos.length > 0) {\n        const step = redos[redos.length - 1];\n        if (debug$h(\"Redoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n          });\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n              withRedoing(editor, () => {\n                withoutSaving(editor, () => {\n                  transformedOperations.forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$h(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n              undos: [],\n              redos: []\n            }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();\n            return;\n          }\n          editor.history.undos.push(step), editor.history.redos.pop();\n        }\n      }\n    }, editor;\n  };\n}\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n  debugVerbose$3 && (debug$h(`Adjusting '${operation.type}' operation paths for '${patch.type}' patch`), debug$h(`Operation ${JSON.stringify(operation)}`), debug$h(`Patch ${JSON.stringify(patch)}`));\n  const transformedOperation = {\n    ...operation\n  };\n  if (patch.type === \"insert\" && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({\n      _key: blk._key\n    }, patch.path[0]));\n    return debug$h(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({\n      _key: blk._key\n    }, patch.path[0]));\n    return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$h(\"Skipping transformation that targeted removed block\"), []) : (debugVerbose$3 && (debug$h(`Selection ${JSON.stringify(editor.selection)}`), debug$h(`Adjusting block path (-1) for '${transformedOperation.type}' operation and patch '${patch.type}'`)), [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)]);\n  }\n  if (patch.type === \"unset\" && patch.path.length === 0)\n    return debug$h(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n  if (patch.type === \"diffMatchPatch\") {\n    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n    return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({\n      _key: operationTargetBlock._key\n    }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {\n      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n      const {\n        diffs\n      } = diffPatch;\n      if (diffs.forEach((diff2, index2) => {\n        const [diffType, text] = diff2;\n        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index2).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));\n      }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n        const currentFocus = transformedOperation.properties?.focus ? {\n          ...transformedOperation.properties.focus\n        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n          ...transformedOperation.properties.anchor\n        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n          ...transformedOperation.newProperties.focus\n        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n          ...transformedOperation.newProperties.anchor\n        } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor\n        }));\n      }\n    }), [transformedOperation]);\n  }\n  return [transformedOperation];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];\n    transformedOperation.path = newPath;\n  }\n  if (transformedOperation.type === \"set_selection\") {\n    const currentFocus = transformedOperation.properties?.focus ? {\n      ...transformedOperation.properties.focus\n    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n      ...transformedOperation.properties.anchor\n    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n      ...transformedOperation.newProperties.focus\n    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n      ...transformedOperation.newProperties.anchor\n    } : void 0;\n    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);\n    }), currentFocus && currentAnchor && (transformedOperation.properties = {\n      focus: currentFocus,\n      anchor: currentAnchor\n    }), newFocus && newAnchor && (transformedOperation.newProperties = {\n      focus: newFocus,\n      anchor: newAnchor\n    }));\n  }\n  return transformedOperation;\n}\nconst shouldMerge = (op, prev) => !!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op) => op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n  const prev = isSaving(editor);\n  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n  return {\n    type: \"set_selection\",\n    properties: {\n      ...editor.selection\n    },\n    newProperties: {\n      ...editor.selection\n    }\n  };\n}\nfunction findOperationTargetBlock(editor, operation) {\n  let block;\n  return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst debug$g = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({\n  editorActor,\n  patchFunctions,\n  readOnly,\n  schemaTypes\n}) {\n  let previousChildren;\n  const applyPatch = createApplyPatch(schemaTypes);\n  return function(editor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];\n    const {\n      apply: apply2\n    } = editor;\n    let bufferedPatches = [];\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0)\n        return;\n      const patches = bufferedPatches;\n      bufferedPatches = [];\n      let changed = !1;\n      withRemoteChanges(editor, () => {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              patches.forEach((patch) => {\n                debug$g.enabled && debug$g(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch(editor, patch);\n              });\n            });\n          });\n        }), changed && (editor.normalize(), editor.onChange());\n      });\n    }, handlePatches = ({\n      patches\n    }) => {\n      const remotePatches = patches.filter((p) => p.origin !== \"local\");\n      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n    };\n    return editor.subscriptions.push(() => {\n      debug$g(\"Subscribing to remote patches\");\n      const sub = editorActor.on(\"patches\", handlePatches);\n      return () => {\n        debug$g(\"Unsubscribing to remote patches\"), sub.unsubscribe();\n      };\n    }), editor.apply = (operation) => {\n      if (readOnly)\n        return apply2(operation), editor;\n      let patches = [];\n      previousChildren = editor.children;\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);\n      apply2(operation);\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);\n      if (!isPatching(editor))\n        return editor;\n      switch (editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)(previousChildren, \"before\", [0])), operation.type) {\n        case \"insert_text\":\n          patches = [...patches, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_text\":\n          patches = [...patches, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_node\":\n          patches = [...patches, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"split_node\":\n          patches = [...patches, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"insert_node\":\n          patches = [...patches, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"set_node\":\n          patches = [...patches, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"merge_node\":\n          patches = [...patches, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"move_node\":\n          patches = [...patches, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];\n          break;\n      }\n      return !editorWasEmpty && editorIsEmpty && [\"merge_node\", \"set_node\", \"remove_text\", \"remove_node\"].includes(operation.type) && (patches = [...patches, (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([])], editorActor.send({\n        type: \"unset\",\n        previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n      })), editorWasEmpty && patches.length > 0 && (patches = [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.setIfMissing)([], []), ...patches]), patches.length > 0 && patches.forEach((patch) => {\n        editorActor.send({\n          type: \"patch\",\n          patch: {\n            ...patch,\n            origin: \"local\"\n          }\n        });\n      }), editor;\n    }, editor;\n  };\n}\nconst debug$f = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock() {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"remove_node\") {\n        const node = op.node;\n        if (op.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, node)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(op.path);\n          editor.children[nextPath[0]] || (debug$f(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n            decorators: []\n          })));\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst debug$e = debugWithName(\"plugin:withPortableTextBlockStyle\");\nfunction createWithPortableTextBlockStyle(editorActor, types) {\n  const defaultStyle = types.styles[0].value;\n  return function(editor) {\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (nodeEntry) => {\n      const [, path] = nodeEntry;\n      for (const op of editor.operations)\n        if (op.type === \"split_node\" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(path, op.path)) {\n          const [child] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [op.path[0] + 1, 0]);\n          if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && child.text === \"\") {\n            debug$e(`Normalizing split node to ${defaultStyle} style`, op), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              style: defaultStyle\n            }, {\n              at: [op.path[0] + 1],\n              voids: !1\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      normalizeNode(nodeEntry);\n    }, editor.pteHasBlockStyle = (style) => editor.selection ? [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node) && node.style === style\n    })].length > 0 : !1, editor.pteToggleBlockStyle = (blockStyle) => {\n      editor.selection && ([...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      })].forEach(([node, path]) => {\n        editor.isTextBlock(node) && node.style === blockStyle ? (debug$e(`Unsetting block style '${blockStyle}'`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          ...node,\n          style: defaultStyle\n        }, {\n          at: path\n        })) : (blockStyle ? debug$e(`Setting style '${blockStyle}'`) : debug$e(\"Setting default style\", defaultStyle), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          ...node,\n          style: blockStyle || defaultStyle\n        }, {\n          at: path\n        }));\n      }), editor.onChange());\n    }, editor;\n  };\n}\nconst debug$d = debugWithName(\"plugin:withPortableTextLists\"), MAX_LIST_LEVEL = 10;\nfunction createWithPortableTextLists(types) {\n  return function(editor) {\n    return editor.pteToggleListItem = (listItemStyle) => {\n      editor.pteHasListStyle(listItemStyle) ? (debug$d(`Remove list item '${listItemStyle}'`), editor.pteUnsetListItem(listItemStyle)) : (debug$d(`Add list item '${listItemStyle}'`), editor.pteSetListItem(listItemStyle));\n    }, editor.pteUnsetListItem = (listItemStyle) => {\n      editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node) && node._type === types.block.name\n      })].forEach(([node, path]) => {\n        if (editor.isListBlock(node)) {\n          const {\n            listItem,\n            level,\n            ...rest\n          } = node, newNode = {\n            ...rest,\n            listItem: void 0,\n            level: void 0\n          };\n          debug$d(`Unsetting list '${listItemStyle}'`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, newNode, {\n            at: path\n          });\n        }\n      });\n    }, editor.pteSetListItem = (listItemStyle) => {\n      editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      })].forEach(([node, path]) => {\n        debug$d(`Setting list '${listItemStyle}'`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          ...node,\n          level: 1,\n          listItem: listItemStyle || types.lists[0] && types.lists[0].value\n        }, {\n          at: path\n        });\n      });\n    }, editor.pteEndList = () => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node) && editor.isListBlock(node) && node.children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node.children[0]) && node.children[0].text === \"\"\n      })];\n      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node) && (debug$d(\"Unset list\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          ...node,\n          level: void 0,\n          listItem: void 0\n        }, {\n          at: path\n        }));\n      }), !0);\n    }, editor.pteIncrementBlockLevels = (reverse) => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => !!editor.isListBlock(node)\n      })];\n      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {\n        if (editor.isListBlock(node)) {\n          let level = node.level || 1;\n          reverse ? (level--, debug$d(\"Decrementing list level\", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))) : (level++, debug$d(\"Incrementing list level\", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            level: Math.min(MAX_LIST_LEVEL, Math.max(1, level))\n          }, {\n            at: path\n          });\n        }\n      }), !0);\n    }, editor.pteHasListStyle = (listStyle) => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      })];\n      return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listStyle) : !1;\n    }, editor;\n  };\n}\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def) => typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let previousSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n    reverse: !0\n  }))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, spanPath)) {\n      previousSpan = child;\n      break;\n    }\n  return previousSpan;\n}\nfunction getNextSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let nextSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, spanPath)) {\n      nextSpan = child;\n      break;\n    }\n  return nextSpan;\n}\nconst debug$c = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(editorActor, types) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor, decorators = types.decorators.map((t) => t.value), forceNewSelection = () => {\n      editor.selection && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n        ...editor.selection\n      }), editor.selection = {\n        ...editor.selection\n      });\n      const ptRange = toPortableTextRange(editor.children, editor.selection, types);\n      editorActor.send({\n        type: \"selection\",\n        selection: ptRange\n      });\n    };\n    return editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry;\n      if (editor.isTextBlock(node)) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path);\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1];\n          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(child.marks, nextNode.marks)) {\n            debug$c(\"Merging spans\", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: !0\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug$c(\"Adding .markDefs to block node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          markDefs: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug$c(\"Adding .marks to span node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath), decorators2 = types.decorators.map((decorator) => decorator.value), annotations = node.marks?.filter((mark) => !decorators2.includes(mark));\n        if (editor.isTextBlock(block) && node.text === \"\" && annotations && annotations.length > 0) {\n          debug$c(\"Removing annotations from empty span node\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            marks: node.marks?.filter((mark) => decorators2.includes(mark))\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const decorators2 = types.decorators.map((decorator) => decorator.value);\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !node.markDefs?.find((def) => def._key === mark));\n            if (orphanedAnnotations.length > 0) {\n              debug$c(\"Removing orphaned annotations from span node\"), editorActor.send({\n                type: \"normalizing\"\n              }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n              }, {\n                at: childPath\n              }), editorActor.send({\n                type: \"done normalizing\"\n              });\n              return;\n            }\n          }\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath);\n        if (editor.isTextBlock(block)) {\n          const decorators2 = types.decorators.map((decorator) => decorator.value), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !block.markDefs?.find((def) => def._key === mark));\n          if (orphanedAnnotations.length > 0) {\n            debug$c(\"Removing orphaned annotations from span node\"), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n            }, {\n              at: path\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];\n        for (const markDef of markDefs)\n          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));\n        if (markDefs.length !== newMarkDefs.length) {\n          debug$c(\"Removing duplicate markDefs\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1)) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n        if (node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(newMarkDefs, node.markDefs)) {\n          debug$c(\"Removing markDef not in use\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      normalizeNode(nodeEntry);\n    }, editor.apply = (op) => {\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"set_selection\" && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {\n        const previousSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n          anchor: op.properties.anchor,\n          focus: op.properties.focus\n        }), newSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n          anchor: op.newProperties.anchor,\n          focus: op.newProperties.focus\n        });\n        if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n          const focusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.properties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], newFocusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.newProperties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;\n          if (movedToNextSpan || movedToPreviousSpan)\n            return;\n        }\n      }\n      if (op.type === \"insert_node\") {\n        const {\n          selection\n        } = editor;\n        if (selection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath: op.path\n          }), previousSpanAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath: [op.path[0], op.path[1] - 1]\n          }), nextSpanAnnotations = nextSpan ? nextSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], annotationsEnding = previousSpanAnnotations?.filter((annotation) => !nextSpanAnnotations?.includes(annotation)) ?? [];\n          if (annotationsEnding.length > 0 && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsEnding.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: op.node.marks?.filter((mark) => !annotationsEnding.includes(mark)) ?? []\n            });\n            return;\n          }\n          const annotationsStarting = nextSpanAnnotations?.filter((annotation) => !previousSpanAnnotations?.includes(annotation)) ?? [];\n          if (annotationsStarting.length > 0 && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsStarting.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: op.node.marks?.filter((mark) => !annotationsStarting.includes(mark)) ?? []\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"insert_text\") {\n        const {\n          selection\n        } = editor, collapsedSelection = selection ? slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(selection) : !1;\n        if (selection && collapsedSelection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: selection.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0], marks = span.marks ?? [], marksWithoutAnnotations = marks.filter((mark) => decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = span.text.length === 0, atTheBeginningOfSpan = selection.anchor.offset === 0, atTheEndOfSpan = selection.anchor.offset === span.text.length, previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpanAnnotations = nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark) => !decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)).every((mark) => marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.marks?.every((mark) => marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) => nextSpanAnnotations?.includes(mark));\n          if (spanHasAnnotations && !spanIsEmpty) {\n            if (atTheBeginningOfSpan) {\n              if (previousSpanHasSameMarks) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotation) {\n                apply2(op);\n                return;\n              } else if (!previousSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n            if (atTheEndOfSpan) {\n              if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: nextSpan?.marks ?? []\n                });\n                return;\n              }\n              if (!nextSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n          }\n          if (atTheBeginningOfSpan && !spanIsEmpty && previousSpan) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              _type: \"span\",\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              text: op.text,\n              marks: previousSpanHasAnnotations ? [] : (previousSpan.marks ?? []).filter((mark) => decorators.includes(mark))\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"remove_text\") {\n        const {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: {\n              path: op.path,\n              offset: op.offset\n            },\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0];\n          if (span && block && isPortableTextBlock(block)) {\n            const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark) => markDefs.find((markDef) => markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), nextSpan = getNextSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;\n            if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {\n              const marksWithoutAnnotationMarks = ({\n                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n              }.marks || []).filter((mark) => decorators.includes(mark));\n              slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n                apply2(op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                  marks: marksWithoutAnnotationMarks\n                }, {\n                  at: op.path\n                });\n              }), editor.onChange();\n              return;\n            }\n          }\n        }\n      }\n      if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n        const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [op.path[0] - 1]);\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__([...oldDefs, ...op.properties.markDefs]);\n          debug$c(\"Copying markDefs over to merged block\", op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: targetPath,\n            voids: !1\n          }), apply2(op);\n          return;\n        }\n      }\n      apply2(op);\n    }, editor.addMark = (mark) => {\n      if (editor.selection) {\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection))\n          slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n              match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n              split: !0,\n              hanging: !0\n            });\n            const splitTextNodes = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(editor.selection) ? [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n              at: editor.selection,\n              match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText\n            })] : [];\n            splitTextNodes.length > 1 && splitTextNodes.every((node) => node[0].marks?.includes(mark)) ? editor.removeMark(mark) : splitTextNodes.forEach(([node, path]) => {\n              const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];\n              slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                marks\n              }, {\n                at: path,\n                match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n                split: !0,\n                hanging: !0\n              });\n            });\n          });\n        else {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n            depth: 1\n          }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n          if (lonelyEmptySpan) {\n            const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator\n            }, {\n              at: blockPath,\n              match: (node) => editor.isTextSpan(node)\n            });\n          } else {\n            const existingMarks = {\n              ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n            }.marks || [], marks = {\n              ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n              marks: [...existingMarks, mark]\n            };\n            return editor.marks = marks, forceNewSelection(), editor;\n          }\n        }\n        editor.onChange(), forceNewSelection();\n      }\n      return editor;\n    }, editor.removeMark = (mark) => {\n      const {\n        selection\n      } = editor;\n      if (selection) {\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection))\n          slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n              match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n              split: !0,\n              hanging: !0\n            }), editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n              at: editor.selection,\n              match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText\n            })].forEach(([node, path]) => {\n              const block = editor.children[path[0]];\n              slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),\n                _type: \"span\"\n              }, {\n                at: path\n              });\n            });\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.normalize(editor);\n        else {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n          if (lonelyEmptySpan) {\n            const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              marks: existingMarksWithoutDecorator\n            }, {\n              at: blockPath,\n              match: (node) => editor.isTextSpan(node)\n            });\n          } else {\n            const existingMarks = {\n              ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n            }.marks || [], marks = {\n              ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n              marks: existingMarks.filter((eMark) => eMark !== mark)\n            };\n            return editor.marks = {\n              marks: marks.marks,\n              _type: \"span\"\n            }, forceNewSelection(), editor;\n          }\n        }\n        editor.onChange(), forceNewSelection();\n      }\n      return editor;\n    }, editor.pteIsMarkActive = (mark) => {\n      if (!editor.selection)\n        return !1;\n      const selectedNodes = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        at: editor.selection\n      }));\n      return slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection) ? selectedNodes.every((n) => {\n        const [node] = n;\n        return node.marks?.includes(mark);\n      }) : ({\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n      }.marks || []).includes(mark);\n    }, editor.pteToggleMark = (mark) => {\n      editor.pteIsMarkActive(mark) ? (debug$c(`Remove mark '${mark}'`), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.removeMark(editor, mark)) : (debug$c(`Add mark '${mark}'`), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.addMark(editor, mark, !0));\n    }, editor;\n  };\n}\nconst debug$b = debugWithName(\"plugin:withPortableTextSelections\"), debugVerbose$2 = debug$b.enabled && !1;\nfunction createWithPortableTextSelections(editorActor, types) {\n  let prevSelection = null;\n  return function(editor) {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          if (existing)\n            ptRange = existing;\n          else {\n            const value = editor.children;\n            ptRange = toPortableTextRange(value, editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n          }\n        }\n        debugVerbose$2 && debug$b(`Emitting selection ${JSON.stringify(ptRange || null)} (${JSON.stringify(editor.selection)})`), ptRange ? editorActor.send({\n          type: \"selection\",\n          selection: ptRange\n        }) : editorActor.send({\n          type: \"selection\",\n          selection: null\n        });\n      }\n      prevSelection = editor.selection;\n    }, {\n      onChange\n    } = editor;\n    return editor.onChange = () => {\n      const hasChanges = editor.operations.length > 0;\n      onChange(), hasChanges && emitPortableTextSelection();\n    }, editor;\n  };\n}\nconst debug$a = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({\n  editorActor,\n  schemaTypes\n}) {\n  return function(editor) {\n    editor.isTextBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(value) && value._type === schemaTypes.block.name, editor.isTextSpan = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(value) && value._type === schemaTypes.span.name, editor.isListBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextListBlock)(value) && value._type === schemaTypes.block.name, editor.isVoid = (element) => schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj) => obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (node._type === void 0 && path.length === 2) {\n        debug$a(\"Setting span type on text node without a type\");\n        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          ...span,\n          _type: schemaTypes.span.name,\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n        debug$a(\"Setting missing key on child node without a key\");\n        const key = editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$9 = debugWithName(\"plugin:withUtils\");\nfunction createWithUtils({\n  editorActor,\n  schemaTypes,\n  portableTextEditor\n}) {\n  return function(editor) {\n    return editor.pteExpandToWord = () => {\n      const {\n        selection\n      } = editor;\n      if (selection && !slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n        const [textNode] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection.focus, {\n          depth: 2\n        });\n        if (!textNode || !slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(textNode) || textNode.text.length === 0) {\n          debug$9(\"pteExpandToWord: Can't expand to word here\");\n          return;\n        }\n        const {\n          focus\n        } = selection, focusOffset = focus.offset, charsBefore = textNode.text.slice(0, focusOffset), charsAfter = textNode.text.slice(focusOffset, -1), isEmpty = (str) => str.match(/\\s/g), whiteSpaceBeforeIndex = charsBefore.split(\"\").reverse().findIndex((str) => isEmpty(str)), newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0, whiteSpaceAfterIndex = charsAfter.split(\"\").findIndex((obj) => isEmpty(obj)), newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);\n        if (!(newStartOffset === newEndOffset || Number.isNaN(newStartOffset) || Number.isNaN(newEndOffset))) {\n          debug$9(\"pteExpandToWord: Expanding to focused word\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n            anchor: {\n              ...selection.anchor,\n              offset: newStartOffset\n            },\n            focus: {\n              ...selection.focus,\n              offset: newEndOffset\n            }\n          });\n          return;\n        }\n        debug$9(\"pteExpandToWord: Can't expand to word here\");\n      }\n    }, editor.pteCreateTextBlock = (options) => toSlateValue([{\n      _type: schemaTypes.block.name,\n      _key: editorActor.getSnapshot().context.keyGenerator(),\n      style: schemaTypes.styles[0].value || \"normal\",\n      ...options.listItem ? {\n        listItem: options.listItem\n      } : {},\n      ...options.level ? {\n        level: options.level\n      } : {},\n      markDefs: [],\n      children: [{\n        _type: \"span\",\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        text: \"\",\n        marks: options.decorators.filter((decorator) => schemaTypes.decorators.find(({\n          value\n        }) => value === decorator))\n      }]\n    }], portableTextEditor)[0], editor;\n  };\n}\nconst debug$8 = debugWithName(\"plugin:withHotKeys\"), DEFAULT_HOTKEYS = {\n  marks: {\n    \"mod+b\": \"strong\",\n    \"mod+i\": \"em\",\n    \"mod+u\": \"underline\",\n    \"mod+'\": \"code\"\n  },\n  custom: {}\n};\nfunction createWithHotkeys(portableTextEditor, hotkeysFromOptions) {\n  const reservedHotkeys = [\"enter\", \"tab\", \"shift\", \"delete\", \"end\"], activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;\n  return function(editor) {\n    return editor.pteWithHotKeys = (event) => {\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === \"marks\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(hotkey, event.nativeEvent)) {\n              event.preventDefault();\n              const possibleMark = activeHotkeys[cat];\n              if (possibleMark) {\n                const mark = possibleMark[hotkey];\n                debug$8(`HotKey ${hotkey} to toggle ${mark}`), editor.pteToggleMark(mark);\n              }\n            }\n          }\n        if (cat === \"custom\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat];\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey];\n                command(event, portableTextEditor);\n              }\n            }\n          }\n      });\n      const isEnter = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(\"enter\", event.nativeEvent), isTab = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(\"tab\", event.nativeEvent), isShiftEnter = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(\"shift+enter\", event.nativeEvent), isShiftTab = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(\"shift+tab\", event.nativeEvent), isArrowDown = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(\"down\", event.nativeEvent), isArrowUp = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_20__.isHotkey)(\"up\", event.nativeEvent);\n      if (isArrowDown && editor.selection) {\n        const focusBlock = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (focusBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, focusBlock)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(editor.selection.focus.path.slice(0, 1));\n          if (!slate__WEBPACK_IMPORTED_MODULE_15__.Node.has(editor, nextPath)) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n              decorators: []\n            }), {\n              at: nextPath\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n              path: [...nextPath, 0],\n              offset: 0\n            }), editor.onChange();\n            return;\n          }\n        }\n      }\n      if (isArrowUp && editor.selection) {\n        const isFirstBlock = editor.selection.focus.path[0] === 0, focusBlock = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (isFirstBlock && focusBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, focusBlock)) {\n          slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n            decorators: []\n          }), {\n            at: [0]\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n            path: [0, 0],\n            offset: 0\n          }), editor.onChange();\n          return;\n        }\n      }\n      if ((isTab || isShiftTab) && editor.selection) {\n        const [focusChild] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection.focus, {\n          depth: 2\n        }), [focusBlock] = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(focusChild) ? slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection.focus, {\n          depth: 1\n        }) : [], hasAnnotationFocus = focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(focusBlock) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(focusChild) && (focusChild.marks || []).filter((m) => (focusBlock.markDefs || []).map((def) => def._key).includes(m)).length > 0, [start] = slate__WEBPACK_IMPORTED_MODULE_15__.Range.edges(editor.selection), atStartOfNode = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isStart(editor, start, start.path);\n        focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(focusChild) && (!hasAnnotationFocus || atStartOfNode) && editor.pteIncrementBlockLevels(isShiftTab) && event.preventDefault();\n      }\n      if (isEnter && !isShiftEnter && editor.selection) {\n        const focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, focusBlockPath);\n        if (editor.isListBlock(focusBlock)) {\n          editor.pteEndList() && event.preventDefault();\n          return;\n        }\n      }\n    }, editor;\n  };\n}\nfunction validateValue(value, types, keyGenerator) {\n  let resolution = null, valid = !0;\n  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];\n  return value === void 0 ? {\n    valid: !0,\n    resolution: null,\n    value\n  } : !Array.isArray(value) || value.length === 0 ? {\n    valid: !1,\n    resolution: {\n      patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([])],\n      description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n      action: \"Unset the value\",\n      item: value,\n      i18n: {\n        description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n        action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n      }\n    },\n    value\n  } : (value.some((blk, index2) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_11__(blk))\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([index2])],\n        description: `Block must be an object, got ${String(blk)}`,\n        action: \"Unset invalid item\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n          action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n          values: {\n            index: index2\n          }\n        }\n      }, !0;\n    if (!blk._key || typeof blk._key != \"string\")\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n          ...blk,\n          _key: keyGenerator()\n        }, [index2])],\n        description: `Block at index ${index2} is missing required _key.`,\n        action: \"Set the block with a random _key value\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-key.description\",\n          action: \"inputs.portable-text.invalid-value.missing-key.action\",\n          values: {\n            index: index2\n          }\n        }\n      }, !0;\n    if (!blk._type || !validBlockTypes.includes(blk._type)) {\n      if (blk._type === \"block\") {\n        const currentBlockTypeName = types.block.name;\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n            ...blk,\n            _type: currentBlockTypeName\n          }, [{\n            _key: blk._key\n          }])],\n          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n          action: `Use type '${currentBlockTypeName}'`,\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n            action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n            values: {\n              key: blk._key,\n              expectedTypeName: currentBlockTypeName\n            }\n          }\n        }, !0;\n      }\n      return !blk._type && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)({\n        ...blk,\n        _type: types.block.name\n      }) ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n          ...blk,\n          _type: types.block.name\n        }, [{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n        action: `Use type '${types.block.name}'`,\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n          values: {\n            key: blk._key,\n            expectedTypeName: types.block.name\n          }\n        }\n      }, !0) : blk._type ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n          action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n          values: {\n            key: blk._key,\n            typeName: blk._type\n          }\n        }\n      }, !0) : (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing an _type property`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-type.action\",\n          values: {\n            key: blk._key\n          }\n        }\n      }, !0);\n    }\n    if (blk._type === types.block.name) {\n      const textBlock = blk;\n      if (textBlock.children && !Array.isArray(textBlock.children))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n            children: []\n          }, [{\n            _key: textBlock._key\n          }])],\n          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n          action: \"Reset the children property\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n            values: {\n              key: textBlock._key\n            }\n          }\n        }, !0;\n      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n        const newSpan = {\n          _type: types.span.name,\n          _key: keyGenerator(),\n          text: \"\",\n          marks: []\n        };\n        return resolution = {\n          autoResolve: !0,\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.setIfMissing)([], [{\n            _key: blk._key\n          }, \"children\"]), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([newSpan], \"after\", [{\n            _key: blk._key\n          }, \"children\", 0])],\n          description: `Children for text block with _key '${blk._key}' is empty.`,\n          action: \"Insert an empty text\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.empty-children.description\",\n            action: \"inputs.portable-text.invalid-value.empty-children.action\",\n            values: {\n              key: blk._key\n            }\n          }\n        }, !0;\n      }\n      const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])));\n      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n        const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)));\n        if (unusedMarkDefs.length > 0)\n          return resolution = {\n            autoResolve: !0,\n            patches: unusedMarkDefs.map((markDefKey) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n              _key: blk._key\n            }, \"markDefs\", {\n              _key: markDefKey\n            }])),\n            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\", \")}.`,\n            action: \"Remove unused mark definition item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n              values: {\n                key: blk._key,\n                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())\n              }\n            }\n          }, !0;\n      }\n      const orphanedMarks = allUsedMarks.filter((mark) => !types.decorators.map((dec) => dec.value).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));\n      if (orphanedMarks.length > 0) {\n        const spanChildren = textBlock.children.filter((cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));\n        if (spanChildren) {\n          const orphaned = orphanedMarks.join(\", \");\n          return resolution = {\n            autoResolve: !0,\n            patches: spanChildren.map((child) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{\n              _key: blk._key\n            }, \"children\", {\n              _key: child._key\n            }, \"marks\"])),\n            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n            action: \"Remove invalid marks\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n              values: {\n                key: blk._key,\n                orphanedMarks: orphanedMarks.map((m) => m.toString())\n              }\n            }\n          }, !0;\n        }\n      }\n      textBlock.children.some((child, cIndex) => {\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_11__(child))\n          return resolution = {\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n            action: \"Remove the item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n              action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        if (!child._key || typeof child._key != \"string\") {\n          const newChild = {\n            ...child,\n            _key: keyGenerator()\n          };\n          return resolution = {\n            autoResolve: !0,\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(newChild, [{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n            action: \"Set a new random _key on the object\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n              action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        }\n        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n            ...child,\n            text: \"\"\n          }, [{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n          action: \"Write an empty text property to the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n            action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0) : !1 : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key,\n              childType: child._type\n            }\n          }\n        }, !0) : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0);\n      }) && (valid = !1);\n    }\n    return !1;\n  }) && (valid = !1), {\n    valid,\n    resolution,\n    value\n  });\n}\nconst debug$7 = debugWithName(\"plugin:withInsertData\");\nfunction createWithInsertData(editorActor, schemaTypes) {\n  return function(editor) {\n    const blockTypeName = schemaTypes.block.name, spanTypeName = schemaTypes.span.name, whitespaceOnPasteMode = schemaTypes.block.options.unstable_whitespaceOnPasteMode, toPlainText = (blocks) => blocks.map((block) => editor.isTextBlock(block) ? block.children.map((child) => child._type === spanTypeName ? child.text : `[${schemaTypes.inlineObjects.find((t) => t.name === child._type)?.title || \"Object\"}]`).join(\"\") : `[${schemaTypes.blockObjects.find((t) => t.name === block._type)?.title || \"Object\"}]`).join(`\n\n`);\n    return editor.setFragmentData = (data, originEvent) => {\n      const {\n        selection\n      } = editor;\n      if (!selection)\n        return;\n      const [start, end] = slate__WEBPACK_IMPORTED_MODULE_15__.Range.edges(selection), startVoid = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.void(editor, {\n        at: start.path\n      }), endVoid = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.void(editor, {\n        at: end.path\n      });\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(selection) && !startVoid)\n        return;\n      const domRange = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMRange(editor, selection);\n      let contents = domRange.cloneContents();\n      if (endVoid) {\n        const [voidNode] = endVoid, r = domRange.cloneRange(), domNode = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(editor, voidNode);\n        r.setEndAfter(domNode), contents = r.cloneContents();\n      }\n      Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw) => {\n        const isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n        zw.textContent = isNewline ? `\n` : \"\";\n      }), Array.from(contents.querySelectorAll(\"*\")).forEach((elm) => {\n        elm.removeAttribute(\"contentEditable\"), elm.removeAttribute(\"data-slate-inline\"), elm.removeAttribute(\"data-slate-leaf\"), elm.removeAttribute(\"data-slate-node\"), elm.removeAttribute(\"data-slate-spacer\"), elm.removeAttribute(\"data-slate-string\"), elm.removeAttribute(\"data-slate-zero-width\"), elm.removeAttribute(\"draggable\");\n        for (const key in elm.attributes)\n          elm.hasAttribute(key) && elm.removeAttribute(key);\n      });\n      const div = contents.ownerDocument.createElement(\"div\");\n      div.appendChild(contents), div.setAttribute(\"hidden\", \"true\"), contents.ownerDocument.body.appendChild(div);\n      const asHTML = div.innerHTML;\n      contents.ownerDocument.body.removeChild(div);\n      const fragment = editor.getFragment(), portableText = fromSlateValue(fragment, blockTypeName), asJSON = JSON.stringify(portableText), asPlainText = toPlainText(portableText);\n      data.clearData(), data.setData(\"text/plain\", asPlainText), data.setData(\"text/html\", asHTML), data.setData(\"application/json\", asJSON), data.setData(\"application/x-portable-text\", asJSON), debug$7(\"text\", asPlainText), data.setData(\"application/x-portable-text-event-origin\", originEvent || \"external\"), debug$7(\"Set fragment data\", asJSON, asHTML);\n    }, editor.insertPortableTextData = (data) => {\n      if (!editor.selection)\n        return !1;\n      const pText = data.getData(\"application/x-portable-text\"), origin = data.getData(\"application/x-portable-text-event-origin\");\n      if (debug$7(`Inserting portable text from ${origin} event`, pText), pText) {\n        const parsed = JSON.parse(pText);\n        if (Array.isArray(parsed) && parsed.length > 0) {\n          const slateValue = _regenerateKeys(editor, toSlateValue(parsed, {\n            schemaTypes\n          }), editorActor.getSnapshot().context.keyGenerator, spanTypeName, schemaTypes), validation = validateValue(parsed, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n          if (!validation.valid && !validation.resolution?.autoResolve) {\n            const errorDescription = `${validation.resolution?.description}`;\n            return editorActor.send({\n              type: \"error\",\n              name: \"pasteError\",\n              description: errorDescription,\n              data: validation\n            }), debug$7(\"Invalid insert result\", validation), !1;\n          }\n          return _insertFragment(editor, slateValue, schemaTypes), !0;\n        }\n      }\n      return !1;\n    }, editor.insertTextOrHTMLData = (data) => {\n      if (!editor.selection)\n        return debug$7(\"No selection, not inserting\"), !1;\n      const html = data.getData(\"text/html\"), text = data.getData(\"text/plain\");\n      if (html || text) {\n        debug$7(\"Inserting data\", data);\n        let portableText, fragment, insertedType;\n        if (html) {\n          if (portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_21__.htmlToBlocks)(html, schemaTypes.portableText, {\n            unstable_whitespaceOnPasteMode: whitespaceOnPasteMode\n          }).map((block) => (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_21__.normalizeBlock)(block, {\n            blockTypeName\n          })), fragment = toSlateValue(portableText, {\n            schemaTypes\n          }), insertedType = \"HTML\", portableText.length === 0)\n            return !1;\n        } else {\n          const textToHtml = `<html><body>${escapeHtml(text).split(/\\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\").join(\"\")}</body></html>`;\n          portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_21__.htmlToBlocks)(textToHtml, schemaTypes.portableText).map((block) => (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_21__.normalizeBlock)(block, {\n            blockTypeName\n          })), fragment = toSlateValue(portableText, {\n            schemaTypes\n          }), insertedType = \"text\";\n        }\n        const validation = validateValue(portableText, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n        if (!validation.valid) {\n          const errorDescription = `Could not validate the resulting portable text to insert.\n${validation.resolution?.description}\nTry to insert as plain text (shift-paste) instead.`;\n          return editorActor.send({\n            type: \"error\",\n            name: \"pasteError\",\n            description: errorDescription,\n            data: validation\n          }), debug$7(\"Invalid insert result\", validation), !1;\n        }\n        return debug$7(`Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`), _insertFragment(editor, fragment, schemaTypes), !0;\n      }\n      return !1;\n    }, editor.insertData = (data) => {\n      editor.insertPortableTextData(data) || editor.insertTextOrHTMLData(data);\n    }, editor.insertFragmentData = (data) => {\n      const fragment = data.getData(\"application/x-portable-text\");\n      if (fragment) {\n        const parsed = JSON.parse(fragment);\n        return editor.insertFragment(parsed), !0;\n      }\n      return !1;\n    }, editor;\n  };\n}\nconst entityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#x60;\",\n  \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s) => entityMap[s]);\n}\nfunction _regenerateKeys(editor, fragment, keyGenerator, spanTypeName, editorTypes) {\n  return fragment.map((node) => {\n    const newNode = {\n      ...node\n    };\n    if (editor.isTextBlock(newNode)) {\n      const annotations = editorTypes.annotations.map((t) => t.name);\n      if (annotations.length === 0) {\n        const {\n          markDefs,\n          ...NewNodeNoDefs\n        } = newNode;\n        return {\n          ...NewNodeNoDefs,\n          _key: keyGenerator()\n        };\n      }\n      if ((newNode.markDefs || []).some((def) => !annotations.includes(def._type))) {\n        const allowedAnnotations = (newNode.markDefs || []).filter((def) => annotations.includes(def._type));\n        return {\n          ...newNode,\n          markDefs: allowedAnnotations,\n          _key: keyGenerator()\n        };\n      }\n      newNode.markDefs = (newNode.markDefs || []).map((def) => {\n        const oldKey = def._key, newKey = keyGenerator();\n        return newNode.children = newNode.children.map((child) => child._type === spanTypeName && editor.isTextSpan(child) ? {\n          ...child,\n          marks: child.marks && child.marks.includes(oldKey) ? [...child.marks].filter((mark) => mark !== oldKey).concat(newKey) : child.marks\n        } : child), {\n          ...def,\n          _key: newKey\n        };\n      });\n    }\n    const nodeWithNewKeys = {\n      ...newNode,\n      _key: keyGenerator()\n    };\n    return editor.isTextBlock(nodeWithNewKeys) && (nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({\n      ...child,\n      _key: keyGenerator()\n    }))), nodeWithNewKeys;\n  });\n}\nfunction _insertFragment(editor, fragment, schemaTypes) {\n  editor.withoutNormalizing(() => {\n    if (!editor.selection)\n      return;\n    const [focusBlock, focusPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n      depth: 1\n    });\n    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {\n      const {\n        markDefs\n      } = focusBlock;\n      debug$7(\"Mixing markDefs of focusBlock and fragments[0] block\", markDefs, fragment[0].markDefs), lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(markDefs, fragment[0].markDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        markDefs: lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__([...fragment[0].markDefs || [], ...markDefs || []])\n      }, {\n        at: focusPath,\n        mode: \"lowest\",\n        voids: !1\n      });\n    }\n    isEqualToEmptyEditor(editor.children, schemaTypes) ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n      at: [0, 0]\n    }), editor.insertFragment(fragment), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: [0]\n    })) : editor.insertFragment(fragment);\n  }), editor.onChange();\n}\nconst originalFnMap = /* @__PURE__ */ new WeakMap(), withPlugins = (editor, options) => {\n  const e = editor, {\n    editorActor,\n    portableTextEditor,\n    readOnly,\n    maxBlocks\n  } = options, {\n    schemaTypes\n  } = portableTextEditor;\n  e.subscriptions = [], e.destroy ? e.destroy() : originalFnMap.set(e, {\n    apply: e.apply,\n    onChange: e.onChange,\n    normalizeNode: e.normalizeNode\n  });\n  const operationToPatches = createOperationToPatches(schemaTypes), withObjectKeys = createWithObjectKeys(editorActor, schemaTypes), withSchemaTypes = createWithSchemaTypes({\n    editorActor,\n    schemaTypes\n  }), withEditableAPI = createWithEditableAPI(editorActor, portableTextEditor, schemaTypes), withPatches = createWithPatches({\n    editorActor,\n    patchFunctions: operationToPatches,\n    readOnly,\n    schemaTypes\n  }), withMaxBlocks = createWithMaxBlocks(maxBlocks || -1), withPortableTextLists = createWithPortableTextLists(schemaTypes), withUndoRedo = createWithUndoRedo({\n    editorActor,\n    readOnly,\n    blockSchemaType: schemaTypes.block\n  }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor, schemaTypes), withPortableTextBlockStyle = createWithPortableTextBlockStyle(editorActor, schemaTypes), withPlaceholderBlock = createWithPlaceholderBlock(), withUtils = createWithUtils({\n    editorActor,\n    schemaTypes,\n    portableTextEditor\n  }), withPortableTextSelections = createWithPortableTextSelections(editorActor, schemaTypes), withEventListeners = createWithEventListeners(editorActor);\n  return e.destroy = () => {\n    const originalFunctions = originalFnMap.get(e);\n    if (!originalFunctions)\n      throw new Error(\"Could not find pristine versions of editor functions\");\n    e.apply = originalFunctions.apply, e.history = {\n      undos: [],\n      redos: []\n    }, e.normalizeNode = originalFunctions.normalizeNode, e.onChange = originalFunctions.onChange;\n  }, readOnly ? {\n    editor: withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withUtils(withPlaceholderBlock(withPortableTextLists(withPortableTextSelections(withEditableAPI(e))))))))),\n    subscribe: () => lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__\n  } : {\n    editor: withEventListeners(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(withEditableAPI(e))))))))))))),\n    subscribe: () => {\n      const unsubscribes = [];\n      return editor.subscriptions.forEach((subscribeFn) => {\n        unsubscribes.push(subscribeFn());\n      }), () => {\n        unsubscribes.forEach((unsubscribeFn) => {\n          unsubscribeFn();\n        });\n      };\n    }\n  };\n}, debug$6 = debugWithName(\"component:PortableTextEditor:SlateContainer\");\nfunction SlateContainer(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(26), {\n    editorActor,\n    portableTextEditor,\n    readOnly,\n    maxBlocks\n  } = props;\n  let t0;\n  $[0] !== editorActor || $[1] !== maxBlocks || $[2] !== portableTextEditor || $[3] !== readOnly ? (t0 = () => {\n    debug$6(\"Creating new Slate editor instance\");\n    const {\n      editor,\n      subscribe: _sub\n    } = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_17__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_15__.createEditor)()), {\n      editorActor,\n      maxBlocks,\n      portableTextEditor,\n      readOnly\n    });\n    return KEY_TO_VALUE_ELEMENT.set(editor, {}), KEY_TO_SLATE_ELEMENT.set(editor, {}), [editor, _sub];\n  }, $[0] = editorActor, $[1] = maxBlocks, $[2] = portableTextEditor, $[3] = readOnly, $[4] = t0) : t0 = $[4];\n  const [t1] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(t0), [slateEditor, subscribe] = t1;\n  let t2, t3;\n  $[5] !== subscribe ? (t2 = () => {\n    const unsubscribe = subscribe();\n    return () => {\n      unsubscribe();\n    };\n  }, t3 = [subscribe], $[5] = subscribe, $[6] = t2, $[7] = t3) : (t2 = $[6], t3 = $[7]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t2, t3);\n  let t4, t5;\n  $[8] !== slateEditor || $[9] !== editorActor || $[10] !== maxBlocks || $[11] !== portableTextEditor || $[12] !== readOnly ? (t4 = () => {\n    debug$6(\"Re-initializing plugin chain\"), withPlugins(slateEditor, {\n      editorActor,\n      maxBlocks,\n      portableTextEditor,\n      readOnly\n    });\n  }, t5 = [editorActor, portableTextEditor, maxBlocks, readOnly, slateEditor], $[8] = slateEditor, $[9] = editorActor, $[10] = maxBlocks, $[11] = portableTextEditor, $[12] = readOnly, $[13] = t4, $[14] = t5) : (t4 = $[13], t5 = $[14]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t4, t5);\n  let t6, t7;\n  $[15] !== slateEditor ? (t7 = slateEditor.pteCreateTextBlock({\n    decorators: []\n  }), $[15] = slateEditor, $[16] = t7) : t7 = $[16];\n  let t8;\n  $[17] !== t7 ? (t8 = [t7], $[17] = t7, $[18] = t8) : t8 = $[18], t6 = t8;\n  const initialValue = t6;\n  let t9, t10;\n  $[19] !== slateEditor ? (t9 = () => () => {\n    debug$6(\"Destroying Slate editor\"), slateEditor.destroy();\n  }, t10 = [slateEditor], $[19] = slateEditor, $[20] = t9, $[21] = t10) : (t9 = $[20], t10 = $[21]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t9, t10);\n  let t11;\n  return $[22] !== slateEditor || $[23] !== initialValue || $[24] !== props.children ? (t11 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_17__.Slate, { editor: slateEditor, initialValue, children: props.children }), $[22] = slateEditor, $[23] = initialValue, $[24] = props.children, $[25] = t11) : t11 = $[25], t11;\n}\nSlateContainer.displayName = \"SlateContainer\";\nconst PortableTextEditorReadOnlyContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(!1), usePortableTextEditorReadOnlyStatus = () => {\n  const readOnly = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(PortableTextEditorReadOnlyContext);\n  if (readOnly === void 0)\n    throw new Error(\"The `usePortableTextEditorReadOnly` hook must be used inside the <PortableTextEditor> component's context.\");\n  return readOnly;\n}, debug$5 = debugWithName(\"hook:useSyncValue\"), CURRENT_VALUE = /* @__PURE__ */ new WeakMap();\nfunction useSyncValue(props) {\n  const {\n    editorActor,\n    portableTextEditor,\n    readOnly\n  } = props, schemaTypes = editorActor.getSnapshot().context.schema, previousValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlate)(), updateValueFunctionRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(), updateFromCurrentValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    const currentValue = CURRENT_VALUE.get(portableTextEditor);\n    if (previousValue.current === currentValue) {\n      debug$5(\"Value is the same object as previous, not need to sync\");\n      return;\n    }\n    updateValueFunctionRef.current && currentValue && (debug$5(\"Updating the value debounced\"), updateValueFunctionRef.current(currentValue));\n  }, [portableTextEditor]), updateValueDebounced = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_debounce_js__WEBPACK_IMPORTED_MODULE_13__(updateFromCurrentValue, 1e3, {\n    trailing: !0,\n    leading: !1\n  }), [updateFromCurrentValue]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    const updateFunction = (value) => {\n      CURRENT_VALUE.set(portableTextEditor, value);\n      const isProcessingLocalChanges = isChangingLocally(slateEditor), isProcessingRemoteChanges = isChangingRemotely(slateEditor);\n      if (!readOnly) {\n        if (isProcessingLocalChanges) {\n          debug$5(\"Has local changes, not syncing value right now\"), updateValueDebounced();\n          return;\n        }\n        if (isProcessingRemoteChanges) {\n          debug$5(\"Has remote changes, not syncing value right now\"), updateValueDebounced();\n          return;\n        }\n      }\n      let isChanged = !1, isValid = !0;\n      const hadSelection = !!slateEditor.selection;\n      if ((!value || value.length === 0) && (debug$5(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n        withoutSaving(slateEditor, () => {\n          withoutPatching(slateEditor, () => {\n            hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor);\n            const childrenLength = slateEditor.children.length;\n            slateEditor.children.forEach((_, index2) => {\n              slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                at: [childrenLength - 1 - index2]\n              });\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n              decorators: []\n            }), {\n              at: [0]\n            }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, [0, 0]);\n          });\n        });\n      }), isChanged = !0), value && value.length > 0) {\n        const slateValueFromProps = toSlateValue(value, {\n          schemaTypes\n        });\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n          withRemoteChanges(slateEditor, () => {\n            withoutSaving(slateEditor, () => {\n              withoutPatching(slateEditor, () => {\n                const childrenLength_0 = slateEditor.children.length;\n                if (slateValueFromProps.length < childrenLength_0) {\n                  for (let i = childrenLength_0 - 1; i > slateValueFromProps.length - 1; i--)\n                    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                      at: [i]\n                    });\n                  isChanged = !0;\n                }\n                slateValueFromProps.forEach((currentBlock, currentBlockIndex) => {\n                  const oldBlock = slateEditor.children[currentBlockIndex];\n                  if (oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(currentBlock, oldBlock) && isValid) {\n                    const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n                    !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !readOnly && previousValue.current && previousValue.current !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {\n                      editorActor.send({\n                        type: \"patch\",\n                        patch\n                      });\n                    })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$5.enabled && debug$5(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$5.enabled && debug$5(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), isChanged = !0) : (editorActor.send({\n                      type: \"invalid value\",\n                      resolution: validation.resolution,\n                      value\n                    }), isValid = !1);\n                  }\n                  if (!oldBlock && isValid) {\n                    const validationValue_0 = [value[currentBlockIndex]], validation_0 = validateValue(validationValue_0, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n                    debug$5.enabled && debug$5(\"Validating and inserting new block in the end of the value\", currentBlock), validation_0.valid || validation_0.resolution?.autoResolve ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n                      at: [currentBlockIndex]\n                    }) : (debug$5(\"Invalid\", validation_0), editorActor.send({\n                      type: \"invalid value\",\n                      resolution: validation_0.resolution,\n                      value\n                    }), isValid = !1);\n                  }\n                });\n              });\n            });\n          });\n        });\n      }\n      if (!isValid) {\n        debug$5(\"Invalid value, returning\");\n        return;\n      }\n      if (isChanged) {\n        debug$5(\"Server value changed, syncing editor\");\n        try {\n          slateEditor.onChange();\n        } catch (err) {\n          console.error(err), editorActor.send({\n            type: \"invalid value\",\n            resolution: null,\n            value\n          });\n          return;\n        }\n        hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, {\n          anchor: {\n            path: [0, 0],\n            offset: 0\n          },\n          focus: {\n            path: [0, 0],\n            offset: 0\n          }\n        }), slateEditor.onChange()), editorActor.send({\n          type: \"value changed\",\n          value\n        });\n      } else\n        debug$5(\"Server value and editor value is equal, no need to sync.\");\n      previousValue.current = value;\n    };\n    return updateValueFunctionRef.current = updateFunction, updateFunction;\n  }, [editorActor, portableTextEditor, readOnly, schemaTypes, slateEditor, updateValueDebounced]);\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n  selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n    at: [currentBlockIndex]\n  }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n  if (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n    const oldBlockChildrenLength = oldBlock.children.length;\n    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index2) => {\n      const childIndex = oldBlockChildrenLength - 1 - index2;\n      childIndex > 0 && (debug$5(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n        at: [currentBlockIndex, childIndex]\n      }));\n    }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {\n      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(currentBlockChild.text, oldBlockChild?.text), path = [currentBlockIndex, currentBlockChildIndex];\n      if (isChildChanged)\n        if (currentBlockChild._key === oldBlockChild?._key) {\n          debug$5(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlockChild, {\n            at: path\n          });\n          const isSpanNode = slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n          isSpanNode && isTextChanged ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(slateEditor, {\n            at: {\n              focus: {\n                path,\n                offset: 0\n              },\n              anchor: {\n                path,\n                offset: oldBlockChild.text.length\n              }\n            }\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n            at: path\n          }), slateEditor.onChange()) : isSpanNode || (debug$5(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, {\n            _key: VOID_CHILD_KEY\n          }, {\n            at: [...path, 0],\n            voids: !0\n          }));\n        } else oldBlockChild ? (debug$5(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange()) : oldBlockChild || (debug$5(\"Inserting new child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange());\n    });\n  }\n}\nconst debug$4 = debugWithName(\"component:PortableTextEditor:Synchronizer\"), debugVerbose$1 = debug$4.enabled && !1, FLUSH_PATCHES_THROTTLED_MS =  false ? 0 : 1e3;\nfunction Synchronizer(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(35), portableTextEditor = usePortableTextEditor(), readOnly = usePortableTextEditorReadOnlyStatus(), {\n    editorActor,\n    getValue,\n    onChange,\n    value\n  } = props;\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = [], $[0] = t0) : t0 = $[0];\n  const pendingPatches = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(t0);\n  let t1;\n  $[1] !== editorActor || $[2] !== portableTextEditor || $[3] !== readOnly ? (t1 = {\n    editorActor,\n    portableTextEditor,\n    readOnly\n  }, $[1] = editorActor, $[2] = portableTextEditor, $[3] = readOnly, $[4] = t1) : t1 = $[4];\n  const syncValue = useSyncValue(t1), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlate)();\n  let t2, t3;\n  $[5] !== slateEditor ? (t2 = () => {\n    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);\n  }, t3 = [slateEditor], $[5] = slateEditor, $[6] = t2, $[7] = t3) : (t2 = $[6], t3 = $[7]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t2, t3);\n  let t4;\n  $[8] !== getValue || $[9] !== editorActor || $[10] !== slateEditor ? (t4 = () => {\n    if (pendingPatches.current.length > 0) {\n      debug$4(\"Flushing pending patches\"), debugVerbose$1 && debug$4(`Patches:\n${JSON.stringify(pendingPatches.current, null, 2)}`);\n      const snapshot = getValue();\n      editorActor.send({\n        type: \"mutation\",\n        patches: pendingPatches.current,\n        snapshot\n      }), pendingPatches.current = [];\n    }\n    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);\n  }, $[8] = getValue, $[9] = editorActor, $[10] = slateEditor, $[11] = t4) : t4 = $[11];\n  const onFlushPendingPatches = t4;\n  let t5, t6;\n  $[12] !== onFlushPendingPatches ? (t5 = () => () => {\n    onFlushPendingPatches();\n  }, t6 = [onFlushPendingPatches], $[12] = onFlushPendingPatches, $[13] = t5, $[14] = t6) : (t5 = $[13], t6 = $[14]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t5, t6);\n  let t7;\n  $[15] !== onChange ? (t7 = (change) => onChange(change), $[15] = onChange, $[16] = t7) : t7 = $[16];\n  const handleChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_22__.useEffectEvent)(t7);\n  let t8, t9;\n  $[17] !== slateEditor || $[18] !== onFlushPendingPatches || $[19] !== editorActor || $[20] !== handleChange ? (t8 = () => {\n    const onFlushPendingPatchesThrottled = lodash_throttle_js__WEBPACK_IMPORTED_MODULE_12__(() => {\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isNormalizing(slateEditor)) {\n        onFlushPendingPatches();\n        return;\n      }\n      onFlushPendingPatchesThrottled();\n    }, FLUSH_PATCHES_THROTTLED_MS, {\n      leading: !1,\n      trailing: !0\n    });\n    debug$4(\"Subscribing to editor changes\");\n    const sub = editorActor.on(\"*\", (event) => {\n      bb18: switch (event.type) {\n        case \"patch\": {\n          IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !0), pendingPatches.current.push(event.patch), onFlushPendingPatchesThrottled(), handleChange(event);\n          break bb18;\n        }\n        case \"loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !0\n          });\n          break bb18;\n        }\n        case \"done loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !1\n          });\n          break bb18;\n        }\n        case \"offline\": {\n          handleChange({\n            type: \"connection\",\n            value: \"offline\"\n          });\n          break bb18;\n        }\n        case \"online\": {\n          handleChange({\n            type: \"connection\",\n            value: \"online\"\n          });\n          break bb18;\n        }\n        case \"value changed\": {\n          handleChange({\n            type: \"value\",\n            value: event.value\n          });\n          break bb18;\n        }\n        case \"invalid value\": {\n          handleChange({\n            type: \"invalidValue\",\n            resolution: event.resolution,\n            value: event.value\n          });\n          break bb18;\n        }\n        case \"error\": {\n          handleChange({\n            ...event,\n            level: \"warning\"\n          });\n          break bb18;\n        }\n        case \"patches\":\n          break bb18;\n        default:\n          handleChange(event);\n      }\n    });\n    return () => {\n      debug$4(\"Unsubscribing to changes\"), sub.unsubscribe();\n    };\n  }, t9 = [editorActor, handleChange, onFlushPendingPatches, slateEditor], $[17] = slateEditor, $[18] = onFlushPendingPatches, $[19] = editorActor, $[20] = handleChange, $[21] = t8, $[22] = t9) : (t8 = $[21], t9 = $[22]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t8, t9);\n  let t10;\n  $[23] !== syncValue || $[24] !== value ? (t10 = () => {\n    debug$4(\"Editor is online, syncing from props.value\"), syncValue(value);\n  }, $[23] = syncValue, $[24] = value, $[25] = t10) : t10 = $[25];\n  const handleOnline = t10;\n  let t11, t12;\n  $[26] !== editorActor || $[27] !== handleOnline ? (t11 = () => {\n    const subscription = editorActor.on(\"online\", handleOnline);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t12 = [handleOnline, editorActor], $[26] = editorActor, $[27] = handleOnline, $[28] = t11, $[29] = t12) : (t11 = $[28], t12 = $[29]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t11, t12);\n  const isInitialValueFromProps = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(!0);\n  let t13, t14;\n  return $[30] !== syncValue || $[31] !== value || $[32] !== editorActor ? (t13 = () => {\n    debug$4(\"Value from props changed, syncing new value\"), syncValue(value), isInitialValueFromProps.current && (editorActor.send({\n      type: \"ready\"\n    }), isInitialValueFromProps.current = !1);\n  }, t14 = [editorActor, syncValue, value], $[30] = syncValue, $[31] = value, $[32] = editorActor, $[33] = t13, $[34] = t14) : (t13 = $[33], t14 = $[34]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t13, t14), null;\n}\nSynchronizer.displayName = \"Synchronizer\";\nconst EditorActorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({}), insertBreakActionImplementation = ({\n  context,\n  action\n}) => {\n  const keyGenerator = context.keyGenerator, schema = context.schema, editor = action.editor;\n  if (!editor.selection)\n    return;\n  const [focusSpan] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    mode: \"lowest\",\n    at: editor.selection.focus,\n    match: (n) => editor.isTextSpan(n),\n    voids: !1\n  }))[0] ?? [void 0], focusDecorators = focusSpan.marks?.filter((mark) => schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusAnnotations = focusSpan.marks?.filter((mark) => !schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, focusBlockPath);\n  if (editor.isTextBlock(focusBlock)) {\n    const [start, end] = slate__WEBPACK_IMPORTED_MODULE_15__.Range.edges(editor.selection), atTheStartOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(end, {\n      path: [...focusBlockPath, 0],\n      offset: 0\n    });\n    if (atTheStartOfBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n        decorators: focusAnnotations.length === 0 ? focusDecorators : [],\n        listItem: focusBlock.listItem,\n        level: focusBlock.level\n      }));\n      const [nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath);\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n        anchor: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        }\n      });\n      return;\n    }\n    const lastFocusBlockChild = focusBlock.children[focusBlock.children.length - 1], atTheEndOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(start, {\n      path: [...focusBlockPath, focusBlock.children.length - 1],\n      offset: editor.isTextSpan(lastFocusBlockChild) ? lastFocusBlockChild.text.length : 0\n    });\n    if (atTheEndOfBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n        decorators: [],\n        listItem: focusBlock.listItem,\n        level: focusBlock.level\n      }));\n      const [nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath);\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n        anchor: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        }\n      });\n      return;\n    }\n    if (!atTheStartOfBlock && !atTheEndOfBlock) {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n        if (!editor.selection)\n          return;\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n          at: editor.selection\n        });\n        const [nextNode, nextNodePath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath), {\n          depth: 1\n        });\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n          anchor: {\n            path: [...nextNodePath, 0],\n            offset: 0\n          },\n          focus: {\n            path: [...nextNodePath, 0],\n            offset: 0\n          }\n        }), editor.isTextBlock(nextNode) && nextNode.markDefs && nextNode.markDefs.length > 0) {\n          const newMarkDefKeys = /* @__PURE__ */ new Map(), prevNodeSpans = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, focusBlockPath)).map((entry) => entry[0]).filter((node) => editor.isTextSpan(node)), children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, nextNodePath);\n          for (const [child, childPath] of children) {\n            if (!editor.isTextSpan(child))\n              continue;\n            const marks = child.marks ?? [];\n            for (const mark of marks)\n              schema.decorators.some((decorator) => decorator.value === mark) || prevNodeSpans.some((prevNodeSpan) => prevNodeSpan.marks?.includes(mark)) && !newMarkDefKeys.has(mark) && newMarkDefKeys.set(mark, keyGenerator());\n            const newMarks = marks.map((mark) => newMarkDefKeys.get(mark) ?? mark);\n            lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(marks, newMarks) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              marks: newMarks\n            }, {\n              at: childPath\n            });\n          }\n          const newMarkDefs = nextNode.markDefs.map((markDef) => ({\n            ...markDef,\n            _key: newMarkDefKeys.get(markDef._key) ?? markDef._key\n          }));\n          lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextNode.markDefs, newMarkDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: nextNodePath,\n            match: (node) => editor.isTextBlock(node)\n          });\n        }\n      }), editor.onChange();\n      return;\n    }\n  }\n}, behaviorActionImplementations = {\n  \"set block\": ({\n    action\n  }) => {\n    for (const path of action.paths) {\n      const at = toSlateRange({\n        anchor: {\n          path,\n          offset: 0\n        },\n        focus: {\n          path,\n          offset: 0\n        }\n      }, action.editor);\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n        ...action.style ? {\n          style: action.style\n        } : {},\n        ...action.listItem ? {\n          listItem: action.listItem\n        } : {},\n        ...action.level ? {\n          level: action.level\n        } : {}\n      }, {\n        at\n      });\n    }\n  },\n  \"unset block\": ({\n    action\n  }) => {\n    for (const path of action.paths) {\n      const at = toSlateRange({\n        anchor: {\n          path,\n          offset: 0\n        },\n        focus: {\n          path,\n          offset: 0\n        }\n      }, action.editor);\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.unsetNodes(action.editor, action.props, {\n        at\n      });\n    }\n  },\n  \"delete backward\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteBackward)(action.editor, action.unit);\n  },\n  \"delete forward\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteForward)(action.editor, action.unit);\n  },\n  delete: ({\n    action\n  }) => {\n    const location = toSlateRange(action.selection, action.editor);\n    if (!location) {\n      console.error(`Could not find Slate location from selection ${action.selection}`);\n      return;\n    }\n    location.anchor.path.length === 1 && location.focus.path.length === 1 ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(action.editor, {\n      at: location\n    }) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(action.editor, {\n      at: location\n    });\n  },\n  \"insert break\": insertBreakActionImplementation,\n  // This mimics Slate's internal which also just does a regular insert break\n  // when on soft break\n  \"insert soft break\": insertBreakActionImplementation,\n  \"insert text\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.insertText)(action.editor, action.text);\n  },\n  \"insert text block\": ({\n    context,\n    action\n  }) => {\n    slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(action.editor, {\n      _key: context.keyGenerator(),\n      _type: context.schema.block.name,\n      style: context.schema.styles[0].value ?? \"normal\",\n      markDefs: [],\n      children: [{\n        _key: context.keyGenerator(),\n        _type: \"span\",\n        text: \"\"\n      }]\n    });\n  },\n  effect: ({\n    action\n  }) => {\n    action.effect();\n  },\n  select: ({\n    action\n  }) => {\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, toSlateRange(action.selection, action.editor));\n  }\n};\nfunction performAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"delete\": {\n      behaviorActionImplementations.delete({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert text block\": {\n      behaviorActionImplementations[\"insert text block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"set block\": {\n      behaviorActionImplementations[\"set block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"unset block\": {\n      behaviorActionImplementations[\"unset block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"effect\": {\n      behaviorActionImplementations.effect({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select\": {\n      behaviorActionImplementations.select({\n        context,\n        action\n      });\n      break;\n    }\n    default:\n      performDefaultAction({\n        context,\n        action\n      });\n  }\n}\nfunction performDefaultAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"delete backward\": {\n      behaviorActionImplementations[\"delete backward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete forward\": {\n      behaviorActionImplementations[\"delete forward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert break\": {\n      behaviorActionImplementations[\"insert break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert soft break\": {\n      behaviorActionImplementations[\"insert soft break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    default:\n      behaviorActionImplementations[\"insert text\"]({\n        context,\n        action\n      });\n  }\n}\nconst breakingVoidBlock = {\n  on: \"insert break\",\n  guard: ({\n    context\n  }) => !!getFocusBlockObject(context),\n  actions: [() => [{\n    type: \"insert text block\",\n    decorators: []\n  }]]\n}, deletingEmptyTextBlockAfterBlockObject = {\n  on: \"delete backward\",\n  guard: ({\n    context\n  }) => {\n    const focusTextBlock = getFocusTextBlock(context), selectionCollapsed = selectionIsCollapsed(context), previousBlock = getPreviousBlock(context);\n    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(previousBlock.node) ? {\n      focusTextBlock,\n      previousBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    previousBlock\n  }) => [{\n    type: \"delete\",\n    selection: {\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: 0\n      }\n    }\n  }, {\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: previousBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: previousBlock.path,\n        offset: 0\n      }\n    }\n  }]]\n}, deletingEmptyTextBlockBeforeBlockObject = {\n  on: \"delete forward\",\n  guard: ({\n    context\n  }) => {\n    const focusTextBlock = getFocusTextBlock(context), selectionCollapsed = selectionIsCollapsed(context), nextBlock = getNextBlock(context);\n    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(nextBlock.node) ? {\n      focusTextBlock,\n      nextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    nextBlock\n  }) => [{\n    type: \"delete\",\n    selection: {\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: 0\n      }\n    }\n  }, {\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: nextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: nextBlock.path,\n        offset: 0\n      }\n    }\n  }]]\n}, coreBlockObjectBehaviors = [breakingVoidBlock, deletingEmptyTextBlockAfterBlockObject, deletingEmptyTextBlockBeforeBlockObject], clearListOnBackspace = {\n  on: \"delete backward\",\n  guard: ({\n    context\n  }) => {\n    const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection.focus.offset === 0 && focusTextBlock.node.level === 1 ? {\n      focusTextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock\n  }) => [{\n    type: \"unset block\",\n    props: [\"listItem\", \"level\"],\n    paths: [focusTextBlock.path]\n  }]]\n}, unindentListOnBackspace = {\n  on: \"delete backward\",\n  guard: ({\n    context\n  }) => {\n    const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {\n      focusTextBlock,\n      level: focusTextBlock.node.level - 1\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    level\n  }) => [{\n    type: \"set block\",\n    level,\n    paths: [focusTextBlock.path]\n  }]]\n}, coreListBehaviors = [clearListOnBackspace, unindentListOnBackspace], softReturn = {\n  on: \"insert soft break\",\n  actions: [() => [{\n    type: \"insert text\",\n    text: `\n`\n  }]]\n}, coreBehaviors = [softReturn, ...coreBlockObjectBehaviors, ...coreListBehaviors], networkLogic = (0,xstate__WEBPACK_IMPORTED_MODULE_23__.fromCallback)(({\n  sendBack\n}) => {\n  const onlineHandler = () => {\n    sendBack({\n      type: \"online\"\n    });\n  }, offlineHandler = () => {\n    sendBack({\n      type: \"offline\"\n    });\n  };\n  return window.addEventListener(\"online\", onlineHandler), window.addEventListener(\"offline\", offlineHandler), () => {\n    window.removeEventListener(\"online\", onlineHandler), window.removeEventListener(\"offline\", offlineHandler);\n  };\n}), editorMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_24__.setup)({\n  types: {\n    context: {},\n    events: {},\n    emitted: {},\n    input: {}\n  },\n  actions: {\n    \"assign behaviors\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      behaviors: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"update behaviors\"), [...coreBehaviors, ...event.behaviors])\n    }),\n    \"assign schema\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      schema: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"update schema\"), event.schema)\n    }),\n    \"emit patch event\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"patch\"), event)),\n    \"emit mutation event\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"mutation\"), event)),\n    \"defer event\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingEvents: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, [\"patch\", \"mutation\"]), [...context.pendingEvents, event])\n    }),\n    \"emit pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingEvents)\n        enqueue((0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(event));\n    }),\n    \"clear pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingEvents: []\n    }),\n    \"handle behavior event\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.b)(({\n      context,\n      event,\n      enqueue\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, [\"behavior event\"]);\n      const defaultAction = {\n        ...event.behaviorEvent,\n        editor: event.editor\n      }, eventBehaviors = context.behaviors.filter((behavior) => behavior.on === event.behaviorEvent.type);\n      if (eventBehaviors.length === 0) {\n        performDefaultAction({\n          context,\n          action: defaultAction\n        });\n        return;\n      }\n      const value = fromSlateValue(event.editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(event.editor)), selection = toPortableTextRange(value, event.editor.selection, context.schema);\n      if (!selection) {\n        console.warn(`Unable to handle event ${event.type} due to missing selection`), performDefaultAction({\n          context,\n          action: defaultAction\n        });\n        return;\n      }\n      const behaviorContext = {\n        schema: context.schema,\n        value,\n        selection\n      };\n      let behaviorOverwritten = !1;\n      for (const eventBehavior of eventBehaviors) {\n        const shouldRun = eventBehavior.guard?.({\n          context: behaviorContext,\n          event: event.behaviorEvent\n        }) ?? !0;\n        if (!shouldRun)\n          continue;\n        const actionIntendSets = eventBehavior.actions.map((actionSet) => actionSet({\n          context: behaviorContext,\n          event: event.behaviorEvent\n        }, shouldRun));\n        for (const actionIntends of actionIntendSets)\n          behaviorOverwritten = actionIntends.length > 0 && actionIntends.some((actionIntend) => actionIntend.type !== \"effect\"), enqueue.raise({\n            type: \"behavior action intends\",\n            editor: event.editor,\n            actionIntends\n          });\n        if (behaviorOverwritten)\n          break;\n      }\n      behaviorOverwritten || performDefaultAction({\n        context,\n        action: defaultAction\n      });\n    })\n  },\n  actors: {\n    networkLogic\n  }\n}).createMachine({\n  id: \"editor\",\n  context: ({\n    input\n  }) => ({\n    behaviors: input.behaviors ? [...coreBehaviors, ...input.behaviors] : coreBehaviors,\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    schema: input.schema\n  }),\n  invoke: {\n    id: \"networkLogic\",\n    src: \"networkLogic\"\n  },\n  on: {\n    ready: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    unset: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    \"value changed\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    \"invalid value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    error: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    selection: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    blur: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    focus: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    online: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)({\n        type: \"online\"\n      })\n    },\n    offline: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)({\n        type: \"offline\"\n      })\n    },\n    loading: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)({\n        type: \"loading\"\n      })\n    },\n    patches: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)(({\n        event\n      }) => event)\n    },\n    \"done loading\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.e)({\n        type: \"done loading\"\n      })\n    },\n    \"update behaviors\": {\n      actions: \"assign behaviors\"\n    },\n    \"update schema\": {\n      actions: \"assign schema\"\n    },\n    \"behavior event\": {\n      actions: \"handle behavior event\"\n    },\n    \"behavior action intends\": {\n      actions: [({\n        context,\n        event\n      }) => {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, () => {\n          for (const actionIntend of event.actionIntends) {\n            const action = {\n              ...actionIntend,\n              editor: event.editor\n            };\n            performAction({\n              context,\n              action\n            });\n          }\n        }), event.editor.onChange();\n      }]\n    }\n  },\n  initial: \"pristine\",\n  states: {\n    pristine: {\n      initial: \"idle\",\n      states: {\n        idle: {\n          on: {\n            normalizing: {\n              target: \"normalizing\"\n            },\n            patch: {\n              actions: \"defer event\",\n              target: \"#editor.dirty\"\n            },\n            mutation: {\n              actions: \"defer event\",\n              target: \"#editor.dirty\"\n            }\n          }\n        },\n        normalizing: {\n          on: {\n            \"done normalizing\": {\n              target: \"idle\"\n            },\n            patch: {\n              actions: \"defer event\"\n            },\n            mutation: {\n              actions: \"defer event\"\n            }\n          }\n        }\n      }\n    },\n    dirty: {\n      entry: [\"emit pending events\", \"clear pending events\"],\n      on: {\n        patch: {\n          actions: \"emit patch event\"\n        },\n        mutation: {\n          actions: \"emit mutation event\"\n        }\n      }\n    }\n  }\n}), PortableTextEditorSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null), usePortableTextEditorSelection = () => {\n  const selection = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(PortableTextEditorSelectionContext);\n  if (selection === void 0)\n    throw new Error(\"The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.\");\n  return selection;\n}, debug$3 = debugWithName(\"component:PortableTextEditor:SelectionProvider\"), debugVerbose = debug$3.enabled && !1;\nfunction PortableTextEditorSelectionProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(6), [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n  let t0, t1;\n  $[0] !== props.editorActor ? (t0 = () => {\n    debug$3(\"Subscribing to selection changes\");\n    const subscription = props.editorActor.on(\"selection\", (event) => {\n      (0,react__WEBPACK_IMPORTED_MODULE_3__.startTransition)(() => {\n        debugVerbose && debug$3(\"Setting selection\"), setSelection(event.selection);\n      });\n    });\n    return () => {\n      debug$3(\"Unsubscribing to selection changes\"), subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor], $[0] = props.editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t0, t1);\n  let t2;\n  return $[3] !== selection || $[4] !== props.children ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }), $[3] = selection, $[4] = props.children, $[5] = t2) : t2 = $[5], t2;\n}\nconst defaultKeyGenerator = () => (0,_sanity_util_content__WEBPACK_IMPORTED_MODULE_26__.randomKey)(12), debug$2 = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n  static displayName = \"PortableTextEditor\";\n  /**\n   * An observable of all the editor changes.\n   */\n  change$ = new rxjs__WEBPACK_IMPORTED_MODULE_27__.Subject();\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  /**\n   * The editor API (currently implemented with Slate).\n   */\n  constructor(props) {\n    if (super(props), props.editor)\n      this.editorActor = props.editor, this.editorActor.start(), this.schemaTypes = this.editorActor.getSnapshot().context.schema;\n    else {\n      if (!props.schemaType)\n        throw new Error('PortableTextEditor: missing \"schemaType\" property');\n      props.incomingPatches$ && console.warn(\"The prop 'incomingPatches$' is deprecated and renamed to 'patches$'\"), this.schemaTypes = getPortableTextMemberSchemaTypes(props.schemaType.hasOwnProperty(\"jsonType\") ? props.schemaType : compileType(props.schemaType)), this.editorActor = props.editor ?? (0,xstate__WEBPACK_IMPORTED_MODULE_28__.A)(editorMachine, {\n        input: {\n          keyGenerator: props.keyGenerator || defaultKeyGenerator,\n          schema: this.schemaTypes\n        }\n      }), this.editorActor.start();\n    }\n  }\n  componentDidUpdate(prevProps) {\n    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = getPortableTextMemberSchemaTypes(this.props.schemaType.hasOwnProperty(\"jsonType\") ? this.props.schemaType : compileType(this.props.schemaType)), this.editorActor.send({\n      type: \"update schema\",\n      schema: this.schemaTypes\n    })), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this);\n  }\n  setEditable = (editable) => {\n    this.editable = {\n      ...this.editable,\n      ...editable\n    };\n  };\n  getValue = () => {\n    if (this.editable)\n      return this.editable.getValue();\n  };\n  render() {\n    const maxBlocks = this.props.editor || typeof this.props.maxBlocks > \"u\" ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10) || void 0, readOnly = !!this.props.readOnly, legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n      legacyPatches ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RoutePatchesObservableToEditorActor, { editorActor: this.editorActor, patches$: legacyPatches }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EditorActorContext.Provider, { value: this.editorActor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SlateContainer, { editorActor: this.editorActor, maxBlocks, portableTextEditor: this, readOnly, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorContext.Provider, { value: this, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorReadOnlyContext.Provider, { value: readOnly, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(PortableTextEditorSelectionProvider, { editorActor: this.editorActor, children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Synchronizer, { editorActor: this.editorActor, getValue: this.getValue, onChange: (change) => {\n          this.props.editor || this.props.onChange(change), this.change$.next(change);\n        }, value: this.props.value }),\n        this.props.children\n      ] }) }) }) }) })\n    ] });\n  }\n  // Static API methods\n  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];\n  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;\n  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);\n  static blur = (editor) => {\n    debug$2(\"Host blurred\"), editor.editable?.blur();\n  };\n  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);\n  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);\n  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];\n  static focus = (editor) => {\n    debug$2(\"Host requesting focus\"), editor.editable?.focus();\n  };\n  static focusBlock = (editor) => editor.editable?.focusBlock();\n  static focusChild = (editor) => editor.editable?.focusChild();\n  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;\n  static getValue = (editor) => editor.editable?.getValue();\n  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);\n  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);\n  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();\n  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();\n  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);\n  static insertChild = (editor, type, value) => (debug$2(\"Host inserting child\"), editor.editable?.insertChild(type, value));\n  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);\n  static insertBreak = (editor) => editor.editable?.insertBreak();\n  static isVoid = (editor, element) => editor.editable?.isVoid(element);\n  static isObjectPath = (_editor, path) => {\n    if (!path || !Array.isArray(path)) return !1;\n    const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n    return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n  };\n  static marks = (editor) => editor.editable?.marks();\n  static select = (editor, selection) => {\n    debug$2(\"Host setting selection\", selection), editor.editable?.select(selection);\n  };\n  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);\n  static toggleBlockStyle = (editor, blockStyle) => (debug$2(\"Host is toggling block style\"), editor.editable?.toggleBlockStyle(blockStyle));\n  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);\n  static toggleMark = (editor, mark) => {\n    debug$2(\"Host toggling mark\", mark), editor.editable?.toggleMark(mark);\n  };\n  static getFragment = (editor) => (debug$2(\"Host getting fragment\"), editor.editable?.getFragment());\n  static undo = (editor) => {\n    debug$2(\"Host undoing\"), editor.editable?.undo();\n  };\n  static redo = (editor) => {\n    debug$2(\"Host redoing\"), editor.editable?.redo();\n  };\n  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);\n}\nfunction RoutePatchesObservableToEditorActor(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(4);\n  let t0, t1;\n  return $[0] !== props.patches$ || $[1] !== props.editorActor ? (t0 = () => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: \"patches\",\n        ...payload\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor, props.patches$], $[0] = props.patches$, $[1] = props.editorActor, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t0, t1), null;\n}\nconst debug$1 = debugWithName(\"components:Leaf\"), EMPTY_MARKS = [], Leaf = (props) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation\n  } = props, spanRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), portableTextEditor = usePortableTextEditor(), blockSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSelected)(), [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), block = children.props.parent, path = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => block ? [{\n    _key: block?._key\n  }, \"children\", {\n    _key: leaf._key\n  }] : [], [block, leaf._key]), decoratorValues = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => schemaTypes.decorators.map((dec) => dec.value), [schemaTypes.decorators]), marks = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => annotationMarks.map((mark_0) => !decoratorValues.includes(mark_0) && block?.markDefs?.find((def) => def._key === mark_0)).filter(Boolean), [annotationMarks, block, decoratorValues]), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(!1);\n      return;\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor);\n    sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0,react__WEBPACK_IMPORTED_MODULE_3__.startTransition)(() => {\n      setFocused(!0);\n    });\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);\n  const setSelectedFromRange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    debug$1(\"Setting selection and focus from range\");\n    const winSelection = window.getSelection();\n    if (!winSelection) {\n      setSelected(!1);\n      return;\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0);\n      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);\n    } else\n      setSelected(!1);\n  }, [shouldTrackSelectionAndFocus]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    const onBlur = editorActor.on(\"blur\", () => {\n      setFocused(!1), setSelected(!1);\n    }), onFocus = editorActor.on(\"focus\", () => {\n      const sel_0 = PortableTextEditor.getSelection(portableTextEditor);\n      sel_0 && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();\n    }), onSelection = editorActor.on(\"selection\", (event) => {\n      event.selection && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();\n    });\n    return () => {\n      onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();\n    };\n  }, [editorActor, path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => setSelectedFromRange(), [setSelectedFromRange]);\n  const content = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    let returnedChildren = children;\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark_1) => {\n      const schemaType = schemaTypes.decorators.find((dec_0) => dec_0.value === mark_1);\n      if (schemaType && renderDecorator) {\n        const _props = Object.defineProperty({\n          children: returnedChildren,\n          editorElementRef: spanRef,\n          focused,\n          path,\n          selected,\n          schemaType,\n          value: mark_1\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n          }\n        });\n        returnedChildren = renderDecorator(_props);\n      }\n    }), block && annotations.length > 0 && annotations.forEach((annotation) => {\n      const schemaType_0 = schemaTypes.annotations.find((t) => t.name === annotation._type);\n      if (schemaType_0)\n        if (renderAnnotation) {\n          const _props_0 = Object.defineProperty({\n            block,\n            children: returnedChildren,\n            editorElementRef: spanRef,\n            focused,\n            path,\n            selected,\n            schemaType: schemaType_0,\n            value: annotation\n          }, \"type\", {\n            enumerable: !1,\n            get() {\n              return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n            }\n          });\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: spanRef, children: renderAnnotation(_props_0) });\n        } else\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultAnnotation, { annotation, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: spanRef, children: returnedChildren }) });\n    }), block && renderChild)) {\n      const child = block.children.find((_child) => _child._key === leaf._key);\n      if (child) {\n        const _props_1 = Object.defineProperty({\n          annotations,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: returnedChildren }),\n          editorElementRef: spanRef,\n          focused,\n          path,\n          schemaType: schemaTypes.span,\n          selected,\n          value: child\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.span;\n          }\n        });\n        returnedChildren = renderChild(_props_1);\n      }\n    }\n    return returnedChildren;\n  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ...attributes, ref: spanRef, children: content }, leaf._key), [leaf, attributes, content]);\n};\nLeaf.displayName = \"Leaf\";\nconst debug = debugWithName(\"component:Editable\"), PLACEHOLDER_STYLE = {\n  position: \"absolute\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  left: 0,\n  right: 0\n}, PortableTextEditable = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onClick,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props, portableTextEditor = usePortableTextEditor(), readOnly = usePortableTextEditorReadOnlyStatus(), ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), [editableElement, setEditableElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), [rangeDecorationState, setRangeDecorationsState] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useImperativeHandle)(forwardedRef, () => ref.current);\n  const rangeDecorationsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(rangeDecorations), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorActorContext), {\n    schemaTypes\n  } = portableTextEditor, slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlate)(), blockTypeName = schemaTypes.block.name, withInsertData = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => createWithInsertData(editorActor, schemaTypes), [editorActor, schemaTypes]), withHotKeys = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => createWithHotkeys(portableTextEditor, hotkeys), [hotkeys, portableTextEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => readOnly ? (debug(\"Editable is in read only mode\"), withInsertData(slateEditor)) : (debug(\"Editable is in edit mode\"), withInsertData(withHotKeys(slateEditor))), [readOnly, slateEditor, withHotKeys, withInsertData]);\n  const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((eProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Element, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, schemaTypes, spellCheck }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]), renderLeaf = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((lProps) => {\n    if (lProps.leaf._type === \"span\") {\n      let rendered = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Leaf, { ...lProps, editorActor, schemaTypes, renderAnnotation, renderChild, renderDecorator, readOnly });\n      if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === \"\")\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),\n          rendered\n        ] });\n      const decoration = lProps.leaf.rangeDecoration;\n      return decoration && (rendered = decoration.component({\n        children: rendered\n      })), rendered;\n    }\n    return lProps.children;\n  }, [editorActor, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]), restoreSelectionFromProps = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`);\n      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));\n      if (normalizedSelection !== null) {\n        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n        const slateRange = toSlateRange(normalizedSelection, slateEditor);\n        slateRange && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === \"set_selection\") || editorActor.send({\n          type: \"selection\",\n          selection: normalizedSelection\n        }), slateEditor.onChange());\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor]), syncRangeDecorations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((operation) => {\n    if (rangeDecorations && rangeDecorations.length > 0) {\n      const newSlateRanges = [];\n      if (rangeDecorations.forEach((rangeDecorationItem) => {\n        const slateRange_0 = toSlateRange(rangeDecorationItem.selection, slateEditor);\n        if (!slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(slateRange_0)) {\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: null,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n          return;\n        }\n        let newRange;\n        if (operation && (newRange = moveRangeByOperation(slateRange_0, operation), newRange && newRange !== slateRange_0 || newRange === null && slateRange_0)) {\n          const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: newRangeSelection,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n        }\n        newRange !== null && newSlateRanges.push({\n          ...newRange || slateRange_0,\n          rangeDecoration: rangeDecorationItem\n        });\n      }), newSlateRanges.length > 0) {\n        setRangeDecorationsState(newSlateRanges);\n        return;\n      }\n    }\n    setRangeDecorationsState((rangeDecorationState_0) => rangeDecorationState_0.length > 0 ? [] : rangeDecorationState_0);\n  }, [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    const onReady = editorActor.on(\"ready\", () => {\n      restoreSelectionFromProps();\n    }), onInvalidValue = editorActor.on(\"invalid value\", () => {\n      setHasInvalidValue(!0);\n    }), onValueChanged = editorActor.on(\"value changed\", () => {\n      setHasInvalidValue(!1);\n    });\n    return () => {\n      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();\n    };\n  }, [editorActor, restoreSelectionFromProps]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);\n  const originalApply = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => slateEditor.apply, [slateEditor]), [syncedRangeDecorations, setSyncedRangeDecorations] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());\n  }, [syncRangeDecorations, syncedRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;\n  }, [rangeDecorations, syncRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => (slateEditor.apply = (op) => {\n    originalApply(op), op.type !== \"set_selection\" && syncRangeDecorations(op);\n  }, () => {\n    slateEditor.apply = originalApply;\n  }), [originalApply, slateEditor, syncRangeDecorations]);\n  const handleCopy = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event) => {\n    onCopy && onCopy(event) !== void 0 && event.preventDefault();\n  }, [onCopy]), handlePaste = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_0) => {\n    if (event_0.preventDefault(), !slateEditor.selection)\n      return;\n    if (!onPaste) {\n      debug(\"Pasting normally\"), slateEditor.insertData(event_0.clipboardData);\n      return;\n    }\n    const value_0 = PortableTextEditor.getValue(portableTextEditor), path = toPortableTextRange(value_0, slateEditor.selection, schemaTypes)?.focus.path || [], onPasteResult = onPaste({\n      event: event_0,\n      value: value_0,\n      path,\n      schemaTypes\n    });\n    onPasteResult === void 0 ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event_0.clipboardData)) : (editorActor.send({\n      type: \"loading\"\n    }), Promise.resolve(onPasteResult).then((result_0) => {\n      debug(\"Custom paste function from client resolved\", result_0), !result_0 || !result_0.insert ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event_0.clipboardData)) : result_0.insert ? slateEditor.insertFragment(toSlateValue(result_0.insert, {\n        schemaTypes\n      })) : console.warn(\"Your onPaste function returned something unexpected:\", result_0);\n    }).catch((error) => (console.error(error), error)).finally(() => {\n      editorActor.send({\n        type: \"done loading\"\n      });\n    }));\n  }, [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor]), handleOnFocus = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_1) => {\n    if (onFocus && onFocus(event_1), !event_1.isDefaultPrevented()) {\n      const selection = PortableTextEditor.getSelection(portableTextEditor);\n      selection === null && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_15__.Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({\n        type: \"focus\",\n        event: event_1\n      });\n      const newSelection = PortableTextEditor.getSelection(portableTextEditor);\n      selection === newSelection && editorActor.send({\n        type: \"selection\",\n        selection\n      });\n    }\n  }, [editorActor, onFocus, portableTextEditor, slateEditor]), handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_2) => {\n    if (onClick && onClick(event_2), slateEditor.selection && event_2.target === event_2.currentTarget) {\n      const [lastBlock, path_0] = slate__WEBPACK_IMPORTED_MODULE_15__.Node.last(slateEditor, []), focusPath = slateEditor.selection.focus.path.slice(0, 1), lastPath = path_0.slice(0, 1);\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(focusPath, lastPath)) {\n        const node = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(slateEditor, path_0.slice(0, 1));\n        lastBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(slateEditor, node) && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n          decorators: []\n        })), slateEditor.onChange());\n      }\n    }\n  }, [onClick, slateEditor]), handleOnBlur = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_3) => {\n    onBlur && onBlur(event_3), event_3.isPropagationStopped() || editorActor.send({\n      type: \"blur\",\n      event: event_3\n    });\n  }, [editorActor, onBlur]), handleOnBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_4) => {\n    onBeforeInput && onBeforeInput(event_4);\n  }, [onBeforeInput]), validateSelection = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (!slateEditor.selection)\n      return;\n    const root = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findDocumentOrShadowRoot(slateEditor), {\n      activeElement\n    } = root;\n    if (ref.current !== activeElement)\n      return;\n    const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.getWindow(slateEditor).getSelection();\n    if (!domSelection || domSelection.rangeCount === 0)\n      return;\n    const existingDOMRange = domSelection.getRangeAt(0);\n    try {\n      const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug(\"DOM range out of sync, validating selection\"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));\n    } catch {\n      debug(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();\n    }\n  }, [ref, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection);\n      return mutationObserver.observe(editableElement, {\n        attributeOldValue: !1,\n        attributes: !1,\n        characterData: !1,\n        childList: !0,\n        subtree: !0\n      }), () => {\n        mutationObserver.disconnect();\n      };\n    }\n  }, [validateSelection, editableElement]);\n  const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_5) => {\n    props.onKeyDown && props.onKeyDown(event_5), event_5.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_5);\n  }, [props, slateEditor]), scrollSelectionIntoViewToSlate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    if (scrollSelectionIntoView !== void 0)\n      return scrollSelectionIntoView === null ? lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__ : (_editor, domRange) => {\n        scrollSelectionIntoView(portableTextEditor, domRange);\n      };\n  }, [portableTextEditor, scrollSelectionIntoView]), decorate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(([, path_1]) => {\n    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes))\n      return [{\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        },\n        placeholder: !0\n      }];\n    if (path_1.length === 0)\n      return [];\n    const result_1 = rangeDecorationState.filter((item) => slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(item) ? path_1.length !== 2 ? !1 : slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(item.focus.path, path_1) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(item.anchor.path, path_1) : slate__WEBPACK_IMPORTED_MODULE_15__.Range.intersection(item, {\n      anchor: {\n        path: path_1,\n        offset: 0\n      },\n      focus: {\n        path: path_1,\n        offset: 0\n      }\n    }) || slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(item, path_1));\n    return result_1.length > 0 ? result_1 : [];\n  }, [slateEditor, schemaTypes, rangeDecorationState]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    ref.current = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);\n  }, [slateEditor, ref]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    slate_react__WEBPACK_IMPORTED_MODULE_17__.Editable,\n    {\n      ...restProps,\n      autoFocus: !1,\n      className: restProps.className || \"pt-editable\",\n      decorate,\n      onBlur: handleOnBlur,\n      onCopy: handleCopy,\n      onClick: handleClick,\n      onDOMBeforeInput: handleOnBeforeInput,\n      onFocus: handleOnFocus,\n      onKeyDown: handleKeyDown,\n      onPaste: handlePaste,\n      readOnly,\n      renderPlaceholder: void 0,\n      renderElement,\n      renderLeaf,\n      scrollSelectionIntoView: scrollSelectionIntoViewToSlate\n    }\n  ) : null;\n});\nPortableTextEditable.displayName = \"ForwardRef(PortableTextEditable)\";\nvar index = typeof document < \"u\" ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect, withSelector = { exports: {} }, withSelector_production_min = {}, shim = { exports: {} }, useSyncExternalStoreShim_production_min = {};\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredUseSyncExternalStoreShim_production_min;\nfunction requireUseSyncExternalStoreShim_production_min() {\n  if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;\n  hasRequiredUseSyncExternalStoreShim_production_min = 1;\n  var e = react__WEBPACK_IMPORTED_MODULE_3__;\n  function h(a, b) {\n    return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;\n  }\n  var k = typeof Object.is == \"function\" ? Object.is : h, l = e.useState, m = e.useEffect, n = e.useLayoutEffect, p = e.useDebugValue;\n  function q(a, b) {\n    var d = b(), f = l({\n      inst: {\n        value: d,\n        getSnapshot: b\n      }\n    }), c2 = f[0].inst, g = f[1];\n    return n(function() {\n      c2.value = d, c2.getSnapshot = b, r(c2) && g({\n        inst: c2\n      });\n    }, [a, d, b]), m(function() {\n      return r(c2) && g({\n        inst: c2\n      }), a(function() {\n        r(c2) && g({\n          inst: c2\n        });\n      });\n    }, [a]), p(d), d;\n  }\n  function r(a) {\n    var b = a.getSnapshot;\n    a = a.value;\n    try {\n      var d = b();\n      return !k(a, d);\n    } catch {\n      return !0;\n    }\n  }\n  function t(a, b) {\n    return b();\n  }\n  var u = typeof window > \"u\" || typeof window.document > \"u\" || typeof window.document.createElement > \"u\" ? t : q;\n  return useSyncExternalStoreShim_production_min.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, useSyncExternalStoreShim_production_min;\n}\nvar useSyncExternalStoreShim_development = {};\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredUseSyncExternalStoreShim_development;\nfunction requireUseSyncExternalStoreShim_development() {\n  return hasRequiredUseSyncExternalStoreShim_development || (hasRequiredUseSyncExternalStoreShim_development = 1,  true && function() {\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    var React = react__WEBPACK_IMPORTED_MODULE_3__, ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)\n          args[_key2 - 1] = arguments[_key2];\n        printWarning(\"error\", format, args);\n      }\n    }\n    function printWarning(level, format, args) {\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame.getStackAddendum();\n        stack !== \"\" && (format += \"%s\", args = args.concat([stack]));\n        var argsWithFormat = args.map(function(item) {\n          return String(item);\n        });\n        argsWithFormat.unshift(\"Warning: \" + format), Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    function is(x, y) {\n      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    var objectIs = typeof Object.is == \"function\" ? Object.is : is, useState2 = React.useState, useEffect2 = React.useEffect, useLayoutEffect2 = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1;\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      didWarnOld18Alpha || React.startTransition !== void 0 && (didWarnOld18Alpha = !0, error(\"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) || (error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n      }\n      var _useState = useState2({\n        inst: {\n          value,\n          getSnapshot\n        }\n      }), inst = _useState[0].inst, forceUpdate = _useState[1];\n      return useLayoutEffect2(function() {\n        inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({\n          inst\n        });\n      }, [subscribe, value, getSnapshot]), useEffect2(function() {\n        checkIfSnapshotChanged(inst) && forceUpdate({\n          inst\n        });\n        var handleStoreChange = function() {\n          checkIfSnapshotChanged(inst) && forceUpdate({\n            inst\n          });\n        };\n        return subscribe(handleStoreChange);\n      }, [subscribe]), useDebugValue(value), value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot, prevValue = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(prevValue, nextValue);\n      } catch {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n      return getSnapshot();\n    }\n    var canUseDOM = typeof window < \"u\" && typeof window.document < \"u\" && typeof window.document.createElement < \"u\", isServerEnvironment = !canUseDOM, shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore, useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim2;\n    useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n  }()), useSyncExternalStoreShim_development;\n}\nvar hasRequiredShim;\nfunction requireShim() {\n  return hasRequiredShim || (hasRequiredShim = 1,  false ? 0 : shim.exports = requireUseSyncExternalStoreShim_development()), shim.exports;\n}\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredWithSelector_production_min;\nfunction requireWithSelector_production_min() {\n  if (hasRequiredWithSelector_production_min) return withSelector_production_min;\n  hasRequiredWithSelector_production_min = 1;\n  var h = react__WEBPACK_IMPORTED_MODULE_3__, n = requireShim();\n  function p(a, b) {\n    return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;\n  }\n  var q = typeof Object.is == \"function\" ? Object.is : p, r = n.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;\n  return withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b, e, l, g) {\n    var c2 = t(null);\n    if (c2.current === null) {\n      var f = {\n        hasValue: !1,\n        value: null\n      };\n      c2.current = f;\n    } else f = c2.current;\n    c2 = v(function() {\n      function a2(a3) {\n        if (!c3) {\n          if (c3 = !0, d2 = a3, a3 = l(a3), g !== void 0 && f.hasValue) {\n            var b2 = f.value;\n            if (g(b2, a3)) return k = b2;\n          }\n          return k = a3;\n        }\n        if (b2 = k, q(d2, a3)) return b2;\n        var e2 = l(a3);\n        return g !== void 0 && g(b2, e2) ? b2 : (d2 = a3, k = e2);\n      }\n      var c3 = !1, d2, k, m = e === void 0 ? null : e;\n      return [function() {\n        return a2(b());\n      }, m === null ? void 0 : function() {\n        return a2(m());\n      }];\n    }, [b, e, l, g]);\n    var d = r(a, c2[0], c2[1]);\n    return u(function() {\n      f.hasValue = !0, f.value = d;\n    }, [d]), w(d), d;\n  }, withSelector_production_min;\n}\nvar withSelector_development = {};\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredWithSelector_development;\nfunction requireWithSelector_development() {\n  return hasRequiredWithSelector_development || (hasRequiredWithSelector_development = 1,  true && function() {\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    var React = react__WEBPACK_IMPORTED_MODULE_3__, shim2 = requireShim();\n    function is(x, y) {\n      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    var objectIs = typeof Object.is == \"function\" ? Object.is : is, useSyncExternalStore = shim2.useSyncExternalStore, useRef2 = React.useRef, useEffect2 = React.useEffect, useMemo2 = React.useMemo, useDebugValue = React.useDebugValue;\n    function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {\n      var instRef = useRef2(null), inst;\n      instRef.current === null ? (inst = {\n        hasValue: !1,\n        value: null\n      }, instRef.current = inst) : inst = instRef.current;\n      var _useMemo = useMemo2(function() {\n        var hasMemo = !1, memoizedSnapshot, memoizedSelection, memoizedSelector = function(nextSnapshot) {\n          if (!hasMemo) {\n            hasMemo = !0, memoizedSnapshot = nextSnapshot;\n            var _nextSelection = selector(nextSnapshot);\n            if (isEqual2 !== void 0 && inst.hasValue) {\n              var currentSelection = inst.value;\n              if (isEqual2(currentSelection, _nextSelection))\n                return memoizedSelection = currentSelection, currentSelection;\n            }\n            return memoizedSelection = _nextSelection, _nextSelection;\n          }\n          var prevSnapshot = memoizedSnapshot, prevSelection = memoizedSelection;\n          if (objectIs(prevSnapshot, nextSnapshot))\n            return prevSelection;\n          var nextSelection = selector(nextSnapshot);\n          return isEqual2 !== void 0 && isEqual2(prevSelection, nextSelection) ? prevSelection : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection, nextSelection);\n        }, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot, getSnapshotWithSelector = function() {\n          return memoizedSelector(getSnapshot());\n        }, getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {\n          return memoizedSelector(maybeGetServerSnapshot());\n        };\n        return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n      }, [getSnapshot, getServerSnapshot, selector, isEqual2]), getSelection = _useMemo[0], getServerSelection = _useMemo[1], value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n      return useEffect2(function() {\n        inst.hasValue = !0, inst.value = value;\n      }, [value]), useDebugValue(value), value;\n    }\n    withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n  }()), withSelector_development;\n}\nvar hasRequiredWithSelector;\nfunction requireWithSelector() {\n  return hasRequiredWithSelector || (hasRequiredWithSelector = 1,  false ? 0 : withSelector.exports = requireWithSelector_development()), withSelector.exports;\n}\nrequireWithSelector();\nrequireShim();\nconst forEachActor = (actorRef, callback) => {\n  callback(actorRef);\n  const children = actorRef.getSnapshot().children;\n  children && Object.values(children).forEach((child) => {\n    forEachActor(child, callback);\n  });\n};\nfunction stopRootWithRehydration(actorRef) {\n  const persistedSnapshots = [];\n  forEachActor(actorRef, (ref) => {\n    persistedSnapshots.push([ref, ref.getSnapshot()]), ref.observers = /* @__PURE__ */ new Set();\n  });\n  const systemSnapshot = actorRef.system.getSnapshot?.();\n  actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach(([ref, snapshot]) => {\n    ref._processingStatus = 0, ref._snapshot = snapshot;\n  });\n}\nfunction useIdleActorRef(logic, ...[options]) {\n  let [[currentConfig, actorRef], setCurrent] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n    const actorRef2 = (0,xstate__WEBPACK_IMPORTED_MODULE_28__.A)(logic, options);\n    return [logic.config, actorRef2];\n  });\n  if (logic.config !== currentConfig) {\n    const newActorRef = (0,xstate__WEBPACK_IMPORTED_MODULE_28__.A)(logic, {\n      ...options,\n      snapshot: actorRef.getPersistedSnapshot({\n        __unsafeAllowInlineActors: !0\n      })\n    });\n    setCurrent([logic.config, newActorRef]), actorRef = newActorRef;\n  }\n  return index(() => {\n    actorRef.logic.implementations = logic.implementations;\n  }), actorRef;\n}\nfunction useActorRef(machine, ...[options, observerOrListener]) {\n  const actorRef = useIdleActorRef(machine, options);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!observerOrListener)\n      return;\n    let sub = actorRef.subscribe((0,xstate__WEBPACK_IMPORTED_MODULE_28__.L)(observerOrListener));\n    return () => {\n      sub.unsubscribe();\n    };\n  }, [observerOrListener]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => (actorRef.start(), () => {\n    stopRootWithRehydration(actorRef);\n  }), [actorRef]), actorRef;\n}\nfunction useEditor(config) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_5__.c)(8);\n  let t0;\n  $[0] !== config.schema ? (t0 = config.schema.hasOwnProperty(\"jsonType\") ? config.schema : compileType(config.schema), $[0] = config.schema, $[1] = t0) : t0 = $[1];\n  let t1;\n  $[2] !== t0 ? (t1 = getPortableTextMemberSchemaTypes(t0), $[2] = t0, $[3] = t1) : t1 = $[3];\n  const schema = t1, t2 = config.keyGenerator ?? defaultKeyGenerator;\n  let t3;\n  return $[4] !== config.behaviors || $[5] !== t2 || $[6] !== schema ? (t3 = {\n    input: {\n      behaviors: config.behaviors,\n      keyGenerator: t2,\n      schema\n    }\n  }, $[4] = config.behaviors, $[5] = t2, $[6] = schema, $[7] = t3) : t3 = $[7], useActorRef(editorMachine, t3);\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEySTtBQUNuRjtBQUNoQjtBQUNOO0FBQzZKO0FBQzFCO0FBQ3hEO0FBQ2pGO0FBQ2U7QUFDQTtBQUNUO0FBQ0g7QUFDa0Y7QUFDekU7QUFDK0U7QUFDdkY7QUFDZ0I7QUFDVjtBQUNFO0FBQ0M7QUFDMEI7QUFDZjtBQUNWO0FBQ1E7QUFDUjtBQUNPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUVBQXVCO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVFQUF1QjtBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNERBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrRUFBb0I7QUFDM0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkNBQTJDLDREQUFZLG9GQUFvRiw0REFBWTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJDQUEyQyw0REFBWSxzRkFBc0YsNERBQVk7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBTztBQUNQO0FBQ0EsdUJBQXVCLFNBQVMsRUFBRSxLQUFLO0FBQ3ZDLFNBQVMsa0NBQU8sSUFBSSwwQ0FBZSxjQUFjLGtDQUFPLGNBQWMsa0NBQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBDQUFNO0FBQzlDO0FBQ0Esa0JBQWtCLDREQUFZO0FBQzlCLEdBQUc7QUFDSCxpQkFBaUIsMkNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDhDQUFPO0FBQzdGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLDJDQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHlDQUFLLG1CQUFtQix5Q0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGlCQUFpQix5Q0FBSyw2Q0FBNkMseUNBQUs7QUFDeEUsb0RBQW9ELHlDQUFLLGlDQUFpQyx5Q0FBSztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVDQUF1Qyw4Q0FBTztBQUM5QztBQUNBLEdBQUcsZ0dBQWdHLDhDQUFPO0FBQzFHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCw4RkFBOEYsMkNBQVM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0tBQWdLLDJDQUFTLHNRQUFzUSx3Q0FBSTtBQUNuYjtBQUNBO0FBQ0EsWUFBWSx5REFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzREFBRyxVQUFVLDBCQUEwQixzREFBRyxVQUFVLGNBQWMsR0FBRztBQUNsSDtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFNO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esc0RBQU07QUFDTjtBQUNBLFlBQVk7QUFDWjtBQUNBLHdCQUF3QixzREFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRFQUE0RTtBQUM5Riw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFDO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsNERBQWMsbUJBQW1CLDZDQUFNLGtDQUFrQywrQ0FBUTtBQUNwRztBQUNBLDhDQUE4QywwQ0FBTTtBQUNwRDtBQUNBO0FBQ0EsOENBQThDLDBDQUFNO0FBQ3BELHlEQUF5RCwrQ0FBUTtBQUNqRTtBQUNBLHVIQUF1SCxxREFBVyxrS0FBa0ssZ0RBQVM7QUFDN1M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQVc7QUFDbEMscUJBQXFCLHFEQUFXLHVDQUF1Qyx3Q0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQUksd0RBQXdELDhCQUE4QixLQUFLLDJCQUEyQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQUksNERBQTRELGdDQUFnQyxLQUFLLDJCQUEyQjtBQUNySjtBQUNBLFVBQVUsd0NBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYyxZQUFZLHdCQUF3QixLQUFLLDRCQUE0QixHQUFHLGFBQWEsS0FBSyw4Q0FBVTtBQUNsSjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXLGlDQUFpQyxZQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHNEQUFHLFVBQVU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0RBQUcsQ0FBQyx1REFBUSxJQUFJLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsK09BQStPLHVEQUFJLFVBQVU7QUFDN1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLDREQUFjLGVBQWUseURBQVcsZUFBZSw2Q0FBTSwrQkFBK0IsNkNBQU0sa0RBQWtELHlDQUFLLDhDQUE4Qyw4Q0FBTztBQUMvTjtBQUNBLG9CQUFvQiw4Q0FBTztBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFXLHNDQUFzQywwQ0FBTTtBQUN4RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSwyQ0FBUztBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLDZCQUE2Qix1REFBSSxXQUFXO0FBQzVDO0FBQ0Esd0JBQXdCLHVEQUFJLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFHLGtCQUFrQixPQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDBDQUEwQyxzREFBRyxrQkFBa0IsT0FBTztBQUN0RSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxNQUFNO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0hBQStILGtCQUFrQixxQkFBcUIsV0FBVztBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvQ0FBb0Msc0RBQUcsb0JBQW9CLGdIQUFnSCxzREFBRyx5QkFBeUIseUJBQXlCLEdBQUc7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQixzREFBRyxVQUFVLGdFQUFnRSxzREFBRyxtQkFBbUIsdURBQXVELHNEQUFHLFVBQVUsaURBQWlELEdBQUcsR0FBRztBQUN6UDtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsY0FBYztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFHLGtCQUFrQixPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLHVEQUFJLFVBQVU7QUFDdkM7QUFDQSxvQkFBb0IsdURBQUksbUJBQW1CO0FBQzNDLGdEQUFnRCxzREFBRyxVQUFVLHNFQUFzRTtBQUNuSSxpREFBaUQsc0RBQUcsdUJBQXVCLG9DQUFvQyxzREFBRyxrQkFBa0IsT0FBTyxHQUFHO0FBQzlJLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxvREFBYTtBQUMvQyxpQkFBaUIsaURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpRkFBaUYsc0RBQUcsV0FBVywyREFBMkQ7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGlDQUFpQztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFNO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxrTkFBa04sc0VBQWdCO0FBQ3ZPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxnT0FBZ08sc0VBQWdCO0FBQ3JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFNO0FBQzVCO0FBQ0E7QUFDQSxPQUFPLEVBQUUsa0RBQVc7QUFDcEIsY0FBYywyREFBRztBQUNqQjtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQUc7QUFDN0IsMkJBQTJCLDJEQUFHO0FBQzlCO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCwwQkFBMEIsMENBQUc7QUFDN0IsMkJBQTJCLDJEQUFHO0FBQzlCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRCwrQkFBK0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4REFBTTtBQUNoQztBQUNBLE9BQU8sT0FBTyxvRUFBWSxtQkFBbUIsOERBQU07QUFDbkQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3Q0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxjQUFjLDhEQUFNO0FBQ3BCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQ0FBbUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOERBQU07QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCx1QkFBdUIsNkRBQUs7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUIsOERBQU07QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTLGtCQUFrQiwyREFBRztBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQUs7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQSwwSkFBMEosb0JBQW9CLGdGQUFnRiw2REFBSztBQUNuUTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQUc7QUFDeEI7QUFDQSxTQUFTLGtCQUFrQiw2REFBSztBQUNoQztBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILDJEQUFHO0FBQ3JIO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTywyREFBMkQsaUJBQWlCLHNMQUFzTCw2REFBSztBQUM5UTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU8sbURBQW1ELGlCQUFpQjtBQUMzRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQUs7QUFDeEI7QUFDQSxPQUFPLGtCQUFrQiw4REFBTTtBQUMvQjtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxtQkFBbUIsNkRBQUs7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPLGtCQUFrQiw4REFBTTtBQUMvQjtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBVztBQUNuQixPQUFPO0FBQ1A7QUFDQSxRQUFRLHFEQUFXO0FBQ25CLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFdBQVcsMENBQU07QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFVLGtDQUFrQyw4Q0FBVTtBQUMvRSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3Qix3Q0FBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3Qix3Q0FBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBDQUFNO0FBQzlDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTLDJKQUEySix3Q0FBSTtBQUN4SztBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUksOENBQVU7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBTTtBQUM3QywyQkFBMkIsMENBQU07QUFDakM7QUFDQTtBQUNBLFdBQVc7QUFDWCxpQkFBaUIsMENBQU0sd0ZBQXdGLDhDQUFVO0FBQ3pIO0FBQ0EsV0FBVztBQUNYO0FBQ0Esc0NBQXNDLDBDQUFNO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSwwQ0FBTSwwRkFBMEYsOENBQVU7QUFDekg7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFDQUFxQywwQ0FBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUFNO0FBQzFDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsaUJBQWlCLHFEQUFXO0FBQzVCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBDQUFNO0FBQ3REO0FBQ0EsNkJBQTZCLHdDQUFJO0FBQ2pDLFdBQVc7QUFDWDtBQUNBLDRCQUE0QiwwQ0FBTTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWMsd0NBQUk7QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBTTtBQUNsQztBQUNBLDZCQUE2Qix3Q0FBSTtBQUNqQyxXQUFXO0FBQ1gsNERBQTRELGtFQUFvQjtBQUNoRjtBQUNBLDRCQUE0QiwwQ0FBTTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCx5Q0FBeUMsa0VBQW9CO0FBQzdELFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGtDQUFrQyx5Q0FBSztBQUN2QztBQUNBO0FBQ0EsVUFBVSwwQ0FBTTtBQUNoQjtBQUNBO0FBQ0EsbUNBQW1DLDBDQUFNO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIseUNBQUs7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILDhDQUFVO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWUsR0FBRyx5Q0FBSyxxR0FBcUcsOENBQVUsb0JBQW9CO0FBQzFKLHVCQUF1Qix3Q0FBSTtBQUMzQjtBQUNBLGVBQWU7QUFDZiwrQkFBK0Isd0NBQUk7QUFDbkM7QUFDQSxpREFBaUQseUNBQUs7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBVTtBQUMxQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsOENBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSw0RkFBNEYsOENBQVU7QUFDdEc7QUFDQTtBQUNBLHdGQUF3RiwyQ0FBUztBQUNqRyxhQUFhLHdGQUF3Riw4Q0FBVTtBQUMvRztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkNBQVM7QUFDcEQsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw4Q0FBOEMsMENBQU07QUFDcEQ7QUFDQSxnQkFBZ0IseUNBQUs7QUFDckIseUNBQXlDLDBDQUFNO0FBQy9DO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx5SkFBeUosMENBQU07QUFDL0o7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdDQUFJO0FBQ25EO0FBQ0EsZUFBZTtBQUNmLGdEQUFnRCx3Q0FBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdDQUFJO0FBQ25ELGdEQUFnRCx3Q0FBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFVO0FBQzFCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCxjQUFjLDhDQUFVLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsNkJBQTZCLDBDQUFNO0FBQ25DO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQ0FBaUMsd0NBQUk7QUFDckM7QUFDQSxvREFBb0QseUNBQUs7QUFDekQ7QUFDQTtBQUNBLG9FQUFvRSw4Q0FBVTtBQUM5RTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdEQUF3RCx5Q0FBSztBQUM3RCx1REFBdUQseUNBQUs7QUFDNUQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlDQUFLLG9CQUFvQix5Q0FBSyxvQkFBb0IseUNBQUs7QUFDdEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLDBDQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLDJDQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRyw4Q0FBVTtBQUN4QjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EseUNBQXlDLHdDQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRyw4Q0FBVTtBQUMxQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0EseUdBQXlHLHdCQUF3QjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0VBQStFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtSEFBbUg7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBNkM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwRUFBMEU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEMsc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFLQUFxSztBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQW1FO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdWpCQUF1akIsNEJBQTRCO0FBQ25sQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJLHdDQUFJO0FBQzNJO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTCxnREFBZ0QsZUFBZSxtQ0FBbUMsOENBQVU7QUFDNUc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCwrQ0FBK0MsZ0JBQWdCLHNEQUFzRCwyQ0FBUyxtQ0FBbUMsOENBQVU7QUFDM0s7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3Q0FBSSxrQkFBa0Isd0NBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJLFNBQVMsMkNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSixtQkFBbUIsZ0VBQVE7QUFDM0IsV0FBVyw4Q0FBVTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBVTtBQUNyQixNQUFNLDhDQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQLEtBQUssR0FBRyw4Q0FBVTtBQUNsQjtBQUNBLEtBQUsseUJBQXlCLDhDQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVyxtQ0FBbUMsOENBQVU7QUFDdEc7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4TEFBOEwsMEJBQTBCLHNGQUFzRiwwQkFBMEIsSUFBSSw4Q0FBVTtBQUN0VjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVUsb0VBQW9FLFVBQVU7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsMkNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFPO0FBQzNDLFdBQVc7QUFDWCwrREFBK0QsNkNBQVM7QUFDeEU7QUFDQSxZQUFZLDBDQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsYUFBYTtBQUNiLFlBQVk7QUFDWix3R0FBd0csOENBQVU7QUFDbEg7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQ0FBTztBQUMzQyxXQUFXO0FBQ1g7QUFDQSxZQUFZLDBDQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsYUFBYTtBQUNiLFlBQVk7QUFDWix3R0FBd0csOENBQVU7QUFDbEg7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlLHlCQUF5QixXQUFXLGdDQUFnQywwQkFBMEIscUJBQXFCLHNCQUFzQjtBQUNuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw4Q0FBTztBQUN4RTtBQUNBLEtBQUs7QUFDTCw2Q0FBNkMsbUJBQW1CLFNBQVMsMEJBQTBCLHlCQUF5QixXQUFXO0FBQ3ZJO0FBQ0E7QUFDQSx3RUFBd0UsOENBQU87QUFDL0U7QUFDQSxLQUFLO0FBQ0wsNFBBQTRQLGlDQUFpQyw4Q0FBOEMsMEJBQTBCLHlCQUF5QixXQUFXO0FBQ3pZO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQSxxQ0FBcUMsOENBQU87QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0xBQXdMLHdDQUFJLG9LQUFvSyx3Q0FBSTtBQUNwVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxzQkFBc0I7QUFDMUYsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyw4REFBTTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhKQUE4Siw2REFBSztBQUNuSztBQUNBO0FBQ0EsT0FBTyx3REFBd0Qsb0VBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBTTtBQUN0QywyQkFBMkIsd0NBQUk7QUFDL0IsZ0ZBQWdGLDBDQUFNO0FBQ3RGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdLQUF3Syx3Q0FBSTtBQUM1SywwQkFBMEIsMENBQU07QUFDaEMsY0FBYyx3Q0FBSTtBQUNsQixpREFBaUQsY0FBYztBQUMvRDtBQUNBLGFBQWEsR0FBRyw4Q0FBVTtBQUMxQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4REFBOEQsMENBQU07QUFDekU7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsMENBQU07QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUCxtR0FBbUcsV0FBVyxLQUFLLDhDQUFVO0FBQzdIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTLDZDQUE2QyxXQUFXLHNEQUFzRCw4Q0FBVTtBQUNqSTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGNBQWMsMEVBQTBFLGNBQWM7QUFDbEwsS0FBSztBQUNMLDhCQUE4QiwwQ0FBTTtBQUNwQztBQUNBLHlCQUF5QiwyQ0FBUztBQUNsQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjLEtBQUssOENBQVU7QUFDbEU7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDhCQUE4QiwwQ0FBTTtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQLGlDQUFpQyxjQUFjLEtBQUssOENBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQywwQ0FBTTtBQUN2QztBQUNBLHlCQUF5QiwyQ0FBUyw4RUFBOEUsd0NBQUk7QUFDcEgsT0FBTztBQUNQO0FBQ0EsUUFBUSwyQ0FBUyw0Q0FBNEMsOENBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQywwQ0FBTTtBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtNQUErTSw4Q0FBVTtBQUN6TjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQywwQ0FBTTtBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1DQUFtQyx3Q0FBSTtBQUN2QztBQUNBLEdBQUc7QUFDSCxvQ0FBb0Msd0NBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUNBQW1DLHdDQUFJO0FBQ3ZDLG9DQUFvQyx3Q0FBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQiw4Q0FBVTtBQUNyQztBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBSTtBQUM3QjtBQUNBO0FBQ0EseUVBQXlFLDhDQUFPO0FBQ2hGO0FBQ0E7QUFDQSxhQUFhLEdBQUcsOENBQVU7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyw4Q0FBVTtBQUN0QjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLDhDQUFVO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBSSx5QkFBeUIsMENBQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHLDhDQUFVO0FBQ3hCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0NBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRyw4Q0FBVTtBQUM1QjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdDQUFJLHlCQUF5QiwwQ0FBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHLDhDQUFVO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUcsOENBQVU7QUFDeEI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csd0NBQUk7QUFDcEcsOEJBQThCLDhDQUFPO0FBQ3JDO0FBQ0E7QUFDQSxXQUFXLEdBQUcsOENBQVU7QUFDeEI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQ0FBTTtBQUMvQyw2Q0FBNkMseUNBQUs7QUFDbEQ7QUFDQTtBQUNBLFNBQVMsNkJBQTZCLHlDQUFLO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQywwQ0FBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNDQUFzQywwQ0FBTTtBQUM1QztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsWUFBWSw4Q0FBVTtBQUN0QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBVTtBQUN0QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQ0FBMkMseUNBQUs7QUFDMUQ7QUFDQSxzQ0FBc0MsMENBQU07QUFDNUM7QUFDQSxXQUFXLGlDQUFpQywwQ0FBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0IsOENBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0IsOENBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUJBQXlCLHlDQUFLO0FBQzlCLHFDQUFxQywwQ0FBTTtBQUMzQztBQUNBLFdBQVcsaUNBQWlDLDBDQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBTTtBQUN6QixlQUFlO0FBQ2YsY0FBYywwQ0FBTTtBQUNwQiw0QkFBNEIsOENBQVU7QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwQ0FBTTtBQUNoRDtBQUNBLDJHQUEyRywyQ0FBSTtBQUMvRyxnRUFBZ0UsOENBQVU7QUFDMUU7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVkseUNBQUs7QUFDakIsVUFBVSwwQ0FBTTtBQUNoQixZQUFZLDhDQUFVLG9CQUFvQjtBQUMxQyxxQkFBcUIsd0NBQUk7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixtQ0FBbUMseUNBQUssaUNBQWlDLDBDQUFNO0FBQy9FO0FBQ0EscUJBQXFCLHdDQUFJO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYyw4Q0FBVTtBQUN4QjtBQUNBLGVBQWU7QUFDZjtBQUNBLHVCQUF1Qix3Q0FBSTtBQUMzQjtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxxQ0FBcUMsMENBQU07QUFDM0M7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVksOENBQVU7QUFDdEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQSxpQkFBaUIsMENBQU07QUFDdkIsYUFBYTtBQUNiLGlCQUFpQiwwQ0FBTSxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSx5Q0FBSztBQUNqQixVQUFVLDBDQUFNO0FBQ2hCLFlBQVksOENBQVUsb0JBQW9CO0FBQzFDLHFCQUFxQix3Q0FBSTtBQUN6QjtBQUNBO0FBQ0EsYUFBYSwyQkFBMkIsMENBQU07QUFDOUM7QUFDQSxxQkFBcUIsd0NBQUk7QUFDekIsYUFBYTtBQUNiO0FBQ0EsY0FBYywyQ0FBUyxzREFBc0QsOENBQVU7QUFDdkY7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVyxHQUFHLDBDQUFNO0FBQ3BCO0FBQ0EscUNBQXFDLDBDQUFNO0FBQzNDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZLDhDQUFVO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsaUJBQWlCLDBDQUFNO0FBQ3ZCLGFBQWE7QUFDYixpQkFBaUIsMENBQU0sb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLDBDQUFNO0FBQzdDLGVBQWUsd0NBQUk7QUFDbkI7QUFDQSxPQUFPO0FBQ1AsYUFBYSx5Q0FBSztBQUNsQjtBQUNBO0FBQ0EsT0FBTztBQUNQLFdBQVcsMENBQU07QUFDakIsT0FBTztBQUNQLEtBQUs7QUFDTCw4REFBOEQsS0FBSyxLQUFLLDBDQUFNLG1EQUFtRCxLQUFLLEtBQUssMENBQU07QUFDakosS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQ0FBaUMsR0FBRyxpQ0FBaUM7QUFDN0g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9DQUFvQyx1RUFBdUIsa0ZBQWtGLGtFQUFvQixrRkFBa0YsdUVBQXVCO0FBQzFRO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsOENBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLDhDQUFVO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IseUNBQUs7QUFDN0IsMkJBQTJCLDBDQUFNO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDBCQUEwQix3Q0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsaUVBQWlFLDhDQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BELGdCQUFnQix3REFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRLFlBQVksS0FBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCxnQkFBZ0Isd0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHdEQUFRLHNDQUFzQyx3REFBUSwyQ0FBMkMsd0RBQVEsaURBQWlELHdEQUFRLGdEQUFnRCx3REFBUSx5Q0FBeUMsd0RBQVE7QUFDalM7QUFDQSwyQkFBMkIsd0NBQUk7QUFDL0IsMEJBQTBCLDBDQUFNO0FBQ2hDLDJCQUEyQix3Q0FBSTtBQUMvQixlQUFlLHdDQUFJO0FBQ25CLFlBQVksOENBQVU7QUFDdEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhLEdBQUcsOENBQVU7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLHdDQUFJO0FBQ3BGLDBDQUEwQywwQ0FBTTtBQUNoRCxVQUFVLDhDQUFVO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVyxHQUFHLDhDQUFVO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMENBQU07QUFDbkM7QUFDQSxTQUFTLGtCQUFrQixrRUFBb0IsZUFBZSwwQ0FBTTtBQUNwRTtBQUNBLFNBQVMsMkNBQTJDLHVFQUF1QixnQkFBZ0Isa0VBQW9CLDZJQUE2SSx5Q0FBSywwQ0FBMEMsMENBQU07QUFDalQsc0JBQXNCLGtFQUFvQjtBQUMxQztBQUNBO0FBQ0EscUZBQXFGLHdDQUFJO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0osU0FBUyxxREFBYTtBQUN0QjtBQUNBLGtCQUFrQiw2REFBSztBQUN2QixxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQiwyREFBRztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNULHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBRztBQUN2QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLDJDQUEyQyxTQUFTLDJCQUEyQixVQUFVLHNEQUFzRCxxQkFBcUI7QUFDcEssK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsdUVBQXVCO0FBQ2xEO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0JBQWtCLDJEQUFHO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QseUNBQXlDLFNBQVMsNkVBQTZFLGlCQUFpQjtBQUNoSiw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQkFBa0IsNkRBQUs7QUFDdkI7QUFDQSxTQUFTO0FBQ1QseUNBQXlDLFNBQVMsdUJBQXVCLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0JBQWtCLDZEQUFLO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFHO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQVk7QUFDaEM7QUFDQSxXQUFXLGdCQUFnQiw4REFBTTtBQUNqQztBQUNBLFdBQVc7QUFDWCw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsMkNBQUksQ0FBQywrQ0FBTztBQUN2QztBQUNBLCtCQUErQiwyQ0FBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkRBQUs7QUFDN0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2Isb0ZBQW9GLDBCQUEwQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJEQUFHO0FBQ3BEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLDZDQUE2QyxTQUFTLG9CQUFvQixTQUFTO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQWE7QUFDMUI7QUFDQSxzQkFBc0IsNkRBQUs7QUFDM0I7QUFDQSxhQUFhO0FBQ2IsNENBQTRDLE9BQU8sdUJBQXVCLFNBQVM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQUc7QUFDekI7QUFDQSxhQUFhO0FBQ2IsMkNBQTJDLFFBQVEsOENBQThDLFNBQVM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLG9CQUFvQiwyREFBRztBQUN2QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLDJDQUEyQyxXQUFXLHVCQUF1QixTQUFTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9CQUFvQiw2REFBSztBQUN6QjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCwyQ0FBMkMsV0FBVyx1QkFBdUIsU0FBUyxrQ0FBa0MsWUFBWTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9CQUFvQiw2REFBSztBQUN6QjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCwyQ0FBMkMsV0FBVyx1QkFBdUIsU0FBUztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvVUFBb1UsaUZBQWlGLG1CQUFtQixnRkFBZ0Y7O0FBRXhmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwyQkFBMkIseUNBQUssK0JBQStCLDBDQUFNO0FBQ3JFO0FBQ0EsT0FBTyxhQUFhLDBDQUFNO0FBQzFCO0FBQ0EsT0FBTztBQUNQLFVBQVUseUNBQUs7QUFDZjtBQUNBLHVCQUF1QixxREFBVztBQUNsQztBQUNBO0FBQ0EseUVBQXlFLHFEQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQVk7QUFDekM7QUFDQSxXQUFXLGlCQUFpQixvRUFBYztBQUMxQztBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDViw0Q0FBNEMsMkJBQTJCLEdBQUcsOEJBQThCLHlDQUF5Qyw0QkFBNEI7QUFDN0sseUJBQXlCLGtFQUFZLHNEQUFzRCxvRUFBYztBQUN6RztBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxvQ0FBb0MsY0FBYyxjQUFjLGlDQUFpQztBQUNqRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsYUFBYTtBQUNiLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQU07QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHVHQUF1Ryw4Q0FBTyxvQ0FBb0MsOENBQVU7QUFDNUosa0JBQWtCLDJDQUFJO0FBQ3RCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwREFBMEQsOENBQVU7QUFDcEU7QUFDQSxLQUFLLG9DQUFvQyw4Q0FBVTtBQUNuRDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EscUJBQXFCLDJDQUFJO0FBQ3pCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsWUFBWSx5REFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sY0FBYyx1REFBUyxDQUFDLG9EQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QyxzQ0FBc0M7QUFDcEYsR0FBRztBQUNILGVBQWUsK0NBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzRkFBc0YsZ0RBQVM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyx5T0FBeU8sZ0RBQVM7QUFDclA7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0dBQWtHLGdEQUFTO0FBQzlHO0FBQ0EsOEdBQThHLHNEQUFHLENBQUMsK0NBQUssSUFBSSw2REFBNkQ7QUFDeEw7QUFDQTtBQUNBLDBDQUEwQyxvREFBYTtBQUN2RCxtQkFBbUIsaURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFpRiw2Q0FBTSxrQkFBa0Isc0RBQVEsNkJBQTZCLDZDQUFNLDZCQUE2QixrREFBVztBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdEQUFnRCw4Q0FBTyxPQUFPLGdEQUFRO0FBQ3pFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyw4Q0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsMENBQU07QUFDOUU7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBVTtBQUN0QztBQUNBO0FBQ0EsY0FBYyw4Q0FBVTtBQUN4QjtBQUNBLGVBQWU7QUFDZixhQUFhLEdBQUcsOENBQVU7QUFDMUI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhLG1CQUFtQiw4Q0FBVTtBQUMxQyxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsMENBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9DQUFvQztBQUN6RixvQkFBb0IsOENBQVU7QUFDOUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOENBQU87QUFDMUM7QUFDQSxzTkFBc04sOEJBQThCLHVCQUF1Qix3QkFBd0IsS0FBSyxtQ0FBbUM7QUFDM1U7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUxBQXlMLDhDQUFVO0FBQ25NO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxtREFBbUQsOENBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBVSx3QkFBd0IsOENBQVU7QUFDdkU7QUFDQSxHQUFHLEdBQUcsOENBQVU7QUFDaEI7QUFDQSxHQUFHLG9EQUFvRCw4Q0FBVTtBQUNqRTtBQUNBO0FBQ0EsTUFBTSw4Q0FBVTtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOENBQVU7QUFDOUQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLHlGQUF5Riw4Q0FBTyxxREFBcUQsOENBQU87QUFDNUo7QUFDQTtBQUNBLCtFQUErRSw4Q0FBVTtBQUN6RjtBQUNBLFdBQVc7QUFDWCw2QkFBNkIsd0NBQUksb0VBQW9FLHdDQUFJO0FBQ3pHLHlDQUF5Qyw4Q0FBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHLDhDQUFVO0FBQ3hCO0FBQ0EsV0FBVyxnSEFBZ0gsOENBQVU7QUFDckk7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVLHFFQUFxRSw4Q0FBVTtBQUN6RjtBQUNBLFNBQVMsR0FBRyw4Q0FBVTtBQUN0QjtBQUNBLFNBQVMsa0dBQWtHLDhDQUFVO0FBQ3JIO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUpBQWlKLE1BQStCLEdBQUcsQ0FBRztBQUN0TDtBQUNBLFlBQVkseURBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EseUJBQXlCLDZDQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0RBQW9ELHNEQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEZBQTBGLGdEQUFTO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnREFBZ0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtSEFBbUgsZ0RBQVM7QUFDL0g7QUFDQTtBQUNBLHVCQUF1QixpRUFBYztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLGdEQUFRO0FBQ25ELFVBQVUsMENBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRywyTkFBMk4sZ0RBQVM7QUFDdk87QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3SUFBd0ksZ0RBQVM7QUFDcEosa0NBQWtDLDZDQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsd0pBQXdKLGdEQUFTO0FBQ3BLO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQWEsR0FBRztBQUMzQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQ0FBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb1ZBQW9WLHdDQUFJO0FBQzNWO0FBQ0EseUJBQXlCLHlDQUFLLDhDQUE4Qyw4Q0FBTztBQUNuRjtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2Qix5Q0FBSztBQUNsQyxNQUFNLDBDQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhCQUE4Qix3Q0FBSTtBQUNsQyxNQUFNLDhDQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUdBQXVHLDhDQUFPO0FBQzlHO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLHlDQUFLO0FBQ2hDLE1BQU0sMENBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOEJBQThCLHdDQUFJO0FBQ2xDLE1BQU0sOENBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMENBQU07QUFDWjtBQUNBO0FBQ0EsUUFBUSw4Q0FBVTtBQUNsQjtBQUNBLFNBQVM7QUFDVCx5Q0FBeUMsMENBQU0sY0FBYyx3Q0FBSTtBQUNqRTtBQUNBLFNBQVM7QUFDVCxZQUFZLDhDQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1RkFBdUYsd0NBQUksa0hBQWtILHdDQUFJO0FBQ2pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBTyxxQkFBcUIsOENBQVU7QUFDbEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVSw4Q0FBTyxvQ0FBb0MsOENBQVU7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0sOENBQVU7QUFDaEI7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSw4Q0FBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUksc0RBQWM7QUFDbEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSxxREFBYTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0EsNEVBQTRFLDhDQUFVO0FBQ3RGO0FBQ0EsS0FBSyxJQUFJLDhDQUFVO0FBQ25CO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSxrREFBVTtBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSwwQ0FBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSw4Q0FBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFIQUFxSCx1RUFBdUI7QUFDNUk7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlIQUFpSCx1RUFBdUI7QUFDeEk7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxrR0FBa0cscURBQVk7QUFDL0c7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztB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cnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4Lm1qcz83NmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4gYXMgaXNQb3J0YWJsZVRleHRTcGFuJDEsIGlzS2V5U2VnbWVudCwgaXNQb3J0YWJsZVRleHRMaXN0QmxvY2sgfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuaW1wb3J0IHsganN4LCBGcmFnbWVudCwganN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwibG9kYXNoL25vb3AuanNcIjtcbmltcG9ydCByZXF1aXJlJCQwLCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbywgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIHN0YXJ0VHJhbnNpdGlvbiwgQ29tcG9uZW50LCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEVkaXRvciwgRWxlbWVudCBhcyBFbGVtZW50JDEsIFJhbmdlLCBQb2ludCwgVGV4dCwgUGF0aCwgVHJhbnNmb3JtcywgTm9kZSwgT3BlcmF0aW9uLCBjcmVhdGVFZGl0b3IsIGRlbGV0ZUJhY2t3YXJkLCBkZWxldGVGb3J3YXJkLCBpbnNlcnRUZXh0IH0gZnJvbSBcInNsYXRlXCI7XG5pbXBvcnQgeyB1c2VTbGF0ZVN0YXRpYywgUmVhY3RFZGl0b3IsIHVzZVNlbGVjdGVkLCB3aXRoUmVhY3QsIFNsYXRlLCB1c2VTbGF0ZSwgRWRpdGFibGUgfSBmcm9tIFwic2xhdGUtcmVhY3RcIjtcbmltcG9ydCBkZWJ1ZyRtIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgYyB9IGZyb20gXCJyZWFjdC1jb21waWxlci1ydW50aW1lXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBmcm9tQ2FsbGJhY2ssIHNldHVwLCBhc3NpZ24sIGFzc2VydEV2ZW50LCBlbWl0LCBlbnF1ZXVlQWN0aW9ucywgY3JlYXRlQWN0b3IsIHRvT2JzZXJ2ZXIgfSBmcm9tIFwieHN0YXRlXCI7XG5pbXBvcnQgeyBTY2hlbWEgfSBmcm9tIFwiQHNhbml0eS9zY2hlbWFcIjtcbmltcG9ydCB7IGRpZmZNYXRjaFBhdGNoIGFzIGRpZmZNYXRjaFBhdGNoJDEsIHNldCwgaW5zZXJ0LCBzZXRJZk1pc3NpbmcsIHVuc2V0LCBhcHBseUFsbCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3BhdGNoZXNcIjtcbmltcG9ydCBnZXQgZnJvbSBcImxvZGFzaC9nZXQuanNcIjtcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tIFwibG9kYXNoL2lzVW5kZWZpbmVkLmpzXCI7XG5pbXBvcnQgb21pdEJ5IGZyb20gXCJsb2Rhc2gvb21pdEJ5LmpzXCI7XG5pbXBvcnQgZmxhdHRlbiBmcm9tIFwibG9kYXNoL2ZsYXR0ZW4uanNcIjtcbmltcG9ydCB7IGlzSG90a2V5IH0gZnJvbSBcImlzLWhvdGtleS1lc21cIjtcbmltcG9ydCB7IGh0bWxUb0Jsb2Nrcywgbm9ybWFsaXplQmxvY2sgfSBmcm9tIFwiQHNhbml0eS9ibG9jay10b29sc1wiO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSBcImxvZGFzaC9pc1BsYWluT2JqZWN0LmpzXCI7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSBcImxvZGFzaC90aHJvdHRsZS5qc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0RXZlbnQgfSBmcm9tIFwidXNlLWVmZmVjdC1ldmVudFwiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCJsb2Rhc2gvZGVib3VuY2UuanNcIjtcbmltcG9ydCB7IHJhbmRvbUtleSB9IGZyb20gXCJAc2FuaXR5L3V0aWwvY29udGVudFwiO1xuZnVuY3Rpb24gZGVmaW5lQmVoYXZpb3IoYmVoYXZpb3IpIHtcbiAgcmV0dXJuIGJlaGF2aW9yO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uSXNDb2xsYXBzZWQoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5zZWxlY3Rpb24/LmFuY2hvci5wYXRoLmpvaW4oKSA9PT0gY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLnBhdGguam9pbigpICYmIGNvbnRleHQuc2VsZWN0aW9uPy5hbmNob3Iub2Zmc2V0ID09PSBjb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0O1xufVxuZnVuY3Rpb24gZ2V0Rm9jdXNCbG9jayhjb250ZXh0KSB7XG4gIGNvbnN0IGtleSA9IGNvbnRleHQuc2VsZWN0aW9uICYmIGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IGNvbnRleHQudmFsdWUuZmluZCgoYmxvY2spID0+IGJsb2NrLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0Rm9jdXNUZXh0QmxvY2soY29udGV4dCkge1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNCbG9jayhjb250ZXh0KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRGb2N1c0Jsb2NrT2JqZWN0KGNvbnRleHQpIHtcbiAgY29uc3QgZm9jdXNCbG9jayA9IGdldEZvY3VzQmxvY2soY29udGV4dCk7XG4gIHJldHVybiBmb2N1c0Jsb2NrICYmICFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhmb2N1c0Jsb2NrLm5vZGUpID8ge1xuICAgIG5vZGU6IGZvY3VzQmxvY2subm9kZSxcbiAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldEZvY3VzQ2hpbGQoY29udGV4dCkge1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soY29udGV4dCk7XG4gIGlmICghZm9jdXNCbG9jaylcbiAgICByZXR1cm47XG4gIGNvbnN0IGtleSA9IGNvbnRleHQuc2VsZWN0aW9uICYmIGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzJdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IGZvY3VzQmxvY2subm9kZS5jaGlsZHJlbi5maW5kKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFsuLi5mb2N1c0Jsb2NrLnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldEZvY3VzU3Bhbihjb250ZXh0KSB7XG4gIGNvbnN0IGZvY3VzQ2hpbGQgPSBnZXRGb2N1c0NoaWxkKGNvbnRleHQpO1xuICByZXR1cm4gZm9jdXNDaGlsZCAmJiBpc1BvcnRhYmxlVGV4dFNwYW4kMShmb2N1c0NoaWxkLm5vZGUpID8ge1xuICAgIG5vZGU6IGZvY3VzQ2hpbGQubm9kZSxcbiAgICBwYXRoOiBmb2N1c0NoaWxkLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblN0YXJ0QmxvY2soY29udGV4dCkge1xuICBjb25zdCBrZXkgPSBjb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCA6IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwLCBub2RlID0ga2V5ID8gY29udGV4dC52YWx1ZS5maW5kKChibG9jaykgPT4gYmxvY2suX2tleSA9PT0ga2V5KSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgJiYga2V5ID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25FbmRCbG9jayhjb250ZXh0KSB7XG4gIGNvbnN0IGtleSA9IGNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdLl9rZXkgOiB2b2lkIDAgOiBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBjb250ZXh0LnZhbHVlLmZpbmQoKGJsb2NrKSA9PiBibG9jay5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzQmxvY2soY29udGV4dCkge1xuICBsZXQgcHJldmlvdXNCbG9jaztcbiAgY29uc3Qgc2VsZWN0aW9uU3RhcnRCbG9jayA9IGdldFNlbGVjdGlvblN0YXJ0QmxvY2soY29udGV4dCk7XG4gIGlmICghc2VsZWN0aW9uU3RhcnRCbG9jaylcbiAgICByZXR1cm47XG4gIGxldCBmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAhMTtcbiAgZm9yIChjb25zdCBibG9jayBvZiBjb250ZXh0LnZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHNlbGVjdGlvblN0YXJ0QmxvY2subm9kZS5fa2V5KSB7XG4gICAgICBmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAhMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91c0Jsb2NrID0ge1xuICAgICAgbm9kZTogYmxvY2ssXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XVxuICAgIH07XG4gIH1cbiAgaWYgKGZvdW5kU2VsZWN0aW9uU3RhcnRCbG9jayAmJiBwcmV2aW91c0Jsb2NrKVxuICAgIHJldHVybiBwcmV2aW91c0Jsb2NrO1xufVxuZnVuY3Rpb24gZ2V0TmV4dEJsb2NrKGNvbnRleHQpIHtcbiAgbGV0IG5leHRCbG9jaztcbiAgY29uc3Qgc2VsZWN0aW9uRW5kQmxvY2sgPSBnZXRTZWxlY3Rpb25FbmRCbG9jayhjb250ZXh0KTtcbiAgaWYgKCFzZWxlY3Rpb25FbmRCbG9jaylcbiAgICByZXR1cm47XG4gIGxldCBmb3VuZFNlbGVjdGlvbkVuZEJsb2NrID0gITE7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGV4dC52YWx1ZSkge1xuICAgIGlmIChibG9jay5fa2V5ID09PSBzZWxlY3Rpb25FbmRCbG9jay5ub2RlLl9rZXkpIHtcbiAgICAgIGZvdW5kU2VsZWN0aW9uRW5kQmxvY2sgPSAhMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZm91bmRTZWxlY3Rpb25FbmRCbG9jaykge1xuICAgICAgbmV4dEJsb2NrID0ge1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChmb3VuZFNlbGVjdGlvbkVuZEJsb2NrICYmIG5leHRCbG9jaylcbiAgICByZXR1cm4gbmV4dEJsb2NrO1xufVxuZnVuY3Rpb24gaXNFbXB0eVRleHRCbG9jayhibG9jaykge1xuICByZXR1cm4gYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkJlaGF2aW9ycyhjb25maWcpIHtcbiAgY29uc3QgYXV0b21hdGljU3R5bGVPblNwYWNlID0ge1xuICAgIG9uOiBcImluc2VydCB0ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgbG9va3NMaWtlTWFya2Rvd25IZWFkaW5nID0gL14jKy8udGVzdChmb2N1c1NwYW4ubm9kZS50ZXh0KSwgaGVhZGluZ1N0eWxlID0gY29uZmlnLm1hcEhlYWRpbmdTdHlsZShjb250ZXh0LnNjaGVtYSwgZm9jdXNTcGFuLm5vZGUudGV4dC5sZW5ndGgpLCBsb29rc0xpa2VNYXJrZG93blF1b3RlID0gL14+Ly50ZXN0KGZvY3VzU3Bhbi5ub2RlLnRleHQpLCBibG9ja3F1b3RlU3R5bGUgPSBjb25maWcubWFwQmxvY2txdW90ZVN0eWxlKGNvbnRleHQuc2NoZW1hKTtcbiAgICAgIHJldHVybiBsb29rc0xpa2VNYXJrZG93bkhlYWRpbmcgJiYgaGVhZGluZ1N0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBmb2N1c1NwYW4sXG4gICAgICAgIHN0eWxlOiBoZWFkaW5nU3R5bGVcbiAgICAgIH0gOiBsb29rc0xpa2VNYXJrZG93blF1b3RlICYmIGJsb2NrcXVvdGVTdHlsZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgZm9jdXNTcGFuLFxuICAgICAgICBzdHlsZTogYmxvY2txdW90ZVN0eWxlXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3tcbiAgICAgIHR5cGU6IFwiaW5zZXJ0IHRleHRcIixcbiAgICAgIHRleHQ6IFwiIFwiXG4gICAgfV0sIChfLCB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIGZvY3VzU3BhbixcbiAgICAgIHN0eWxlXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwic2V0IGJsb2NrXCIsXG4gICAgICBzdHlsZSxcbiAgICAgIHBhdGhzOiBbZm9jdXNUZXh0QmxvY2sucGF0aF1cbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzU3Bhbi5wYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzU3Bhbi5wYXRoLFxuICAgICAgICAgIG9mZnNldDogZm9jdXNTcGFuLm5vZGUudGV4dC5sZW5ndGggKyAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XV1cbiAgfSwgY2xlYXJTdHlsZU9uQmFja3NwYWNlID0ge1xuICAgIG9uOiBcImRlbGV0ZSBiYWNrd2FyZFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgZGVmYXVsdFN0eWxlID0gY29uZmlnLm1hcERlZmF1bHRTdHlsZShjb250ZXh0LnNjaGVtYSk7XG4gICAgICByZXR1cm4gZGVmYXVsdFN0eWxlICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUuc3R5bGUgIT09IGNvbmZpZy5tYXBEZWZhdWx0U3R5bGUoY29udGV4dC5zY2hlbWEpICYmIGZvY3VzU3Bhbi5ub2RlLnRleHQgPT09IFwiXCIgPyB7XG4gICAgICAgIGRlZmF1bHRTdHlsZSxcbiAgICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgZGVmYXVsdFN0eWxlLFxuICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJzZXQgYmxvY2tcIixcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgICBwYXRoczogW2ZvY3VzVGV4dEJsb2NrLnBhdGhdXG4gICAgfV1dXG4gIH0sIGF1dG9tYXRpY0xpc3RPblNwYWNlID0ge1xuICAgIG9uOiBcImluc2VydCB0ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgbG9va3NMaWtlVW5vcmRlcmVkTGlzdCA9IC9eLS8udGVzdChmb2N1c1NwYW4ubm9kZS50ZXh0KSwgdW5vcmRlcmVkTGlzdFN0eWxlID0gY29uZmlnLm1hcFVub3JkZXJlZExpc3RTdHlsZShjb250ZXh0LnNjaGVtYSk7XG4gICAgICBpZiAobG9va3NMaWtlVW5vcmRlcmVkTGlzdCAmJiB1bm9yZGVyZWRMaXN0U3R5bGUgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgICBmb2N1c1NwYW4sXG4gICAgICAgICAgbGlzdEl0ZW06IHVub3JkZXJlZExpc3RTdHlsZVxuICAgICAgICB9O1xuICAgICAgY29uc3QgbG9va3NMaWtlT3JkZXJlZExpc3QgPSAvXjEuLy50ZXN0KGZvY3VzU3Bhbi5ub2RlLnRleHQpLCBvcmRlcmVkTGlzdFN0eWxlID0gY29uZmlnLm1hcE9yZGVyZWRMaXN0U3R5bGUoY29udGV4dC5zY2hlbWEpO1xuICAgICAgcmV0dXJuIGxvb2tzTGlrZU9yZGVyZWRMaXN0ICYmIG9yZGVyZWRMaXN0U3R5bGUgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICAgIGZvY3VzU3BhbixcbiAgICAgICAgbGlzdEl0ZW06IG9yZGVyZWRMaXN0U3R5bGVcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQgdGV4dFwiLFxuICAgICAgdGV4dDogXCIgXCJcbiAgICB9XSwgKF8sIHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgZm9jdXNTcGFuLFxuICAgICAgbGlzdEl0ZW1cbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJ1bnNldCBibG9ja1wiLFxuICAgICAgcHJvcHM6IFtcInN0eWxlXCJdLFxuICAgICAgcGF0aHM6IFtmb2N1c1RleHRCbG9jay5wYXRoXVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwic2V0IGJsb2NrXCIsXG4gICAgICBsaXN0SXRlbSxcbiAgICAgIGxldmVsOiAxLFxuICAgICAgcGF0aHM6IFtmb2N1c1RleHRCbG9jay5wYXRoXVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNTcGFuLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNTcGFuLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBmb2N1c1NwYW4ubm9kZS50ZXh0Lmxlbmd0aCArIDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dXVxuICB9O1xuICByZXR1cm4gW2F1dG9tYXRpY1N0eWxlT25TcGFjZSwgY2xlYXJTdHlsZU9uQmFja3NwYWNlLCBhdXRvbWF0aWNMaXN0T25TcGFjZV07XG59XG5jb25zdCByb290TmFtZSA9IFwic2FuaXR5LXB0ZTpcIjtcbmRlYnVnJG0ocm9vdE5hbWUpO1xuZnVuY3Rpb24gZGVidWdXaXRoTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IGAke3Jvb3ROYW1lfSR7bmFtZX1gO1xuICByZXR1cm4gZGVidWckbSAmJiBkZWJ1ZyRtLmVuYWJsZWQobmFtZXNwYWNlKSA/IGRlYnVnJG0obmFtZXNwYWNlKSA6IGRlYnVnJG0ocm9vdE5hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5ZWRQYXRoKHBvaW50LCB2YWx1ZSwgdHlwZXMpIHtcbiAgY29uc3QgYmxvY2tQYXRoID0gW3BvaW50LnBhdGhbMF1dO1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBibG9jayA9IHZhbHVlW2Jsb2NrUGF0aFswXV07XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGtleWVkQmxvY2tQYXRoID0gW3tcbiAgICBfa2V5OiBibG9jay5fa2V5XG4gIH1dO1xuICBpZiAoYmxvY2suX3R5cGUgIT09IHR5cGVzLmJsb2NrLm5hbWUpXG4gICAgcmV0dXJuIGtleWVkQmxvY2tQYXRoO1xuICBsZXQga2V5ZWRDaGlsZFBhdGg7XG4gIGNvbnN0IGNoaWxkUGF0aCA9IHBvaW50LnBhdGguc2xpY2UoMCwgMiksIGNoaWxkID0gQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgJiYgYmxvY2suY2hpbGRyZW5bY2hpbGRQYXRoWzFdXTtcbiAgcmV0dXJuIGNoaWxkICYmIChrZXllZENoaWxkUGF0aCA9IFtcImNoaWxkcmVuXCIsIHtcbiAgICBfa2V5OiBjaGlsZC5fa2V5XG4gIH1dKSwga2V5ZWRDaGlsZFBhdGggPyBbLi4ua2V5ZWRCbG9ja1BhdGgsIC4uLmtleWVkQ2hpbGRQYXRoXSA6IGtleWVkQmxvY2tQYXRoO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJyYXllZFBhdGgocG9pbnQsIGVkaXRvcikge1xuICBpZiAoIWVkaXRvcilcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBbXSxcbiAgICBtYXRjaDogKG4pID0+IGlzS2V5U2VnbWVudChwb2ludC5wYXRoWzBdKSAmJiBuLl9rZXkgPT09IHBvaW50LnBhdGhbMF0uX2tleVxuICB9KSlbMF0gfHwgW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFibG9jayB8fCAhRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoZWRpdG9yLmlzVm9pZChibG9jaykpXG4gICAgcmV0dXJuIFtibG9ja1BhdGhbMF0sIDBdO1xuICBjb25zdCBjaGlsZFBhdGggPSBbcG9pbnQucGF0aFsyXV0sIGNoaWxkSW5kZXggPSBibG9jay5jaGlsZHJlbi5maW5kSW5kZXgoKGNoaWxkKSA9PiBpc0VxdWFsKFt7XG4gICAgX2tleTogY2hpbGQuX2tleVxuICB9XSwgY2hpbGRQYXRoKSk7XG4gIGlmIChjaGlsZEluZGV4ID49IDAgJiYgYmxvY2suY2hpbGRyZW5bY2hpbGRJbmRleF0pIHtcbiAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2NoaWxkSW5kZXhdO1xuICAgIHJldHVybiBFbGVtZW50JDEuaXNFbGVtZW50KGNoaWxkKSAmJiBlZGl0b3IuaXNWb2lkKGNoaWxkKSA/IGJsb2NrUGF0aC5jb25jYXQoY2hpbGRJbmRleCkuY29uY2F0KDApIDogYmxvY2tQYXRoLmNvbmNhdChjaGlsZEluZGV4KTtcbiAgfVxuICByZXR1cm4gYmxvY2tQYXRoO1xufVxuZnVuY3Rpb24gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgcmFuZ2UsIHR5cGVzKSB7XG4gIGlmICghcmFuZ2UpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBhbmNob3IgPSBudWxsLCBmb2N1cyA9IG51bGw7XG4gIGNvbnN0IGFuY2hvclBhdGggPSByYW5nZS5hbmNob3IgJiYgY3JlYXRlS2V5ZWRQYXRoKHJhbmdlLmFuY2hvciwgdmFsdWUsIHR5cGVzKTtcbiAgYW5jaG9yUGF0aCAmJiByYW5nZS5hbmNob3IgJiYgKGFuY2hvciA9IHtcbiAgICBwYXRoOiBhbmNob3JQYXRoLFxuICAgIG9mZnNldDogcmFuZ2UuYW5jaG9yLm9mZnNldFxuICB9KTtcbiAgY29uc3QgZm9jdXNQYXRoID0gcmFuZ2UuZm9jdXMgJiYgY3JlYXRlS2V5ZWRQYXRoKHJhbmdlLmZvY3VzLCB2YWx1ZSwgdHlwZXMpO1xuICBmb2N1c1BhdGggJiYgcmFuZ2UuZm9jdXMgJiYgKGZvY3VzID0ge1xuICAgIHBhdGg6IGZvY3VzUGF0aCxcbiAgICBvZmZzZXQ6IHJhbmdlLmZvY3VzLm9mZnNldFxuICB9KTtcbiAgY29uc3QgYmFja3dhcmQgPSAhIShSYW5nZS5pc1JhbmdlKHJhbmdlKSAmJiBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKSk7XG4gIHJldHVybiBhbmNob3IgJiYgZm9jdXMgPyB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzLFxuICAgIGJhY2t3YXJkXG4gIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGlmICghc2VsZWN0aW9uIHx8ICFlZGl0b3IpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFuY2hvciA9IHtcbiAgICBwYXRoOiBjcmVhdGVBcnJheWVkUGF0aChzZWxlY3Rpb24uYW5jaG9yLCBlZGl0b3IpLFxuICAgIG9mZnNldDogc2VsZWN0aW9uLmFuY2hvci5vZmZzZXRcbiAgfSwgZm9jdXMgPSB7XG4gICAgcGF0aDogY3JlYXRlQXJyYXllZFBhdGgoc2VsZWN0aW9uLmZvY3VzLCBlZGl0b3IpLFxuICAgIG9mZnNldDogc2VsZWN0aW9uLmZvY3VzLm9mZnNldFxuICB9O1xuICByZXR1cm4gZm9jdXMucGF0aC5sZW5ndGggPT09IDAgfHwgYW5jaG9yLnBhdGgubGVuZ3RoID09PSAwID8gbnVsbCA6IGFuY2hvciAmJiBmb2N1cyA/IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiBtb3ZlUmFuZ2VCeU9wZXJhdGlvbihyYW5nZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyYW5nZS5hbmNob3IsIG9wZXJhdGlvbiksIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmZvY3VzLCBvcGVyYXRpb24pO1xuICByZXR1cm4gYW5jaG9yID09PSBudWxsIHx8IGZvY3VzID09PSBudWxsID8gbnVsbCA6IFBvaW50LmVxdWFscyhhbmNob3IsIHJhbmdlLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKGZvY3VzLCByYW5nZS5mb2N1cykgPyByYW5nZSA6IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KHBvaW50LCB2YWx1ZSkge1xuICBpZiAoIXBvaW50IHx8ICF2YWx1ZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbmV3UGF0aCA9IFtdO1xuICBsZXQgbmV3T2Zmc2V0ID0gcG9pbnQub2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGJsb2NrS2V5ID0gdHlwZW9mIHBvaW50LnBhdGhbMF0gPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBwb2ludC5wYXRoWzBdICYmIHBvaW50LnBhdGhbMF0uX2tleSwgY2hpbGRLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFsyXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMl0gJiYgcG9pbnQucGF0aFsyXS5fa2V5LCBibG9jayA9IHZhbHVlLmZpbmQoKGJsaykgPT4gYmxrLl9rZXkgPT09IGJsb2NrS2V5KTtcbiAgaWYgKGJsb2NrKVxuICAgIG5ld1BhdGgucHVzaCh7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSk7XG4gIGVsc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGJsb2NrICYmIHBvaW50LnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIikge1xuICAgIGlmICghYmxvY2suY2hpbGRyZW4gfHwgQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgJiYgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY2hpbGQgPSBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5maW5kKChjbGQpID0+IGNsZC5fa2V5ID09PSBjaGlsZEtleSk7XG4gICAgaWYgKGNoaWxkKVxuICAgICAgbmV3UGF0aC5wdXNoKFwiY2hpbGRyZW5cIiksIG5ld1BhdGgucHVzaCh7XG4gICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgIH0pLCBuZXdPZmZzZXQgPSBjaGlsZC50ZXh0ICYmIGNoaWxkLnRleHQubGVuZ3RoID49IHBvaW50Lm9mZnNldCA/IHBvaW50Lm9mZnNldCA6IGNoaWxkLnRleHQgJiYgY2hpbGQudGV4dC5sZW5ndGggfHwgMDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgb2Zmc2V0OiBuZXdPZmZzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24sIHZhbHVlKSB7XG4gIGlmICghc2VsZWN0aW9uIHx8ICF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBuZXdBbmNob3IgPSBudWxsLCBuZXdGb2N1cyA9IG51bGw7XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgcmV0dXJuIGFuY2hvciAmJiB2YWx1ZS5maW5kKChibGspID0+IGlzRXF1YWwoe1xuICAgIF9rZXk6IGJsay5fa2V5XG4gIH0sIGFuY2hvci5wYXRoWzBdKSkgJiYgKG5ld0FuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGFuY2hvciwgdmFsdWUpKSwgZm9jdXMgJiYgdmFsdWUuZmluZCgoYmxrKSA9PiBpc0VxdWFsKHtcbiAgICBfa2V5OiBibGsuX2tleVxuICB9LCBmb2N1cy5wYXRoWzBdKSkgJiYgKG5ld0ZvY3VzID0gbm9ybWFsaXplUG9pbnQoZm9jdXMsIHZhbHVlKSksIG5ld0FuY2hvciAmJiBuZXdGb2N1cyA/IHtcbiAgICBhbmNob3I6IG5ld0FuY2hvcixcbiAgICBmb2N1czogbmV3Rm9jdXMsXG4gICAgYmFja3dhcmQ6IHNlbGVjdGlvbi5iYWNrd2FyZFxuICB9IDogbnVsbDtcbn1cbmNvbnN0IFZPSURfQ0hJTERfS0VZID0gXCJ2b2lkLWNoaWxkXCI7XG5mdW5jdGlvbiBrZWVwT2JqZWN0RXF1YWxpdHkob2JqZWN0LCBrZXlNYXApIHtcbiAgY29uc3QgdmFsdWUgPSBrZXlNYXBbb2JqZWN0Ll9rZXldO1xuICByZXR1cm4gdmFsdWUgJiYgaXNFcXVhbChvYmplY3QsIHZhbHVlKSA/IHZhbHVlIDogKGtleU1hcFtvYmplY3QuX2tleV0gPSBvYmplY3QsIG9iamVjdCk7XG59XG5mdW5jdGlvbiB0b1NsYXRlVmFsdWUodmFsdWUsIHtcbiAgc2NoZW1hVHlwZXNcbn0sIGtleU1hcCA9IHt9KSB7XG4gIHJldHVybiB2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgoYmxvY2spID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBfdHlwZSxcbiAgICAgIF9rZXksXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IGJsb2NrLCB2b2lkQ2hpbGRyZW4gPSBbe1xuICAgICAgX2tleTogVk9JRF9DSElMRF9LRVksXG4gICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICB0ZXh0OiBcIlwiLFxuICAgICAgbWFya3M6IFtdXG4gICAgfV07XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibG9jaztcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBoYXNNaXNzaW5nU3R5bGUgPSB0eXBlb2YgdGV4dEJsb2NrLnN0eWxlID4gXCJ1XCIsIGhhc01pc3NpbmdNYXJrRGVmcyA9IHR5cGVvZiB0ZXh0QmxvY2subWFya0RlZnMgPiBcInVcIiwgaGFzTWlzc2luZ0NoaWxkcmVuID0gdHlwZW9mIHRleHRCbG9jay5jaGlsZHJlbiA+IFwidVwiLCBjaGlsZHJlbiA9ICh0ZXh0QmxvY2suY2hpbGRyZW4gfHwgW10pLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIF90eXBlOiBjVHlwZSxcbiAgICAgICAgICBfa2V5OiBjS2V5LFxuICAgICAgICAgIC4uLmNSZXN0XG4gICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIGNUeXBlICE9PSBcInNwYW5cIiA/IChoYXNJbmxpbmVzID0gITAsIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICAgICAgX3R5cGU6IGNUeXBlLFxuICAgICAgICAgIF9rZXk6IGNLZXksXG4gICAgICAgICAgY2hpbGRyZW46IHZvaWRDaGlsZHJlbixcbiAgICAgICAgICB2YWx1ZTogY1Jlc3QsXG4gICAgICAgICAgX19pbmxpbmU6ICEwXG4gICAgICAgIH0sIGtleU1hcCkpIDogY2hpbGQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhaGFzTWlzc2luZ1N0eWxlICYmICFoYXNNaXNzaW5nTWFya0RlZnMgJiYgIWhhc01pc3NpbmdDaGlsZHJlbiAmJiAhaGFzSW5saW5lcyAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSA/IGJsb2NrIDogKGhhc01pc3NpbmdTdHlsZSAmJiAocmVzdC5zdHlsZSA9IHNjaGVtYVR5cGVzLnN0eWxlc1swXS52YWx1ZSksIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICAgIF90eXBlLFxuICAgICAgICBfa2V5LFxuICAgICAgICAuLi5yZXN0LFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSwga2V5TWFwKSk7XG4gICAgfVxuICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgX3R5cGUsXG4gICAgICBfa2V5LFxuICAgICAgY2hpbGRyZW46IHZvaWRDaGlsZHJlbixcbiAgICAgIHZhbHVlOiByZXN0XG4gICAgfSwga2V5TWFwKTtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIGZyb21TbGF0ZVZhbHVlKHZhbHVlLCB0ZXh0QmxvY2tUeXBlLCBrZXlNYXAgPSB7fSkge1xuICByZXR1cm4gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF9rZXksXG4gICAgICBfdHlwZVxuICAgIH0gPSBibG9jaztcbiAgICBpZiAoIV9rZXkgfHwgIV90eXBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgYmxvY2tcIik7XG4gICAgaWYgKF90eXBlID09PSB0ZXh0QmxvY2tUeXBlICYmIFwiY2hpbGRyZW5cIiBpbiBibG9jayAmJiBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBfa2V5KSB7XG4gICAgICBsZXQgaGFzSW5saW5lcyA9ICExO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBfdHlwZTogX2NUeXBlXG4gICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBjaGlsZCAmJiBfY1R5cGUgIT09IFwic3BhblwiKSB7XG4gICAgICAgICAgaGFzSW5saW5lcyA9ICEwO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICAgICAgX2tleTogayxcbiAgICAgICAgICAgIF90eXBlOiB0LFxuICAgICAgICAgICAgX19pbmxpbmU6IF9pLFxuICAgICAgICAgICAgY2hpbGRyZW46IF9jLFxuICAgICAgICAgICAgLi4ucmVzdFxuICAgICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgICByZXR1cm4ga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAuLi52LFxuICAgICAgICAgICAgX2tleTogayxcbiAgICAgICAgICAgIF90eXBlOiB0XG4gICAgICAgICAgfSwga2V5TWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoYXNJbmxpbmVzID8ga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBfa2V5LFxuICAgICAgICBfdHlwZVxuICAgICAgfSwga2V5TWFwKSA6IGJsb2NrO1xuICAgIH1cbiAgICBjb25zdCBibG9ja1ZhbHVlID0gXCJ2YWx1ZVwiIGluIGJsb2NrICYmIGJsb2NrLnZhbHVlO1xuICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgX2tleSxcbiAgICAgIF90eXBlLFxuICAgICAgLi4udHlwZW9mIGJsb2NrVmFsdWUgPT0gXCJvYmplY3RcIiA/IGJsb2NrVmFsdWUgOiB7fVxuICAgIH0sIGtleU1hcCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNFcXVhbFRvRW1wdHlFZGl0b3IoY2hpbGRyZW4sIHNjaGVtYVR5cGVzKSB7XG4gIHJldHVybiBjaGlsZHJlbiA9PT0gdm9pZCAwIHx8IGNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZHJlblswXSkgJiYgY2hpbGRyZW5bMF0uX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUgJiYgXCJzdHlsZVwiIGluIGNoaWxkcmVuWzBdICYmIGNoaWxkcmVuWzBdLnN0eWxlID09PSBzY2hlbWFUeXBlcy5zdHlsZXNbMF0udmFsdWUgJiYgIShcImxpc3RJdGVtXCIgaW4gY2hpbGRyZW5bMF0pICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW5bMF0uY2hpbGRyZW4pICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBUZXh0LmlzVGV4dChjaGlsZHJlblswXS5jaGlsZHJlblswXSkgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uX3R5cGUgPT09IFwic3BhblwiICYmICFjaGlsZHJlblswXS5jaGlsZHJlblswXS5tYXJrcz8uam9pbihcIlwiKSAmJiBjaGlsZHJlblswXS5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiO1xufVxuY29uc3QgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19QUk9DRVNTSU5HX0xPQ0FMX0NIQU5HRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBEZWZhdWx0T2JqZWN0ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0ICQgPSBjKDQpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzLnZhbHVlID8gKHQwID0gSlNPTi5zdHJpbmdpZnkocHJvcHMudmFsdWUsIG51bGwsIDIpLCAkWzBdID0gcHJvcHMudmFsdWUsICRbMV0gPSB0MCkgOiB0MCA9ICRbMV07XG4gIGxldCB0MTtcbiAgcmV0dXJuICRbMl0gIT09IHQwID8gKHQxID0gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwicHJlXCIsIHsgY2hpbGRyZW46IHQwIH0pIH0pLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiB0MSA9ICRbM10sIHQxO1xufTtcbkRlZmF1bHRPYmplY3QuZGlzcGxheU5hbWUgPSBcIkRlZmF1bHRPYmplY3RcIjtcbmNvbnN0IERlZmF1bHRCbG9ja09iamVjdCA9IHN0eWxlZC5kaXZgXG4gIHVzZXItc2VsZWN0OiBub25lO1xuICBib3JkZXI6ICR7KHByb3BzKSA9PiBwcm9wcy5zZWxlY3RlZCA/IFwiMXB4IHNvbGlkIGJsdWVcIiA6IFwiMXB4IHNvbGlkIHRyYW5zcGFyZW50XCJ9O1xuYDtcbnN0eWxlZC5zcGFuYFxuICBiYWNrZ3JvdW5kOiAjOTk5O1xuICBib3JkZXI6ICR7KHByb3BzKSA9PiBwcm9wcy5zZWxlY3RlZCA/IFwiMXB4IHNvbGlkIGJsdWVcIiA6IFwiMXB4IHNvbGlkIHRyYW5zcGFyZW50XCJ9O1xuYDtcbmNvbnN0IERlZmF1bHRMaXN0SXRlbSA9IHN0eWxlZC5kaXZgXG4gICYucHQtbGlzdC1pdGVtIHtcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuXG4gICAgLyogSW1wb3J0YW50ICd0cmFuc2Zvcm0nIGluIG9yZGVyIHRvIGZvcmNlIHJlZnJlc2ggdGhlIDo6YmVmb3JlIGFuZCA6OmFmdGVyIHJ1bGVzXG4gICAgICBpbiBXZWJraXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTk0NzYyOC84MzE0ODBcbiAgICAqL1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICBtYXJnaW4tbGVmdDogJHsocHJvcHMpID0+IGdldExlZnRQb3NpdGlvbkZvckxpc3RMZXZlbChwcm9wcy5saXN0TGV2ZWwpfTtcbiAgfVxuICAmLnB0LWxpc3QtaXRlbSA+IC5wdC1saXN0LWl0ZW0taW5uZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgJjpiZWZvcmUge1xuICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICB9XG4gIH1cbiAgJi5wdC1saXN0LWl0ZW0tYnVsbGV0ID4gLnB0LWxpc3QtaXRlbS1pbm5lcjpiZWZvcmUge1xuICAgICAgY29udGVudDogJyR7KHByb3BzKSA9PiBnZXRDb250ZW50Rm9yTGlzdExldmVsQW5kU3R5bGUocHJvcHMubGlzdExldmVsLCBwcm9wcy5saXN0U3R5bGUpfSc7XG4gICAgICBmb250LXNpemU6IDAuNDM3NXJlbTsgLyogN3B4ICovXG4gICAgICBsaW5lLWhlaWdodDogMS41cmVtOyAvKiBTYW1lIGFzIGJvZHkgdGV4dCAqL1xuICAgICAgLyogT3B0aWNhbCBhbGlnbm1lbnQgKi9cbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gIH1cbiAgJi5wdC1saXN0LWl0ZW0tYnVsbGV0ID4gLnB0LWxpc3QtaXRlbS1pbm5lciB7XG4gICAgJjpiZWZvcmUge1xuICAgICAgbWluLXdpZHRoOiAxLjVyZW07IC8qIE1ha2Ugc3VyZSBzcGFjZSBiZXR3ZWVuIGJ1bGxldCBhbmQgdGV4dCBuZXZlciBzaHJpbmtzICovXG4gICAgfVxuICB9XG4gICYucHQtbGlzdC1pdGVtLW51bWJlciB7XG4gICAgY291bnRlci1pbmNyZW1lbnQ6ICR7KHByb3BzKSA9PiBnZXRDb3VudGVySW5jcmVtZW50Rm9yTGlzdExldmVsKHByb3BzLmxpc3RMZXZlbCl9O1xuICAgIGNvdW50ZXItcmVzZXQ6ICR7KHByb3BzKSA9PiBnZXRDb3VudGVyUmVzZXRGb3JMaXN0TGV2ZWwocHJvcHMubGlzdExldmVsKX07XG4gIH1cbiAgJiArIDpub3QoLnB0LWxpc3QtaXRlbS1udW1iZXIpIHtcbiAgICBjb3VudGVyLXJlc2V0OiBsaXN0SXRlbU51bWJlcjtcbiAgfVxuICAmLnB0LWxpc3QtaXRlbS1udW1iZXIgPiAucHQtbGlzdC1pdGVtLWlubmVyOmJlZm9yZSB7XG4gICAgY29udGVudDogJHsocHJvcHMpID0+IGdldENvdW50ZXJDb250ZW50Rm9yTGlzdExldmVsKHByb3BzLmxpc3RMZXZlbCl9O1xuICAgIG1pbi13aWR0aDogMS41cmVtOyAvKiBNYWtlIHN1cmUgc3BhY2UgYmV0d2VlbiBudW1iZXIgYW5kIHRleHQgbmV2ZXIgc2hyaW5rcyAqL1xuICAgIC8qIE9wdGljYWwgYWxpZ25tZW50ICovXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHRvcDogMXB4O1xuICB9XG5gLCBEZWZhdWx0TGlzdEl0ZW1Jbm5lciA9IHN0eWxlZC5kaXZgYDtcbmZ1bmN0aW9uIGdldExlZnRQb3NpdGlvbkZvckxpc3RMZXZlbChsZXZlbCkge1xuICBzd2l0Y2ggKE51bWJlcihsZXZlbCkpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gXCIxLjVlbVwiO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBcIjNlbVwiO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBcIjQuNWVtXCI7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFwiNmVtXCI7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIFwiNy41ZW1cIjtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gXCI5ZW1cIjtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gXCIxMC41ZW1cIjtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gXCIxMmVtXCI7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIFwiMTMuNWVtXCI7XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiBcIjE1ZW1cIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiMGVtXCI7XG4gIH1cbn1cbmNvbnN0IGJ1bGxldHMgPSBbXCJcXHUyNUNGXCIsIFwiXFx1MjVDQlwiLCBcIlxcdTI1QTBcIl07XG5mdW5jdGlvbiBnZXRDb250ZW50Rm9yTGlzdExldmVsQW5kU3R5bGUobGV2ZWwsIHN0eWxlKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRMZXZlbCA9IChsZXZlbCAtIDEpICUgMztcbiAgcmV0dXJuIHN0eWxlID09PSBcImJ1bGxldFwiID8gYnVsbGV0c1tub3JtYWxpemVkTGV2ZWxdIDogXCIqXCI7XG59XG5mdW5jdGlvbiBnZXRDb3VudGVySW5jcmVtZW50Rm9yTGlzdExldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlclwiO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtQWxwaGFcIjtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuXCI7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0XCI7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1MZXR0ZXJOZXh0XCI7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1Sb21hbk5leHRcIjtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHROZXh0XCI7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1BbHBoYU5leHROZXh0XCI7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1Sb21hbk5leHROZXh0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHROZXh0XCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvdW50ZXJSZXNldEZvckxpc3RMZXZlbChsZXZlbCkge1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1BbHBoYVwiO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5cIjtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHRcIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUxldHRlck5leHRcIjtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuTmV4dFwiO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHRcIjtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUFscGhhTmV4dE5leHRcIjtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuTmV4dE5leHRcIjtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHROZXh0TmV4dFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHROZXh0TmV4dFwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb3VudGVyQ29udGVudEZvckxpc3RMZXZlbChsZXZlbCkge1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbU51bWJlcikgJy4gJ1wiO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1BbHBoYSwgbG93ZXItYWxwaGEpICcuICdcIjtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtUm9tYW4sIGxvd2VyLXJvbWFuKSAnLiAnXCI7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbU51bWJlck5leHQpICcuICdcIjtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtTGV0dGVyTmV4dCwgbG93ZXItYWxwaGEpICcuICdcIjtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtUm9tYW5OZXh0LCBsb3dlci1yb21hbikgJy4gJ1wiO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1OdW1iZXJOZXh0TmV4dCkgJy4gJ1wiO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1BbHBoYU5leHROZXh0LCBsb3dlci1hbHBoYSkgJy4gJ1wiO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1Sb21hbk5leHROZXh0LCBsb3dlci1yb21hbikgJy4gJ1wiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtTnVtYmVyTmV4dE5leHROZXh0KSAnLiAnXCI7XG4gIH1cbn1cbmNvbnN0IGRlYnVnJGwgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50czpEcmFnZ2FibGVCbG9ja1wiKSwgRHJhZ2dhYmxlQmxvY2sgPSAodDApID0+IHtcbiAgY29uc3QgJCA9IGMoNTEpLCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudCxcbiAgICByZWFkT25seSxcbiAgICBibG9ja1JlZlxuICB9ID0gdDAsIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCksIGRyYWdHaG9zdFJlZiA9IHVzZVJlZigpLCBbaXNEcmFnT3Zlciwgc2V0SXNEcmFnT3Zlcl0gPSB1c2VTdGF0ZSghMSk7XG4gIGxldCB0MSwgdDI7XG4gICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBlbGVtZW50ID8gKHQyID0gRWRpdG9yLmlzVm9pZChlZGl0b3IsIGVsZW1lbnQpLCAkWzBdID0gZWRpdG9yLCAkWzFdID0gZWxlbWVudCwgJFsyXSA9IHQyKSA6IHQyID0gJFsyXSwgdDEgPSB0MjtcbiAgY29uc3QgaXNWb2lkID0gdDE7XG4gIGxldCB0MywgdDQ7XG4gICRbM10gIT09IGVkaXRvciB8fCAkWzRdICE9PSBlbGVtZW50ID8gKHQ0ID0gRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgZWxlbWVudCksICRbM10gPSBlZGl0b3IsICRbNF0gPSBlbGVtZW50LCAkWzVdID0gdDQpIDogdDQgPSAkWzVdLCB0MyA9IHQ0O1xuICBjb25zdCBpc0lubGluZSA9IHQzLCBbYmxvY2tFbGVtZW50LCBzZXRCbG9ja0VsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGxldCB0NSwgdDY7XG4gICRbNl0gIT09IGJsb2NrUmVmIHx8ICRbN10gIT09IGVkaXRvciB8fCAkWzhdICE9PSBlbGVtZW50ID8gKHQ1ID0gKCkgPT4gc2V0QmxvY2tFbGVtZW50KGJsb2NrUmVmID8gYmxvY2tSZWYuY3VycmVudCA6IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVsZW1lbnQpKSwgdDYgPSBbZWRpdG9yLCBlbGVtZW50LCBibG9ja1JlZl0sICRbNl0gPSBibG9ja1JlZiwgJFs3XSA9IGVkaXRvciwgJFs4XSA9IGVsZW1lbnQsICRbOV0gPSB0NSwgJFsxMF0gPSB0NikgOiAodDUgPSAkWzldLCB0NiA9ICRbMTBdKSwgdXNlRWZmZWN0KHQ1LCB0Nik7XG4gIGxldCB0NztcbiAgJFsxMV0gIT09IGVkaXRvciB8fCAkWzEyXSAhPT0gYmxvY2tFbGVtZW50IHx8ICRbMTNdICE9PSBlbGVtZW50ID8gKHQ3ID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgaXNNeURyYWdPdmVyID0gSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICBpZiAoIWlzTXlEcmFnT3ZlciB8fCAhYmxvY2tFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJtb3ZlXCIsIElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULnNldChlZGl0b3IsIGVsZW1lbnQpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gYmxvY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvZmZzZXQgPSBlbGVtZW50UmVjdC50b3AsIGhlaWdodCA9IGVsZW1lbnRSZWN0LmhlaWdodCwgWSA9IGV2ZW50LnBhZ2VZLCBsb2MgPSBNYXRoLmFicyhvZmZzZXQgLSBZKTtcbiAgICBpZiAoZWxlbWVudCA9PT0gZWRpdG9yLmNoaWxkcmVuWzBdIHx8IChsb2MgPCBoZWlnaHQgLyAyID8gSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLnNldChlZGl0b3IsIFwidG9wXCIpIDogSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLnNldChlZGl0b3IsIFwiYm90dG9tXCIpKSwgaXNNeURyYWdPdmVyID09PSBlbGVtZW50KSB7XG4gICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibm9uZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRJc0RyYWdPdmVyKCEwKTtcbiAgfSwgJFsxMV0gPSBlZGl0b3IsICRbMTJdID0gYmxvY2tFbGVtZW50LCAkWzEzXSA9IGVsZW1lbnQsICRbMTRdID0gdDcpIDogdDcgPSAkWzE0XTtcbiAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSB0NztcbiAgbGV0IHQ4O1xuICAkWzE1XSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDggPSAoKSA9PiB7XG4gICAgc2V0SXNEcmFnT3ZlcighMSk7XG4gIH0sICRbMTVdID0gdDgpIDogdDggPSAkWzE1XTtcbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gdDg7XG4gIGxldCB0OTtcbiAgJFsxNl0gIT09IGVkaXRvciB8fCAkWzE3XSAhPT0gZWxlbWVudCA/ICh0OSA9IChldmVudF8wKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0QmxvY2sgPSBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5nZXQoZWRpdG9yKTtcbiAgICBpZiAodGFyZ2V0QmxvY2spIHtcbiAgICAgIElTX0RSQUdHSU5HLnNldChlZGl0b3IsICExKSwgZXZlbnRfMC5wcmV2ZW50RGVmYXVsdCgpLCBldmVudF8wLnN0b3BQcm9wYWdhdGlvbigpLCBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5kZWxldGUoZWRpdG9yKSwgZHJhZ0dob3N0UmVmLmN1cnJlbnQgJiYgKGRlYnVnJGwoXCJSZW1vdmluZyBkcmFnIGdob3N0XCIpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRyYWdHaG9zdFJlZi5jdXJyZW50KSk7XG4gICAgICBjb25zdCBkcmFnUG9zaXRpb24gPSBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uZ2V0KGVkaXRvcik7XG4gICAgICBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICBsZXQgdGFyZ2V0UGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgdGFyZ2V0QmxvY2spO1xuICAgICAgY29uc3QgbXlQYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBlbGVtZW50KSwgaXNCZWZvcmUgPSBQYXRoLmlzQmVmb3JlKG15UGF0aCwgdGFyZ2V0UGF0aCk7XG4gICAgICBpZiAoZHJhZ1Bvc2l0aW9uID09PSBcImJvdHRvbVwiICYmICFpc0JlZm9yZSkge1xuICAgICAgICBpZiAodGFyZ2V0UGF0aFswXSA+PSBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGRlYnVnJGwoXCJ0YXJnZXQgaXMgYWxyZWFkeSBhdCB0aGUgYm90dG9tLCBub3QgbW92aW5nXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGggPSB0YXJnZXRQYXRoO1xuICAgICAgICB0YXJnZXRQYXRoID0gUGF0aC5uZXh0KHRhcmdldFBhdGgpLCBkZWJ1ZyRsKGBBZGp1c3RpbmcgdGFyZ2V0UGF0aCBmcm9tICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxQYXRoKX0gdG8gJHtKU09OLnN0cmluZ2lmeSh0YXJnZXRQYXRoKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmFnUG9zaXRpb24gPT09IFwidG9wXCIgJiYgaXNCZWZvcmUgJiYgdGFyZ2V0UGF0aFswXSAhPT0gZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRoXzAgPSB0YXJnZXRQYXRoO1xuICAgICAgICB0YXJnZXRQYXRoID0gUGF0aC5wcmV2aW91cyh0YXJnZXRQYXRoKSwgZGVidWckbChgQWRqdXN0aW5nIHRhcmdldFBhdGggZnJvbSAke0pTT04uc3RyaW5naWZ5KG9yaWdpbmFsUGF0aF8wKX0gdG8gJHtKU09OLnN0cmluZ2lmeSh0YXJnZXRQYXRoKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChQYXRoLmVxdWFscyh0YXJnZXRQYXRoLCBteVBhdGgpKSB7XG4gICAgICAgIGV2ZW50XzAucHJldmVudERlZmF1bHQoKSwgZGVidWckbChcInRhcmdldFBhdGggYW5kIG15UGF0aCBpcyB0aGUgc2FtZSwgbm90IG1vdmluZ1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVidWckbChgTW92aW5nIGVsZW1lbnQgJHtlbGVtZW50Ll9rZXl9IGZyb20gcGF0aCAke0pTT04uc3RyaW5naWZ5KG15UGF0aCl9IHRvICR7SlNPTi5zdHJpbmdpZnkodGFyZ2V0UGF0aCl9ICgke2RyYWdQb3NpdGlvbn0pYCksIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogbXlQYXRoLFxuICAgICAgICB0bzogdGFyZ2V0UGF0aFxuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWJ1ZyRsKFwiTm8gdGFyZ2V0IGVsZW1lbnQsIG5vdCBkb2luZyBhbnl0aGluZ1wiKTtcbiAgfSwgJFsxNl0gPSBlZGl0b3IsICRbMTddID0gZWxlbWVudCwgJFsxOF0gPSB0OSkgOiB0OSA9ICRbMThdO1xuICBjb25zdCBoYW5kbGVEcmFnRW5kID0gdDk7XG4gIGxldCB0MTA7XG4gICRbMTldICE9PSBlZGl0b3IgfHwgJFsyMF0gIT09IGVsZW1lbnQgPyAodDEwID0gKGV2ZW50XzEpID0+IHtcbiAgICBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmdldChlZGl0b3IpICYmIChkZWJ1ZyRsKFwiT24gZHJvcCAocHJldmVudGVkKVwiLCBlbGVtZW50KSwgZXZlbnRfMS5wcmV2ZW50RGVmYXVsdCgpLCBldmVudF8xLnN0b3BQcm9wYWdhdGlvbigpLCBzZXRJc0RyYWdPdmVyKCExKSk7XG4gIH0sICRbMTldID0gZWRpdG9yLCAkWzIwXSA9IGVsZW1lbnQsICRbMjFdID0gdDEwKSA6IHQxMCA9ICRbMjFdO1xuICBjb25zdCBoYW5kbGVEcm9wID0gdDEwO1xuICBsZXQgdDExO1xuICAkWzIyXSAhPT0gaXNWb2lkIHx8ICRbMjNdICE9PSBlZGl0b3IgfHwgJFsyNF0gIT09IGVsZW1lbnQgPyAodDExID0gKGV2ZW50XzIpID0+IHtcbiAgICBpZiAoIWlzVm9pZCkge1xuICAgICAgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgSVNfRFJBR0dJTkcuc2V0KGVkaXRvciwgITApLCBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULnNldChlZGl0b3IsIGVsZW1lbnQpLCBldmVudF8yLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50XzIudGFyZ2V0O1xuICAgIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmICh0YXJnZXQuc3R5bGUub3BhY2l0eSA9IFwiMVwiKTtcbiAgfSwgJFsyMl0gPSBpc1ZvaWQsICRbMjNdID0gZWRpdG9yLCAkWzI0XSA9IGVsZW1lbnQsICRbMjVdID0gdDExKSA6IHQxMSA9ICRbMjVdO1xuICBjb25zdCBoYW5kbGVEcmFnID0gdDExO1xuICBsZXQgdDEyO1xuICAkWzI2XSAhPT0gaXNWb2lkIHx8ICRbMjddICE9PSBpc0lubGluZSB8fCAkWzI4XSAhPT0gZWRpdG9yIHx8ICRbMjldICE9PSBibG9ja0VsZW1lbnQgfHwgJFszMF0gIT09IGhhbmRsZURyYWcgPyAodDEyID0gKGV2ZW50XzMpID0+IHtcbiAgICBpZiAoIWlzVm9pZCB8fCBpc0lubGluZSkge1xuICAgICAgZGVidWckbChcIk5vdCBkcmFnZ2luZyBibG9ja1wiKSwgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5kZWxldGUoZWRpdG9yKSwgSVNfRFJBR0dJTkcuc2V0KGVkaXRvciwgITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVidWckbChcIkRyYWcgc3RhcnRcIiksIElTX0RSQUdHSU5HLnNldChlZGl0b3IsICEwKSwgZXZlbnRfMy5kYXRhVHJhbnNmZXIgJiYgKGV2ZW50XzMuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wb3J0YWJsZS10ZXh0XCIsIFwic29tZXRoaW5nXCIpLCBldmVudF8zLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJtb3ZlXCIpLCBibG9ja0VsZW1lbnQgJiYgYmxvY2tFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIGxldCBkcmFnR2hvc3QgPSBibG9ja0VsZW1lbnQuY2xvbmVOb2RlKCEwKTtcbiAgICAgIGNvbnN0IGN1c3RvbUdob3N0ID0gZHJhZ0dob3N0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wdC1kcmFnLWdob3N0LWVsZW1lbnRdXCIpO1xuICAgICAgaWYgKGN1c3RvbUdob3N0ICYmIChkcmFnR2hvc3QgPSBjdXN0b21HaG9zdCksIGRyYWdHaG9zdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRyYWdnZWRcIiwgXCJcIiksIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgZHJhZ0dob3N0UmVmLmN1cnJlbnQgPSBkcmFnR2hvc3QsIGRyYWdHaG9zdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgZHJhZ0dob3N0LnN0eWxlLmxlZnQgPSBcIi05OTk5OXB4XCIsIGRyYWdHaG9zdC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnR2hvc3QpO1xuICAgICAgICBjb25zdCByZWN0ID0gYmxvY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB4ID0gZXZlbnRfMy5jbGllbnRYIC0gcmVjdC5sZWZ0LCB5ID0gZXZlbnRfMy5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICAgIGRyYWdHaG9zdC5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgLCBkcmFnR2hvc3Quc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgLCBldmVudF8zLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoZHJhZ0dob3N0LCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRHJhZyhldmVudF8zKTtcbiAgfSwgJFsyNl0gPSBpc1ZvaWQsICRbMjddID0gaXNJbmxpbmUsICRbMjhdID0gZWRpdG9yLCAkWzI5XSA9IGJsb2NrRWxlbWVudCwgJFszMF0gPSBoYW5kbGVEcmFnLCAkWzMxXSA9IHQxMikgOiB0MTIgPSAkWzMxXTtcbiAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gdDEyO1xuICBsZXQgdDEzO1xuICAkWzMyXSAhPT0gaXNEcmFnT3ZlciB8fCAkWzMzXSAhPT0gZWRpdG9yID8gKHQxMyA9IGlzRHJhZ092ZXIgJiYgZWRpdG9yLmNoaWxkcmVuWzBdID09PSBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5nZXQoZWRpdG9yKSwgJFszMl0gPSBpc0RyYWdPdmVyLCAkWzMzXSA9IGVkaXRvciwgJFszNF0gPSB0MTMpIDogdDEzID0gJFszNF07XG4gIGNvbnN0IGlzRHJhZ2dpbmdPdmVyRmlyc3RCbG9jayA9IHQxMztcbiAgbGV0IHQxNDtcbiAgJFszNV0gIT09IGlzRHJhZ092ZXIgfHwgJFszNl0gIT09IGVkaXRvciA/ICh0MTQgPSBpc0RyYWdPdmVyICYmIGVkaXRvci5jaGlsZHJlbltlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPT09IElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULmdldChlZGl0b3IpLCAkWzM1XSA9IGlzRHJhZ092ZXIsICRbMzZdID0gZWRpdG9yLCAkWzM3XSA9IHQxNCkgOiB0MTQgPSAkWzM3XTtcbiAgY29uc3QgaXNEcmFnZ2luZ092ZXJMYXN0QmxvY2sgPSB0MTQsIGRyYWdQb3NpdGlvbl8wID0gSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLmdldChlZGl0b3IpLCBpc0RyYWdnaW5nT3ZlclRvcCA9IGlzRHJhZ2dpbmdPdmVyRmlyc3RCbG9jayB8fCBpc0RyYWdPdmVyICYmICFpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgJiYgIWlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrICYmIGRyYWdQb3NpdGlvbl8wID09PSBcInRvcFwiLCBpc0RyYWdnaW5nT3ZlckJvdHRvbSA9IGlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrIHx8IGlzRHJhZ092ZXIgJiYgIWlzRHJhZ2dpbmdPdmVyRmlyc3RCbG9jayAmJiAhaXNEcmFnZ2luZ092ZXJMYXN0QmxvY2sgJiYgZHJhZ1Bvc2l0aW9uXzAgPT09IFwiYm90dG9tXCI7XG4gIGxldCB0MTUsIHQxNjtcbiAgJFszOF0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQxNiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicHQtZHJvcC1pbmRpY2F0b3JcIiwgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IDEsXG4gICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBjdXJyZW50Q29sb3JcIixcbiAgICB6SW5kZXg6IDVcbiAgfSB9KSwgJFszOF0gPSB0MTYpIDogdDE2ID0gJFszOF0sIHQxNSA9IHQxNjtcbiAgY29uc3QgZHJvcEluZGljYXRvciA9IHQxNTtcbiAgaWYgKHJlYWRPbmx5KSB7XG4gICAgbGV0IHQxNzI7XG4gICAgcmV0dXJuICRbMzldICE9PSBjaGlsZHJlbiA/ICh0MTcyID0gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbiB9KSwgJFszOV0gPSBjaGlsZHJlbiwgJFs0MF0gPSB0MTcyKSA6IHQxNzIgPSAkWzQwXSwgdDE3MjtcbiAgfVxuICBjb25zdCB0MTcgPSBpc0RyYWdnaW5nT3ZlclRvcCAmJiBkcm9wSW5kaWNhdG9yLCB0MTggPSBpc0RyYWdnaW5nT3ZlckJvdHRvbSAmJiBkcm9wSW5kaWNhdG9yO1xuICBsZXQgdDE5O1xuICByZXR1cm4gJFs0MV0gIT09IGlzVm9pZCB8fCAkWzQyXSAhPT0gaGFuZGxlRHJhZ1N0YXJ0IHx8ICRbNDNdICE9PSBoYW5kbGVEcmFnIHx8ICRbNDRdICE9PSBoYW5kbGVEcmFnT3ZlciB8fCAkWzQ1XSAhPT0gaGFuZGxlRHJhZ0VuZCB8fCAkWzQ2XSAhPT0gaGFuZGxlRHJvcCB8fCAkWzQ3XSAhPT0gdDE3IHx8ICRbNDhdICE9PSBjaGlsZHJlbiB8fCAkWzQ5XSAhPT0gdDE4ID8gKHQxOSA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgZHJhZ2dhYmxlOiBpc1ZvaWQsIG9uRHJhZ1N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsIG9uRHJhZzogaGFuZGxlRHJhZywgb25EcmFnT3ZlcjogaGFuZGxlRHJhZ092ZXIsIG9uRHJhZ0xlYXZlOiBoYW5kbGVEcmFnTGVhdmUsIG9uRHJhZ0VuZDogaGFuZGxlRHJhZ0VuZCwgb25Ecm9wOiBoYW5kbGVEcm9wLCBjaGlsZHJlbjogW1xuICAgIHQxNyxcbiAgICBjaGlsZHJlbixcbiAgICB0MThcbiAgXSB9KSwgJFs0MV0gPSBpc1ZvaWQsICRbNDJdID0gaGFuZGxlRHJhZ1N0YXJ0LCAkWzQzXSA9IGhhbmRsZURyYWcsICRbNDRdID0gaGFuZGxlRHJhZ092ZXIsICRbNDVdID0gaGFuZGxlRHJhZ0VuZCwgJFs0Nl0gPSBoYW5kbGVEcm9wLCAkWzQ3XSA9IHQxNywgJFs0OF0gPSBjaGlsZHJlbiwgJFs0OV0gPSB0MTgsICRbNTBdID0gdDE5KSA6IHQxOSA9ICRbNTBdLCB0MTk7XG59O1xuRHJhZ2dhYmxlQmxvY2suZGlzcGxheU5hbWUgPSBcIkRyYWdnYWJsZUJsb2NrXCI7XG5kZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50czpFbGVtZW50XCIpO1xuY29uc3QgRU1QVFlfQU5OT1RBVElPTlMgPSBbXSwgaW5saW5lQmxvY2tTdHlsZSA9IHtcbiAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxufSwgRWxlbWVudCA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIGNoaWxkcmVuLFxuICBlbGVtZW50LFxuICBzY2hlbWFUeXBlcyxcbiAgcmVhZE9ubHksXG4gIHJlbmRlckJsb2NrLFxuICByZW5kZXJDaGlsZCxcbiAgcmVuZGVyTGlzdEl0ZW0sXG4gIHJlbmRlclN0eWxlLFxuICBzcGVsbENoZWNrXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCksIHNlbGVjdGVkID0gdXNlU2VsZWN0ZWQoKSwgYmxvY2tSZWYgPSB1c2VSZWYobnVsbCksIGlubGluZUJsb2NrT2JqZWN0UmVmID0gdXNlUmVmKG51bGwpLCBmb2N1c2VkID0gc2VsZWN0ZWQgJiYgZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSB8fCAhMSwgdmFsdWUgPSB1c2VNZW1vKCgpID0+IGZyb21TbGF0ZVZhbHVlKFtlbGVtZW50XSwgc2NoZW1hVHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpWzBdLCBbZWRpdG9yLCBlbGVtZW50LCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lXSk7XG4gIGxldCByZW5kZXJlZEJsb2NrID0gY2hpbGRyZW4sIGNsYXNzTmFtZTtcbiAgY29uc3QgYmxvY2tQYXRoID0gdXNlTWVtbygoKSA9PiBbe1xuICAgIF9rZXk6IGVsZW1lbnQuX2tleVxuICB9XSwgW2VsZW1lbnRdKTtcbiAgaWYgKHR5cGVvZiBlbGVtZW50Ll90eXBlICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudCB0byBoYXZlIGEgX3R5cGUgcHJvcGVydHlcIik7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudCB0byBoYXZlIGEgX2tleSBwcm9wZXJ0eVwiKTtcbiAgaWYgKGVkaXRvci5pc0lubGluZShlbGVtZW50KSkge1xuICAgIGNvbnN0IHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIGVsZW1lbnQpLCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoLCB7XG4gICAgICBkZXB0aDogMVxuICAgIH0pLCBzY2hlbWFUeXBlID0gc2NoZW1hVHlwZXMuaW5saW5lT2JqZWN0cy5maW5kKChfdHlwZSkgPT4gX3R5cGUubmFtZSA9PT0gZWxlbWVudC5fdHlwZSk7XG4gICAgaWYgKCFzY2hlbWFUeXBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgdHlwZSBmb3IgaW5saW5lIGJsb2NrIGVsZW1lbnRcIik7XG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spKSB7XG4gICAgICBjb25zdCBlbG1QYXRoID0gW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IGVsZW1lbnQuX2tleVxuICAgICAgfV07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgLi4uYXR0cmlidXRlcywgY2hpbGRyZW46IFtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7IGRyYWdnYWJsZTogIXJlYWRPbmx5LCBjbGFzc05hbWU6IFwicHQtaW5saW5lLW9iamVjdFwiLCBcImRhdGEtdGVzdGlkXCI6IFwicHQtaW5saW5lLW9iamVjdFwiLCByZWY6IGlubGluZUJsb2NrT2JqZWN0UmVmLCBzdHlsZTogaW5saW5lQmxvY2tTdHlsZSwgY29udGVudEVkaXRhYmxlOiAhMSwgY2hpbGRyZW46IFtcbiAgICAgICAgICByZW5kZXJDaGlsZCAmJiByZW5kZXJDaGlsZCh7XG4gICAgICAgICAgICBhbm5vdGF0aW9uczogRU1QVFlfQU5OT1RBVElPTlMsXG4gICAgICAgICAgICAvLyBUaGVzZSBpbmxpbmUgb2JqZWN0cyBjdXJyZW50bHkgZG9lc24ndCBzdXBwb3J0IGFubm90YXRpb25zLiBUaGlzIGlzIGEgbGltaXRhdGlvbiBvZiB0aGUgY3VycmVudCBQVCBzcGVjL21vZGVsLlxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdE9iamVjdCwgeyB2YWx1ZSB9KSxcbiAgICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGlubGluZUJsb2NrT2JqZWN0UmVmLFxuICAgICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICAgIHBhdGg6IGVsbVBhdGgsXG4gICAgICAgICAgICBzY2hlbWFUeXBlLFxuICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICB0eXBlOiBzY2hlbWFUeXBlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAhcmVuZGVyQ2hpbGQgJiYgLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0T2JqZWN0LCB7IHZhbHVlIH0pXG4gICAgICAgIF0gfSwgZWxlbWVudC5fa2V5KVxuICAgICAgXSB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgbm90IGZvdW5kIVwiKTtcbiAgfVxuICBpZiAoZWxlbWVudC5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSkge1xuICAgIGNsYXNzTmFtZSA9IFwicHQtYmxvY2sgcHQtdGV4dC1ibG9ja1wiO1xuICAgIGNvbnN0IGlzTGlzdEl0ZW0gPSBcImxpc3RJdGVtXCIgaW4gZWxlbWVudCwgc3R5bGUgPSBcInN0eWxlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnN0eWxlIHx8IFwibm9ybWFsXCI7XG4gICAgY2xhc3NOYW1lID0gYHB0LWJsb2NrIHB0LXRleHQtYmxvY2sgcHQtdGV4dC1ibG9jay1zdHlsZS0ke3N0eWxlfWA7XG4gICAgY29uc3QgYmxvY2tTdHlsZVR5cGUgPSBzY2hlbWFUeXBlcy5zdHlsZXMuZmluZCgoaXRlbSkgPT4gaXRlbS52YWx1ZSA9PT0gc3R5bGUpO1xuICAgIHJlbmRlclN0eWxlICYmIGJsb2NrU3R5bGVUeXBlICYmIChyZW5kZXJlZEJsb2NrID0gcmVuZGVyU3R5bGUoe1xuICAgICAgYmxvY2s6IGVsZW1lbnQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHZhbHVlOiBzdHlsZSxcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHNjaGVtYVR5cGU6IGJsb2NrU3R5bGVUeXBlLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWZcbiAgICB9KSk7XG4gICAgbGV0IGxldmVsO1xuICAgIGlmIChpc0xpc3RJdGVtICYmICh0eXBlb2YgZWxlbWVudC5sZXZlbCA9PSBcIm51bWJlclwiICYmIChsZXZlbCA9IGVsZW1lbnQubGV2ZWwpLCBjbGFzc05hbWUgKz0gYCBwdC1saXN0LWl0ZW0gcHQtbGlzdC1pdGVtLSR7ZWxlbWVudC5saXN0SXRlbX0gcHQtbGlzdC1pdGVtLWxldmVsLSR7bGV2ZWwgfHwgMX1gKSwgZWRpdG9yLmlzTGlzdEJsb2NrKHZhbHVlKSAmJiBpc0xpc3RJdGVtICYmIGVsZW1lbnQubGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gc2NoZW1hVHlwZXMubGlzdHMuZmluZCgoaXRlbV8wKSA9PiBpdGVtXzAudmFsdWUgPT09IGVsZW1lbnQubGlzdEl0ZW0pO1xuICAgICAgcmVuZGVyTGlzdEl0ZW0gJiYgbGlzdFR5cGUgPyByZW5kZXJlZEJsb2NrID0gcmVuZGVyTGlzdEl0ZW0oe1xuICAgICAgICBibG9jazogdmFsdWUsXG4gICAgICAgIGNoaWxkcmVuOiByZW5kZXJlZEJsb2NrLFxuICAgICAgICBmb2N1c2VkLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgdmFsdWU6IGVsZW1lbnQubGlzdEl0ZW0sXG4gICAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgICAgc2NoZW1hVHlwZTogbGlzdFR5cGUsXG4gICAgICAgIGxldmVsOiB2YWx1ZS5sZXZlbCB8fCAxLFxuICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZlxuICAgICAgfSkgOiByZW5kZXJlZEJsb2NrID0gLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0TGlzdEl0ZW0sIHsgbGlzdFN0eWxlOiB2YWx1ZS5saXN0SXRlbSB8fCBzY2hlbWFUeXBlcy5saXN0c1swXS52YWx1ZSwgbGlzdExldmVsOiB2YWx1ZS5sZXZlbCB8fCAxLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0TGlzdEl0ZW1Jbm5lciwgeyBjaGlsZHJlbjogcmVuZGVyZWRCbG9jayB9KSB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2ssXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBsZXZlbCxcbiAgICAgIGxpc3RJdGVtOiBpc0xpc3RJdGVtID8gZWxlbWVudC5saXN0SXRlbSA6IHZvaWQgMCxcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgc3R5bGUsXG4gICAgICBzY2hlbWFUeXBlOiBzY2hlbWFUeXBlcy5ibG9jayxcbiAgICAgIHZhbHVlXG4gICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVzLmJsb2NrO1xuICAgICAgfVxuICAgIH0pLCBwcm9wc09yRGVmYXVsdFJlbmRlcmVkID0gcmVuZGVyQmxvY2sgPyByZW5kZXJCbG9jayhyZW5kZXJQcm9wcykgOiBjaGlsZHJlbjtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IC4uLmF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgc3BlbGxDaGVjaywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRHJhZ2dhYmxlQmxvY2ssIHsgZWxlbWVudCwgcmVhZE9ubHksIGJsb2NrUmVmLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogYmxvY2tSZWYsIGNoaWxkcmVuOiBwcm9wc09yRGVmYXVsdFJlbmRlcmVkIH0pIH0pIH0sIGVsZW1lbnQuX2tleSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hVHlwZV8wID0gc2NoZW1hVHlwZXMuYmxvY2tPYmplY3RzLmZpbmQoKF90eXBlXzApID0+IF90eXBlXzAubmFtZSA9PT0gZWxlbWVudC5fdHlwZSk7XG4gIGlmICghc2NoZW1hVHlwZV8wKVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc2NoZW1hIHR5cGUgZm9yIGJsb2NrIGVsZW1lbnQgb2YgX3R5cGUgJHtlbGVtZW50Ll90eXBlfWApO1xuICBjbGFzc05hbWUgPSBcInB0LWJsb2NrIHB0LW9iamVjdC1ibG9ja1wiO1xuICBjb25zdCBibG9ja18wID0gZnJvbVNsYXRlVmFsdWUoW2VsZW1lbnRdLCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gIGxldCByZW5kZXJlZEJsb2NrRnJvbVByb3BzO1xuICBpZiAocmVuZGVyQmxvY2spIHtcbiAgICBjb25zdCBfcHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdE9iamVjdCwgeyB2YWx1ZSB9KSxcbiAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVfMCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgdmFsdWU6IGJsb2NrXzBcbiAgICB9LCBcInR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZV8wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlbmRlcmVkQmxvY2tGcm9tUHJvcHMgPSByZW5kZXJCbG9jayhfcHJvcHMpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IC4uLmF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgY2hpbGRyZW46IFtcbiAgICBjaGlsZHJlbixcbiAgICAvKiBAX19QVVJFX18gKi8ganN4cyhEcmFnZ2FibGVCbG9jaywgeyBlbGVtZW50LCByZWFkT25seSwgYmxvY2tSZWYsIGNoaWxkcmVuOiBbXG4gICAgICByZW5kZXJlZEJsb2NrRnJvbVByb3BzICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IGJsb2NrUmVmLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogcmVuZGVyZWRCbG9ja0Zyb21Qcm9wcyB9KSxcbiAgICAgICFyZW5kZXJlZEJsb2NrRnJvbVByb3BzICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdEJsb2NrT2JqZWN0LCB7IHNlbGVjdGVkLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0T2JqZWN0LCB7IHZhbHVlIH0pIH0pXG4gICAgXSB9KVxuICBdIH0sIGVsZW1lbnQuX2tleSk7XG59O1xuRWxlbWVudC5kaXNwbGF5TmFtZSA9IFwiRWxlbWVudFwiO1xuY29uc3QgUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCksIHVzZVBvcnRhYmxlVGV4dEVkaXRvciA9ICgpID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VQb3J0YWJsZVRleHRFZGl0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFBvcnRhYmxlVGV4dEVkaXRvcj4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIHJldHVybiBlZGl0b3I7XG59O1xuZnVuY3Rpb24gRGVmYXVsdEFubm90YXRpb24ocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNik7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gcHJvcHMuYW5ub3RhdGlvbiA/ICh0MCA9ICgpID0+IGFsZXJ0KEpTT04uc3RyaW5naWZ5KHByb3BzLmFubm90YXRpb24pKSwgJFswXSA9IHByb3BzLmFubm90YXRpb24sICRbMV0gPSB0MCkgOiB0MCA9ICRbMV07XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gdDA7XG4gIGxldCB0MTtcbiAgJFsyXSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDEgPSB7XG4gICAgY29sb3I6IFwiYmx1ZVwiXG4gIH0sICRbMl0gPSB0MSkgOiB0MSA9ICRbMl07XG4gIGxldCB0MjtcbiAgcmV0dXJuICRbM10gIT09IGhhbmRsZUNsaWNrIHx8ICRbNF0gIT09IHByb3BzLmNoaWxkcmVuID8gKHQyID0gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBzdHlsZTogdDEsIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLCBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSksICRbM10gPSBoYW5kbGVDbGljaywgJFs0XSA9IHByb3BzLmNoaWxkcmVuLCAkWzVdID0gdDIpIDogdDIgPSAkWzVdLCB0Mjtcbn1cbkRlZmF1bHRBbm5vdGF0aW9uLmRpc3BsYXlOYW1lID0gXCJEZWZhdWx0QW5ub3RhdGlvblwiO1xuZnVuY3Rpb24gZ2V0UG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXMocG9ydGFibGVUZXh0VHlwZSkge1xuICBpZiAoIXBvcnRhYmxlVGV4dFR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyICdwb3J0YWJsZXRleHRUeXBlJyBtaXNzaW5nIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGJsb2NrVHlwZSA9IHBvcnRhYmxlVGV4dFR5cGUub2Y/LmZpbmQoZmluZEJsb2NrVHlwZSk7XG4gIGlmICghYmxvY2tUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIHR5cGUgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgY2hpbGRyZW5GaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBcImNoaWxkcmVuXCIpO1xuICBpZiAoIWNoaWxkcmVuRmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGRyZW4gZmllbGQgZm9yIGJsb2NrIHR5cGUgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IG9mVHlwZSA9IGNoaWxkcmVuRmllbGQudHlwZS5vZjtcbiAgaWYgKCFvZlR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWQgdHlwZXMgZm9yIGJsb2NrIGNoaWxkcmVuIG5vdCBmb3VuZCBpbiBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3Qgc3BhblR5cGUgPSBvZlR5cGUuZmluZCgobWVtYmVyVHlwZSkgPT4gbWVtYmVyVHlwZS5uYW1lID09PSBcInNwYW5cIik7XG4gIGlmICghc3BhblR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3BhbiB0eXBlIG5vdCBmb3VuZCBpbiBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgaW5saW5lT2JqZWN0VHlwZXMgPSBvZlR5cGUuZmlsdGVyKChtZW1iZXJUeXBlKSA9PiBtZW1iZXJUeXBlLm5hbWUgIT09IFwic3BhblwiKSB8fCBbXSwgYmxvY2tPYmplY3RUeXBlcyA9IHBvcnRhYmxlVGV4dFR5cGUub2Y/LmZpbHRlcigoZmllbGQpID0+IGZpZWxkLm5hbWUgIT09IGJsb2NrVHlwZS5uYW1lKSB8fCBbXTtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZXM6IHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSksXG4gICAgZGVjb3JhdG9yczogcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSxcbiAgICBsaXN0czogcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSxcbiAgICBibG9jazogYmxvY2tUeXBlLFxuICAgIHNwYW46IHNwYW5UeXBlLFxuICAgIHBvcnRhYmxlVGV4dDogcG9ydGFibGVUZXh0VHlwZSxcbiAgICBpbmxpbmVPYmplY3RzOiBpbmxpbmVPYmplY3RUeXBlcyxcbiAgICBibG9ja09iamVjdHM6IGJsb2NrT2JqZWN0VHlwZXMsXG4gICAgYW5ub3RhdGlvbnM6IHNwYW5UeXBlLmFubm90YXRpb25zXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpIHtcbiAgY29uc3Qgc3R5bGVGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJzdHlsZVwiKTtcbiAgaWYgKCFzdHlsZUZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgZmllbGQgd2l0aCBuYW1lICdzdHlsZScgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIik7XG4gIGNvbnN0IHRleHRTdHlsZXMgPSBzdHlsZUZpZWxkLnR5cGUub3B0aW9ucz8ubGlzdCAmJiBzdHlsZUZpZWxkLnR5cGUub3B0aW9ucy5saXN0Py5maWx0ZXIoKHN0eWxlKSA9PiBzdHlsZS52YWx1ZSk7XG4gIGlmICghdGV4dFN0eWxlcyB8fCB0ZXh0U3R5bGVzLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUgZmllbGRzIG5lZWQgYXQgbGVhc3Qgb25lIHN0eWxlIGRlZmluZWQuIEkuZToge3RpdGxlOiAnTm9ybWFsJywgdmFsdWU6ICdub3JtYWwnfS5cIik7XG4gIHJldHVybiB0ZXh0U3R5bGVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSB7XG4gIHJldHVybiBzcGFuVHlwZS5kZWNvcmF0b3JzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IGxpc3RGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJsaXN0SXRlbVwiKTtcbiAgaWYgKCFsaXN0RmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBmaWVsZCB3aXRoIG5hbWUgJ2xpc3RJdGVtJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiKTtcbiAgY29uc3QgbGlzdEl0ZW1zID0gbGlzdEZpZWxkLnR5cGUub3B0aW9ucz8ubGlzdCAmJiBsaXN0RmllbGQudHlwZS5vcHRpb25zLmxpc3QuZmlsdGVyKChsaXN0KSA9PiBsaXN0LnZhbHVlKTtcbiAgaWYgKCFsaXN0SXRlbXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3QgZmllbGQgbmVlZCBhdCBsZWFzdCB0byBiZSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgcmV0dXJuIGxpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGZpbmRCbG9ja1R5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZS50eXBlID8gZmluZEJsb2NrVHlwZSh0eXBlLnR5cGUpIDogdHlwZS5uYW1lID09PSBcImJsb2NrXCIgPyB0eXBlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVUeXBlKHJhd1R5cGUpIHtcbiAgcmV0dXJuIFNjaGVtYS5jb21waWxlKHtcbiAgICBuYW1lOiBcImJsb2NrVHlwZVNjaGVtYVwiLFxuICAgIHR5cGVzOiBbcmF3VHlwZV1cbiAgfSkuZ2V0KHJhd1R5cGUubmFtZSk7XG59XG5jb25zdCBkZWJ1ZyRrID0gZGVidWdXaXRoTmFtZShcIm9wZXJhdGlvblRvUGF0Y2hlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZU9wZXJhdGlvblRvUGF0Y2hlcyh0eXBlcykge1xuICBjb25zdCB0ZXh0QmxvY2tOYW1lID0gdHlwZXMuYmxvY2submFtZTtcbiAgZnVuY3Rpb24gaW5zZXJ0VGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGRlYnVnJGsuZW5hYmxlZCAmJiBkZWJ1ZyRrKFwiT3BlcmF0aW9uXCIsIEpTT04uc3RyaW5naWZ5KG9wZXJhdGlvbiwgbnVsbCwgMikpO1xuICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmlzVGV4dEJsb2NrKGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV0pICYmIGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKCFibG9jaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGJsb2NrXCIpO1xuICAgIGNvbnN0IHRleHRDaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dKSAmJiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgaWYgKCF0ZXh0Q2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBjaGlsZFwiKTtcbiAgICBjb25zdCBwYXRoID0gW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IHRleHRDaGlsZC5fa2V5XG4gICAgfSwgXCJ0ZXh0XCJdLCBwcmV2QmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHByZXZDaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhwcmV2QmxvY2spICYmIHByZXZCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0sIHByZXZUZXh0ID0gZWRpdG9yLmlzVGV4dFNwYW4ocHJldkNoaWxkKSA/IHByZXZDaGlsZC50ZXh0IDogXCJcIiwgcGF0Y2ggPSBkaWZmTWF0Y2hQYXRjaCQxKHByZXZUZXh0LCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGNoLnZhbHVlLmxlbmd0aCA/IFtwYXRjaF0gOiBbXTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgYmxvY2sgPSBlZGl0b3IgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWJsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2tcIik7XG4gICAgY29uc3QgY2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSB8fCB2b2lkIDAsIHRleHRDaGlsZCA9IGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSA/IGNoaWxkIDogdm9pZCAwO1xuICAgIGlmIChjaGlsZCAmJiAhdGV4dENoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3BhblwiKTtcbiAgICBpZiAoIXRleHRDaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGNoaWxkXCIpO1xuICAgIGNvbnN0IHBhdGggPSBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogdGV4dENoaWxkLl9rZXlcbiAgICB9LCBcInRleHRcIl0sIGJlZm9yZUJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCBwcmV2VGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJlZm9yZUJsb2NrKSAmJiBiZWZvcmVCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0sIHByZXZUZXh0ID0gZWRpdG9yLmlzVGV4dFNwYW4ocHJldlRleHRDaGlsZCkgJiYgcHJldlRleHRDaGlsZC50ZXh0LCBwYXRjaCA9IGRpZmZNYXRjaFBhdGNoJDEocHJldlRleHQgfHwgXCJcIiwgdGV4dENoaWxkLnRleHQsIHBhdGgpO1xuICAgIHJldHVybiBwYXRjaC52YWx1ZSA/IFtwYXRjaF0gOiBbXTtcbiAgfVxuICBmdW5jdGlvbiBzZXROb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBibG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgICBpZiAodHlwZW9mIGJsb2NrLl9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYmxvY2sgdG8gaGF2ZSBhIF9rZXlcIik7XG4gICAgICBjb25zdCBzZXROb2RlID0gb21pdEJ5KHtcbiAgICAgICAgLi4uZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSxcbiAgICAgICAgLi4ub3BlcmF0aW9uLm5ld1Byb3BlcnRpZXNcbiAgICAgIH0sIGlzVW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiBbc2V0KGZyb21TbGF0ZVZhbHVlKFtzZXROb2RlXSwgdGV4dEJsb2NrTmFtZSlbMF0sIFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH1dKV07XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBjb25zdCBibG9ja0tleSA9IGJsb2NrLl9rZXksIGNoaWxkS2V5ID0gY2hpbGQuX2tleSwgcGF0Y2hlcyA9IFtdLCBrZXlzID0gT2JqZWN0LmtleXMob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgIHJldHVybiBrZXlzLmZvckVhY2goKGtleU5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlOYW1lID09PSBcIl9rZXlcIikge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXQob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMsIGtleU5hbWUpO1xuICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9ja0tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIGJsb2NrLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpLCBrZXlOYW1lXSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gZ2V0KG9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLCBrZXlOYW1lKTtcbiAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHNldCh2YWwsIFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2tLZXlcbiAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogY2hpbGRLZXlcbiAgICAgICAgICAgICAgfSwga2V5TmFtZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgcGF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkIGNoaWxkXCIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCBibG9ja1wiKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBwYXRoIGVuY291bnRlcmVkOiAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5wYXRoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiBpbnNlcnROb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIGlzVGV4dEJsb2NrID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5wYXRoWzBdID09PSAwID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXSAtIDFdLCB0YXJnZXRLZXkgPSBvcGVyYXRpb24ucGF0aFswXSA9PT0gMCA/IGJsb2NrPy5fa2V5IDogYmVmb3JlQmxvY2s/Ll9rZXk7XG4gICAgICByZXR1cm4gdGFyZ2V0S2V5ID8gW2luc2VydChbZnJvbVNsYXRlVmFsdWUoW29wZXJhdGlvbi5ub2RlXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBwb3NpdGlvbiwgW3tcbiAgICAgICAgX2tleTogdGFyZ2V0S2V5XG4gICAgICB9XSldIDogW3NldElmTWlzc2luZyhiZWZvcmVWYWx1ZSwgW10pLCBpbnNlcnQoW2Zyb21TbGF0ZVZhbHVlKFtvcGVyYXRpb24ubm9kZV0sIHRleHRCbG9ja05hbWUpWzBdXSwgXCJiZWZvcmVcIiwgW29wZXJhdGlvbi5wYXRoWzBdXSldO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0QmxvY2sgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyICYmIGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV0pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICFibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiwgbm9kZSA9IHtcbiAgICAgICAgLi4ub3BlcmF0aW9uLm5vZGVcbiAgICAgIH07XG4gICAgICAhbm9kZS5fdHlwZSAmJiBUZXh0LmlzVGV4dChub2RlKSAmJiAobm9kZS5fdHlwZSA9IFwic3BhblwiLCBub2RlLm1hcmtzID0gW10pO1xuICAgICAgY29uc3QgY2hpbGQgPSBmcm9tU2xhdGVWYWx1ZShbe1xuICAgICAgICBfa2V5OiBcImJvZ3VzXCIsXG4gICAgICAgIF90eXBlOiB0ZXh0QmxvY2tOYW1lLFxuICAgICAgICBjaGlsZHJlbjogW25vZGVdXG4gICAgICB9XSwgdGV4dEJsb2NrTmFtZSlbMF0uY2hpbGRyZW5bMF07XG4gICAgICByZXR1cm4gW2luc2VydChbY2hpbGRdLCBwb3NpdGlvbiwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCBibG9jay5jaGlsZHJlbi5sZW5ndGggPD0gMSB8fCAhYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSA/IDAgOiB7XG4gICAgICAgIF9rZXk6IGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0uX2tleVxuICAgICAgfV0pXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlYnVnJGsoXCJTb21ldGhpbmcgd2FzIGluc2VydGVkIGludG8gYSB2b2lkIGJsb2NrLiBOb3QgcHJvZHVjaW5nIGVkaXRvciBwYXRjaGVzLlwiKSwgW107XG4gIH1cbiAgZnVuY3Rpb24gc3BsaXROb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdLCBzcGxpdEJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWVkaXRvci5pc1RleHRCbG9jayhzcGxpdEJsb2NrKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgd2l0aCBwYXRoICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLnBhdGhbMF0pfSBpcyBub3QgYSB0ZXh0IGJsb2NrIGFuZCBjYW4ndCBiZSBzcGxpdGApO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IG9sZEJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhvbGRCbG9jaykpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBmcm9tU2xhdGVWYWx1ZShbZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdICsgMV1dLCB0ZXh0QmxvY2tOYW1lKVswXTtcbiAgICAgICAgdGFyZ2V0VmFsdWUgJiYgKHBhdGNoZXMucHVzaChpbnNlcnQoW3RhcmdldFZhbHVlXSwgXCJhZnRlclwiLCBbe1xuICAgICAgICAgIF9rZXk6IHNwbGl0QmxvY2suX2tleVxuICAgICAgICB9XSkpLCBvbGRCbG9jay5jaGlsZHJlbi5zbGljZShvcGVyYXRpb24ucG9zaXRpb24pLmZvckVhY2goKHNwYW4pID0+IHtcbiAgICAgICAgICBjb25zdCBwYXRoID0gW3tcbiAgICAgICAgICAgIF9rZXk6IG9sZEJsb2NrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IHNwYW4uX2tleVxuICAgICAgICAgIH1dO1xuICAgICAgICAgIHBhdGNoZXMucHVzaCh1bnNldChwYXRoKSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgIH1cbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBzcGxpdFNwYW4gPSBzcGxpdEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihzcGxpdFNwYW4pKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFNwYW5zID0gZnJvbVNsYXRlVmFsdWUoW3tcbiAgICAgICAgICAuLi5zcGxpdEJsb2NrLFxuICAgICAgICAgIGNoaWxkcmVuOiBzcGxpdEJsb2NrLmNoaWxkcmVuLnNsaWNlKG9wZXJhdGlvbi5wYXRoWzFdICsgMSwgb3BlcmF0aW9uLnBhdGhbMV0gKyAyKVxuICAgICAgICB9XSwgdGV4dEJsb2NrTmFtZSlbMF0uY2hpbGRyZW47XG4gICAgICAgIHBhdGNoZXMucHVzaChpbnNlcnQodGFyZ2V0U3BhbnMsIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICBfa2V5OiBzcGxpdEJsb2NrLl9rZXlcbiAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgX2tleTogc3BsaXRTcGFuLl9rZXlcbiAgICAgICAgfV0pKSwgcGF0Y2hlcy5wdXNoKHNldChzcGxpdFNwYW4udGV4dCwgW3tcbiAgICAgICAgICBfa2V5OiBzcGxpdEJsb2NrLl9rZXlcbiAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgX2tleTogc3BsaXRTcGFuLl9rZXlcbiAgICAgICAgfSwgXCJ0ZXh0XCJdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChibG9jayAmJiBibG9jay5fa2V5KVxuICAgICAgICByZXR1cm4gW3Vuc2V0KFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XSldO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgbm90IGZvdW5kXCIpO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHNwYW5Ub1JlbW92ZSA9IGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICAgIHJldHVybiBzcGFuVG9SZW1vdmUgPyBibG9jay5jaGlsZHJlbi5maWx0ZXIoKHNwYW4pID0+IHNwYW4uX2tleSA9PT0gb3BlcmF0aW9uLm5vZGUuX2tleSkubGVuZ3RoID4gMSA/IChjb25zb2xlLndhcm4oYE11bHRpcGxlIHNwYW5zIGhhdmUgXFxgX2tleVxcYCAke29wZXJhdGlvbi5ub2RlLl9rZXl9LiBJdCdzIGFtYmlndW91cyB3aGljaCBvbmUgdG8gcmVtb3ZlLmAsIEpTT04uc3RyaW5naWZ5KGJsb2NrLCBudWxsLCAyKSksIFtdKSA6IFt1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogc3BhblRvUmVtb3ZlLl9rZXlcbiAgICAgIH1dKV0gOiAoZGVidWckayhcIlNwYW4gbm90IGZvdW5kIGluIGVkaXRvciB0cnlpbmcgdG8gcmVtb3ZlIG5vZGVcIiksIFtdKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBkZWJ1ZyRrKFwiTm90IGNyZWF0aW5nIHBhdGNoIGluc2lkZSBvYmplY3QgYmxvY2tcIiksIFtdO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXSwgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHVwZGF0ZWRCbG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSlcbiAgICAgIGlmIChibG9jaz8uX2tleSkge1xuICAgICAgICBjb25zdCBuZXdCbG9jayA9IGZyb21TbGF0ZVZhbHVlKFtlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF0gLSAxXV0sIHRleHRCbG9ja05hbWUpWzBdO1xuICAgICAgICBwYXRjaGVzLnB1c2goc2V0KG5ld0Jsb2NrLCBbe1xuICAgICAgICAgIF9rZXk6IG5ld0Jsb2NrLl9rZXlcbiAgICAgICAgfV0pKSwgcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XSkpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCBrZXkgbm90IGZvdW5kIVwiKTtcbiAgICBlbHNlIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGVkaXRvci5pc1RleHRCbG9jayh1cGRhdGVkQmxvY2spICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgdXBkYXRlZFNwYW4gPSB1cGRhdGVkQmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSAmJiBlZGl0b3IuaXNUZXh0U3Bhbih1cGRhdGVkQmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSkgPyB1cGRhdGVkQmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSA6IHZvaWQgMCwgcmVtb3ZlZFNwYW4gPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0gJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dKSA/IGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSA6IHZvaWQgMDtcbiAgICAgIHVwZGF0ZWRTcGFuICYmIChibG9jay5jaGlsZHJlbi5maWx0ZXIoKHNwYW4pID0+IHNwYW4uX2tleSA9PT0gdXBkYXRlZFNwYW4uX2tleSkubGVuZ3RoID09PSAxID8gcGF0Y2hlcy5wdXNoKHNldCh1cGRhdGVkU3Bhbi50ZXh0LCBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogdXBkYXRlZFNwYW4uX2tleVxuICAgICAgfSwgXCJ0ZXh0XCJdKSkgOiBjb25zb2xlLndhcm4oYE11bHRpcGxlIHNwYW5zIGhhdmUgXFxgX2tleVxcYCAke3VwZGF0ZWRTcGFuLl9rZXl9LiBJdCdzIGFtYmlndW91cyB3aGljaCBvbmUgdG8gdXBkYXRlLmAsIEpTT04uc3RyaW5naWZ5KGJsb2NrLCBudWxsLCAyKSkpLCByZW1vdmVkU3BhbiAmJiAoYmxvY2suY2hpbGRyZW4uZmlsdGVyKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IHJlbW92ZWRTcGFuLl9rZXkpLmxlbmd0aCA9PT0gMSA/IHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogcmVtb3ZlZFNwYW4uX2tleVxuICAgICAgfV0pKSA6IGNvbnNvbGUud2FybihgTXVsdGlwbGUgc3BhbnMgaGF2ZSBcXGBfa2V5XFxgICR7cmVtb3ZlZFNwYW4uX2tleX0uIEl0J3MgYW1iaWd1b3VzIHdoaWNoIG9uZSB0byByZW1vdmUuYCwgSlNPTi5zdHJpbmdpZnkoYmxvY2ssIG51bGwsIDIpKSk7XG4gICAgfSBlbHNlXG4gICAgICBkZWJ1ZyRrKFwiVm9pZCBub2RlcyBjYW4ndCBiZSBtZXJnZWQsIG5vdCBjcmVhdGluZyBhbnkgcGF0Y2hlc1wiKTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBmdW5jdGlvbiBtb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXSwgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHRhcmdldEJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLm5ld1BhdGhbMF1dO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3BlcmF0aW9uLnBhdGhbMF0gPiBvcGVyYXRpb24ubmV3UGF0aFswXSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG4gICAgICBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV0pKSwgcGF0Y2hlcy5wdXNoKGluc2VydChbZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBwb3NpdGlvbiwgW3tcbiAgICAgICAgX2tleTogdGFyZ2V0QmxvY2suX2tleVxuICAgICAgfV0pKTtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMiAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGVkaXRvci5pc1RleHRCbG9jayh0YXJnZXRCbG9jaykpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dLCB0YXJnZXRDaGlsZCA9IHRhcmdldEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5uZXdQYXRoWzFdXSwgcG9zaXRpb24gPSBvcGVyYXRpb24ubmV3UGF0aFsxXSA9PT0gdGFyZ2V0QmxvY2suY2hpbGRyZW4ubGVuZ3RoID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIiwgY2hpbGRUb0luc2VydCA9IGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICAgIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfV0pKSwgcGF0Y2hlcy5wdXNoKGluc2VydChbY2hpbGRUb0luc2VydF0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRCbG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogdGFyZ2V0Q2hpbGQuX2tleVxuICAgICAgfV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbnNlcnROb2RlUGF0Y2gsXG4gICAgaW5zZXJ0VGV4dFBhdGNoLFxuICAgIG1lcmdlTm9kZVBhdGNoLFxuICAgIG1vdmVOb2RlUGF0Y2gsXG4gICAgcmVtb3ZlTm9kZVBhdGNoLFxuICAgIHJlbW92ZVRleHRQYXRjaCxcbiAgICBzZXROb2RlUGF0Y2gsXG4gICAgc3BsaXROb2RlUGF0Y2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhFdmVudExpc3RlbmVycyhlZGl0b3JBY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9ICh1bml0KSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWxldGUgYmFja3dhcmRcIixcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmRlbGV0ZUZvcndhcmQgPSAodW5pdCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlIGZvcndhcmRcIixcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0IGJyZWFrXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrID0gKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0IHNvZnQgYnJlYWtcIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRUZXh0ID0gKHRleHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImluc2VydCB0ZXh0XCIsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckaiA9IGRlYnVnV2l0aE5hbWUoXCJBUEk6ZWRpdGFibGVcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoRWRpdGFibGVBUEkoZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgdHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBwb3J0YWJsZVRleHRFZGl0b3Iuc2V0RWRpdGFibGUoe1xuICAgICAgZm9jdXM6ICgpID0+IHtcbiAgICAgICAgUmVhY3RFZGl0b3IuZm9jdXMoZWRpdG9yKTtcbiAgICAgIH0sXG4gICAgICBibHVyOiAoKSA9PiB7XG4gICAgICAgIFJlYWN0RWRpdG9yLmJsdXIoZWRpdG9yKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVNYXJrOiAobWFyaykgPT4ge1xuICAgICAgICBlZGl0b3IucHRlVG9nZ2xlTWFyayhtYXJrKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVMaXN0OiAobGlzdFN0eWxlKSA9PiB7XG4gICAgICAgIGVkaXRvci5wdGVUb2dnbGVMaXN0SXRlbShsaXN0U3R5bGUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUJsb2NrU3R5bGU6IChibG9ja1N0eWxlKSA9PiB7XG4gICAgICAgIGVkaXRvci5wdGVUb2dnbGVCbG9ja1N0eWxlKGJsb2NrU3R5bGUpO1xuICAgICAgfSxcbiAgICAgIGlzTWFya0FjdGl2ZTogKG1hcmspID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLnB0ZUlzTWFya0FjdGl2ZShtYXJrKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnIpLCAhMTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1hcmtzOiAoKSA9PiAoe1xuICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgfSkubWFya3MgfHwgW10sXG4gICAgICB1bmRvOiAoKSA9PiBlZGl0b3IudW5kbygpLFxuICAgICAgcmVkbzogKCkgPT4gZWRpdG9yLnJlZG8oKSxcbiAgICAgIHNlbGVjdDogKHNlbGVjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBzbGF0ZVNlbGVjdGlvbiA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgIHNsYXRlU2VsZWN0aW9uID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzbGF0ZVNlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIGZvY3VzQmxvY2s6ICgpID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBibG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZvY3VzQ2hpbGQ6ICgpID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBibG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgICAgaWYgKGJsb2NrICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpXG4gICAgICAgICAgICByZXR1cm4gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpWzBdLmNoaWxkcmVuW2VkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aFsxXV07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbnNlcnRDaGlsZDogKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZWRpdG9yIGhhcyBubyBzZWxlY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IFtmb2N1c0Jsb2NrXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksXG4gICAgICAgICAgbWF0Y2g6IChuKSA9PiBuLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lXG4gICAgICAgIH0pKVswXSB8fCBbdm9pZCAwXTtcbiAgICAgICAgaWYgKCFmb2N1c0Jsb2NrKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZvY3VzZWQgdGV4dCBibG9ja1wiKTtcbiAgICAgICAgaWYgKHR5cGUubmFtZSAhPT0gdHlwZXMuc3Bhbi5uYW1lICYmICF0eXBlcy5pbmxpbmVPYmplY3RzLnNvbWUoKHQpID0+IHQubmFtZSA9PT0gdHlwZS5uYW1lKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHR5cGUgY2Fubm90IGJlIGluc2VydGVkIGFzIGEgY2hpbGQgdG8gYSB0ZXh0IGJsb2NrXCIpO1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRvU2xhdGVWYWx1ZShbe1xuICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZSxcbiAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAuLi52YWx1ZSB8fCB7fVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwb3J0YWJsZVRleHRFZGl0b3IpWzBdLmNoaWxkcmVuWzBdLCBmb2N1c0NoaWxkUGF0aCA9IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAyKSwgaXNTcGFuTm9kZSA9IGNoaWxkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUsIGZvY3VzTm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgZm9jdXNDaGlsZFBhdGgpO1xuICAgICAgICByZXR1cm4gaXNTcGFuTm9kZSAmJiBmb2N1c05vZGUuX3R5cGUgIT09IHR5cGVzLnNwYW4ubmFtZSAmJiAoZGVidWckaihcIkluc2VydGluZyBzcGFuIGNoaWxkIG5leHQgdG8gaW5saW5lIG9iamVjdCBjaGlsZCwgbW92aW5nIHNlbGVjdGlvbiArIDFcIiksIGVkaXRvci5tb3ZlKHtcbiAgICAgICAgICBkaXN0YW5jZTogMSxcbiAgICAgICAgICB1bml0OiBcImNoYXJhY3RlclwiXG4gICAgICAgIH0pKSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICAgICAgc2VsZWN0OiAhMCxcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvblxuICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCksIHRvUG9ydGFibGVUZXh0UmFuZ2UoZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKT8uZm9jdXMucGF0aCB8fCBbXTtcbiAgICAgIH0sXG4gICAgICBpbnNlcnRCbG9jazogKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgLi4udmFsdWUgfHwge31cbiAgICAgICAgfV0sIHBvcnRhYmxlVGV4dEVkaXRvcilbMF07XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IGxhc3RCbG9jayA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiAhRWRpdG9yLmlzRWRpdG9yKG4pLFxuICAgICAgICAgICAgYXQ6IFtdLFxuICAgICAgICAgICAgcmV2ZXJzZTogITBcbiAgICAgICAgICB9KSlbMF07XG4gICAgICAgICAgcmV0dXJuIEVkaXRvci5pbnNlcnROb2RlKGVkaXRvciwgYmxvY2spLCBsYXN0QmxvY2sgJiYgaXNFcXVhbFRvRW1wdHlFZGl0b3IoW2xhc3RCbG9ja1swXV0sIHR5cGVzKSAmJiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGxhc3RCbG9ja1sxXVxuICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpPy5mb2N1cy5wYXRoID8/IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvY3VzQmxvY2sgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLFxuICAgICAgICAgIG1hdGNoOiAobikgPT4gbi5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgICB9KSlbMF07XG4gICAgICAgIHJldHVybiBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGJsb2NrKSwgZm9jdXNCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbZm9jdXNCbG9ja1swXV0sIHR5cGVzKSAmJiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBmb2N1c0Jsb2NrWzFdXG4gICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpPy5mb2N1cy5wYXRoIHx8IFtdO1xuICAgICAgfSxcbiAgICAgIGhhc0Jsb2NrU3R5bGU6IChzdHlsZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBlZGl0b3IucHRlSGFzQmxvY2tTdHlsZShzdHlsZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc0xpc3RTdHlsZTogKGxpc3RTdHlsZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBlZGl0b3IucHRlSGFzTGlzdFN0eWxlKGxpc3RTdHlsZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzVm9pZDogKGVsZW1lbnQpID0+ICFbdHlwZXMuYmxvY2submFtZSwgdHlwZXMuc3Bhbi5uYW1lXS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSxcbiAgICAgIGZpbmRCeVBhdGg6IChwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNsYXRlUGF0aCA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgZWRpdG9yKTtcbiAgICAgICAgaWYgKHNsYXRlUGF0aCkge1xuICAgICAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2xhdGVQYXRoLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICAgIGlmIChibG9jayAmJiBibG9ja1BhdGggJiYgdHlwZW9mIGJsb2NrLl9rZXkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHNsYXRlUGF0aC5mb2N1cy5wYXRoLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lKVswXSwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgIH1dXTtcbiAgICAgICAgICAgIGNvbnN0IHB0QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gICAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKHB0QmxvY2spKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHB0Q2hpbGQgPSBwdEJsb2NrLmNoaWxkcmVuW3NsYXRlUGF0aC5mb2N1cy5wYXRoWzFdXTtcbiAgICAgICAgICAgICAgaWYgKHB0Q2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwdENoaWxkLCBbe1xuICAgICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgICAgX2tleTogcHRDaGlsZC5fa2V5XG4gICAgICAgICAgICAgICAgfV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICAgIH0sXG4gICAgICBmaW5kRE9NTm9kZTogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgW2l0ZW1dID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogW10sXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IG4uX2tleSA9PT0gZWxlbWVudC5fa2V5XG4gICAgICAgICAgfSkgfHwgW10pWzBdIHx8IFt2b2lkIDBdO1xuICAgICAgICAgIG5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBpdGVtKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LFxuICAgICAgYWN0aXZlQW5ub3RhdGlvbnM6ICgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5sZW5ndGggPCAyKVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVBbm5vdGF0aW9ucyA9IFtdLCBzcGFucyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBUZXh0LmlzVGV4dChub2RlKSAmJiBub2RlLm1hcmtzICE9PSB2b2lkIDAgJiYgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmxlbmd0aCA+IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtzcGFuLCBwYXRoXSBvZiBzcGFucykge1xuICAgICAgICAgICAgY29uc3QgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCwge1xuICAgICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLm1hcmtEZWZzPy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgICAgICAgVGV4dC5pc1RleHQoc3BhbikgJiYgc3Bhbi5tYXJrcyAmJiBBcnJheS5pc0FycmF5KHNwYW4ubWFya3MpICYmIHNwYW4ubWFya3MuaW5jbHVkZXMoZGVmLl9rZXkpICYmIGFjdGl2ZUFubm90YXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWN0aXZlQW5ub3RhdGlvbnM7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzQW5ub3RhdGlvbkFjdGl2ZTogKGFubm90YXRpb25UeXBlKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgubGVuZ3RoIDwgMilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3BhbnMgPSBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IFRleHQuaXNUZXh0KG5vZGUpXG4gICAgICAgICAgfSldO1xuICAgICAgICAgIGlmIChzcGFucy5sZW5ndGggPT09IDAgfHwgc3BhbnMuc29tZSgoW3NwYW5dKSA9PiAhaXNQb3J0YWJsZVRleHRTcGFuJDEoc3BhbikgfHwgIXNwYW4ubWFya3MgfHwgc3Bhbi5tYXJrcz8ubGVuZ3RoID09PSAwKSkgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbk1hcmtEZWZzID0gc3BhbnMucmVkdWNlKChhY2NNYXJrRGVmcywgWywgcGF0aF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2subWFya0RlZnMgPyBbLi4uYWNjTWFya0RlZnMsIC4uLmJsb2NrLm1hcmtEZWZzXSA6IGFjY01hcmtEZWZzO1xuICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICByZXR1cm4gc3BhbnMuZXZlcnkoKFtzcGFuXSkgPT4gaXNQb3J0YWJsZVRleHRTcGFuJDEoc3BhbikgPyBzcGFuLm1hcmtzPy5tYXAoKG1hcmtLZXkpID0+IHNlbGVjdGlvbk1hcmtEZWZzLmZpbmQoKGRlZikgPT4gZGVmPy5fa2V5ID09PSBtYXJrS2V5KT8uX3R5cGUpPy5pbmNsdWRlcyhhbm5vdGF0aW9uVHlwZSkgOiAhMSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFkZEFubm90YXRpb246ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uOiBvcmlnaW5hbFNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgIGlmIChvcmlnaW5hbFNlbGVjdGlvbiAmJiAoUmFuZ2UuaXNDb2xsYXBzZWQob3JpZ2luYWxTZWxlY3Rpb24pICYmIChlZGl0b3IucHRlRXhwYW5kVG9Xb3JkKCksIGVkaXRvci5vbkNoYW5nZSgpKSwgZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICBsZXQgc3BhblBhdGgsIG1hcmtEZWZQYXRoO1xuICAgICAgICAgIGNvbnN0IG1hcmtEZWZQYXRocyA9IFtdO1xuICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSksXG4gICAgICAgICAgICAgIHJldmVyc2U6IFJhbmdlLmlzQmFja3dhcmQoZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gb2Ygc2VsZWN0ZWRCbG9ja3MpIHtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbktleSA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSwgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXTtcbiAgICAgICAgICAgICAgbWFya0RlZnMuZmluZCgobWFya0RlZikgPT4gbWFya0RlZi5fdHlwZSA9PT0gdHlwZS5uYW1lICYmIG1hcmtEZWYuX2tleSA9PT0gYW5ub3RhdGlvbktleSkgPT09IHZvaWQgMCAmJiAoVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBtYXJrRGVmczogWy4uLm1hcmtEZWZzLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogdHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgX2tleTogYW5ub3RhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGF0OiBibG9ja1BhdGhcbiAgICAgICAgICAgICAgfSksIG1hcmtEZWZQYXRoID0gW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgIH0sIFwibWFya0RlZnNcIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IGFubm90YXRpb25LZXlcbiAgICAgICAgICAgICAgfV0sIFJhbmdlLmlzQmFja3dhcmQoZWRpdG9yLnNlbGVjdGlvbikgPyBtYXJrRGVmUGF0aHMudW5zaGlmdChtYXJrRGVmUGF0aCkgOiBtYXJrRGVmUGF0aHMucHVzaChtYXJrRGVmUGF0aCkpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgICAgICAgICAgc3BsaXQ6ICEwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzcGFuLCBwYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oc3BhbikgfHwgIVJhbmdlLmluY2x1ZGVzKGVkaXRvci5zZWxlY3Rpb24sIHBhdGgpKVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBleGlzdGluZ1NhbWVUeXBlQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLnNvbWUoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyayAmJiBtYXJrRGVmLl90eXBlID09PSB0eXBlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgbWFya3M6IFsuLi5tYXJrcy5maWx0ZXIoKG1hcmspID0+ICFleGlzdGluZ1NhbWVUeXBlQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpLCBhbm5vdGF0aW9uS2V5XVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICAgICAgfSksIHNwYW5QYXRoID0gW3tcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICAgIF9rZXk6IHNwYW4uX2tleVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrRGVmUGF0aCAmJiBzcGFuUGF0aCAmJiAocmV0dXJuVmFsdWUgPSB7XG4gICAgICAgICAgICAgIG1hcmtEZWZQYXRoLFxuICAgICAgICAgICAgICBtYXJrRGVmUGF0aHMsXG4gICAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogKHNlbGVjdGlvbiwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgICAgICAgIGlmICghKHJhbmdlICYmIHJhbmdlLmFuY2hvci5wYXRoLmxlbmd0aCA+IDAgJiYgcmFuZ2UuZm9jdXMucGF0aC5sZW5ndGggPiAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmFuZ2VcIik7XG4gICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnM/Lm1vZGUgfHwgb3B0aW9ucz8ubW9kZSA9PT0gXCJzZWxlY3RlZFwiKSB7XG4gICAgICAgICAgICAgIGRlYnVnJGooXCJEZWxldGluZyBjb250ZW50IGluIHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICAgIGhhbmdpbmc6ICEwLFxuICAgICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnM/Lm1vZGUgPT09IFwiYmxvY2tzXCIgJiYgKGRlYnVnJGooXCJEZWxldGluZyBibG9ja3MgdG91Y2hlZCBieSBzZWxlY3Rpb25cIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwLFxuICAgICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKSB8fCAhZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSlcbiAgICAgICAgICAgIH0pKSwgb3B0aW9ucz8ubW9kZSA9PT0gXCJjaGlsZHJlblwiICYmIChkZWJ1ZyRqKFwiRGVsZXRpbmcgY2hpbGRyZW4gdG91Y2hlZCBieSBzZWxlY3Rpb25cIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwLFxuICAgICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IG5vZGUuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSB8fCAvLyBUZXh0IGNoaWxkcmVuXG4gICAgICAgICAgICAgICFlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgRWxlbWVudCQxLmlzRWxlbWVudChub2RlKVxuICAgICAgICAgICAgfSkpLCBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIChlZGl0b3IuY2hpbGRyZW4gPSBbZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgICAgICB9KV0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVBbm5vdGF0aW9uOiAodHlwZSkgPT4ge1xuICAgICAgICBkZWJ1ZyRqKFwiUmVtb3ZpbmcgYW5ub3RhdGlvblwiLCB0eXBlKSwgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsQW5ub3RhdGlvbnMgPSAoYmxvY2subWFya0RlZnMgPz8gW10pLmZpbHRlcigobWFya0RlZikgPT4gbWFya0RlZi5fdHlwZSA9PT0gdHlwZS5uYW1lKSwgW3NlbGVjdGVkQ2hpbGQsIHNlbGVjdGVkQ2hpbGRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICAgICAgICAgIGRlcHRoOiAyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKHNlbGVjdGVkQ2hpbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblRvUmVtb3ZlID0gc2VsZWN0ZWRDaGlsZC5tYXJrcz8uZmluZCgobWFyaykgPT4gcG90ZW50aWFsQW5ub3RhdGlvbnMuc29tZSgobWFya0RlZikgPT4gbWFya0RlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICAgICAgICAgIGlmICghYW5ub3RhdGlvblRvUmVtb3ZlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoLCB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZTogITBcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQmVmb3JlKGNoaWxkUGF0aCwgc2VsZWN0ZWRDaGlsZFBhdGgpKVxuICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhhbm5vdGF0aW9uVG9SZW1vdmUpKVxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLnB1c2goW2NoaWxkLCBjaGlsZFBhdGhdKTtcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKSlcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNBZnRlcihjaGlsZFBhdGgsIHNlbGVjdGVkQ2hpbGRQYXRoKSlcbiAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5tYXJrcz8uaW5jbHVkZXMoYW5ub3RhdGlvblRvUmVtb3ZlKSlcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLnB1c2goW2NoaWxkLCBjaGlsZFBhdGhdKTtcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIFsuLi5wcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLCBbc2VsZWN0ZWRDaGlsZCwgc2VsZWN0ZWRDaGlsZFBhdGhdLCAuLi5uZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb25dKVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBtYXJrczogY2hpbGQubWFya3M/LmZpbHRlcigobWFyaykgPT4gbWFyayAhPT0gYW5ub3RhdGlvblRvUmVtb3ZlKVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dFNwYW4obm9kZSksXG4gICAgICAgICAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICAgICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBibG9ja3MgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdIG9mIGJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpIHx8ICFSYW5nZS5pbmNsdWRlcyhlZGl0b3Iuc2VsZWN0aW9uLCBjaGlsZFBhdGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW10sIG1hcmtzID0gY2hpbGQubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb24gPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYyKSA9PiBtYXJrRGVmMi5fa2V5ID09PSBtYXJrKT8uX3R5cGUgIT09IHR5cGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uLmxlbmd0aCAhPT0gbWFya3MubGVuZ3RoICYmIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtzOiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgZ2V0U2VsZWN0aW9uOiAoKSA9PiB7XG4gICAgICAgIGxldCBwdFJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UuZ2V0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIGlmIChleGlzdGluZylcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICBwdFJhbmdlID0gdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpLCBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLnNldChlZGl0b3Iuc2VsZWN0aW9uLCBwdFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHRSYW5nZTtcbiAgICAgIH0sXG4gICAgICBnZXRWYWx1ZTogKCkgPT4gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksXG4gICAgICBpc0NvbGxhcHNlZFNlbGVjdGlvbjogKCkgPT4gISFlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pLFxuICAgICAgaXNFeHBhbmRlZFNlbGVjdGlvbjogKCkgPT4gISFlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoZWRpdG9yLnNlbGVjdGlvbiksXG4gICAgICBpbnNlcnRCcmVhazogKCkgPT4ge1xuICAgICAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgZ2V0RnJhZ21lbnQ6ICgpID0+IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5nZXRGcmFnbWVudCgpLCB0eXBlcy5ibG9jay5uYW1lKSxcbiAgICAgIGlzU2VsZWN0aW9uc092ZXJsYXBwaW5nOiAoc2VsZWN0aW9uQSwgc2VsZWN0aW9uQikgPT4ge1xuICAgICAgICBjb25zdCByYW5nZUEgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uQSwgZWRpdG9yKSwgcmFuZ2VCID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbkIsIGVkaXRvcik7XG4gICAgICAgIHJldHVybiBSYW5nZS5pc1JhbmdlKHJhbmdlQSkgJiYgUmFuZ2UuaXNSYW5nZShyYW5nZUIpICYmIFJhbmdlLmluY2x1ZGVzKHJhbmdlQSwgcmFuZ2VCKTtcbiAgICAgIH1cbiAgICB9KSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gd2l0aFJlbW90ZUNoYW5nZXMoZWRpdG9yLCBmbikge1xuICBjb25zdCBwcmV2ID0gaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikgfHwgITE7XG4gIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgITApLCBmbigpLCBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikge1xuICByZXR1cm4gSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5nZXQoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGlzQ2hhbmdpbmdMb2NhbGx5KGVkaXRvcikge1xuICByZXR1cm4gSVNfUFJPQ0VTU0lOR19MT0NBTF9DSEFOR0VTLmdldChlZGl0b3IpO1xufVxuY29uc3QgSVNfVURPSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX1JFRE9JTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHdpdGhVbmRvaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzVW5kb2luZyhlZGl0b3IpO1xuICBJU19VRE9JTkcuc2V0KGVkaXRvciwgITApLCBmbigpLCBJU19VRE9JTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1VuZG9pbmcoZWRpdG9yKSB7XG4gIHJldHVybiBJU19VRE9JTkcuZ2V0KGVkaXRvcikgPz8gITE7XG59XG5mdW5jdGlvbiBzZXRJc1VuZG9pbmcoZWRpdG9yLCBpc1VuZG9pbmcyKSB7XG4gIElTX1VET0lORy5zZXQoZWRpdG9yLCBpc1VuZG9pbmcyKTtcbn1cbmZ1bmN0aW9uIHdpdGhSZWRvaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUmVkb2luZyhlZGl0b3IpO1xuICBJU19SRURPSU5HLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfUkVET0lORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzUmVkb2luZyhlZGl0b3IpIHtcbiAgcmV0dXJuIElTX1JFRE9JTkcuZ2V0KGVkaXRvcikgPz8gITE7XG59XG5mdW5jdGlvbiBzZXRJc1JlZG9pbmcoZWRpdG9yLCBpc1JlZG9pbmcyKSB7XG4gIElTX1JFRE9JTkcuc2V0KGVkaXRvciwgaXNSZWRvaW5nMik7XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoTWF4QmxvY2tzKG1heEJsb2Nrcykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzID0gbWF4QmxvY2tzO1xuICAgICAgcm93cyA+IDAgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+PSByb3dzICYmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiIHx8IG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxIHx8IGFwcGx5MihvcGVyYXRpb24pO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhPYmplY3RLZXlzKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MixcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikge1xuICAgICAgICBhcHBseTIoe1xuICAgICAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAuLi5vcGVyYXRpb24ucHJvcGVydGllcyxcbiAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiICYmICFFZGl0b3IuaXNFZGl0b3Iob3BlcmF0aW9uLm5vZGUpKSB7XG4gICAgICAgIGFwcGx5Mih7XG4gICAgICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIC4uLm9wZXJhdGlvbi5ub2RlLFxuICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgfSwgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuX2tleSkge1xuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICBpZiAoIWNoaWxkLl9rZXkpIHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoYXIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjaGFyQ29kZSA+PSA1NTI5NiAmJiBjaGFyQ29kZSA8PSA1NjMxOTtcbn1cbmZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNoYXIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjaGFyQ29kZSA+PSA1NjMyMCAmJiBjaGFyQ29kZSA8PSA1NzM0Mztcbn1cbmZ1bmN0aW9uIGNsb25lRGlmZihkaWZmMikge1xuICBjb25zdCBbdHlwZSwgcGF0Y2hdID0gZGlmZjI7XG4gIHJldHVybiBbdHlwZSwgcGF0Y2hdO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uT3ZlcmxhcCh0ZXh0QSwgdGV4dEIpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGNvbnN0IHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoLCB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgaWYgKHRleHQxTGVuZ3RoID09PSAwIHx8IHRleHQyTGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICB0ZXh0MUxlbmd0aCA+IHRleHQyTGVuZ3RoID8gdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFMZW5ndGggLSB0ZXh0Mkxlbmd0aCkgOiB0ZXh0MUxlbmd0aCA8IHRleHQyTGVuZ3RoICYmICh0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MUxlbmd0aCkpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gTWF0aC5taW4odGV4dDFMZW5ndGgsIHRleHQyTGVuZ3RoKTtcbiAgaWYgKHRleHQxID09PSB0ZXh0MilcbiAgICByZXR1cm4gdGV4dExlbmd0aDtcbiAgbGV0IGJlc3QgPSAwLCBsZW5ndGggPSAxO1xuICBmb3IgKGxldCBmb3VuZCA9IDA7IGZvdW5kICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBpZiAoZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pLCBmb3VuZCA9PT0gLTEpXG4gICAgICByZXR1cm4gYmVzdDtcbiAgICBsZW5ndGggKz0gZm91bmQsIChmb3VuZCA9PT0gMCB8fCB0ZXh0MS5zdWJzdHJpbmcodGV4dExlbmd0aCAtIGxlbmd0aCkgPT09IHRleHQyLnN1YnN0cmluZygwLCBsZW5ndGgpKSAmJiAoYmVzdCA9IGxlbmd0aCwgbGVuZ3RoKyspO1xuICB9XG4gIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MVswXSAhPT0gdGV4dDJbMF0pXG4gICAgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJTdGFydCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKVxuICAgIHRleHQxLnN1YnN0cmluZyhwb2ludGVyU3RhcnQsIHBvaW50ZXJNaWQpID09PSB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA/IChwb2ludGVyTWluID0gcG9pbnRlck1pZCwgcG9pbnRlclN0YXJ0ID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBnZXRDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxW3RleHQxLmxlbmd0aCAtIDFdICE9PSB0ZXh0Mlt0ZXh0Mi5sZW5ndGggLSAxXSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJNaW4gPSAwLCBwb2ludGVyTWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpLCBwb2ludGVyTWlkID0gcG9pbnRlck1heCwgcG9pbnRlckVuZCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKVxuICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVyTWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyRW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJFbmQpID8gKHBvaW50ZXJNaW4gPSBwb2ludGVyTWlkLCBwb2ludGVyRW5kID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWMocmF3RGlmZnMpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKVxuICAgIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIGxlbmd0aEluc2VydGlvbnMxID0gbGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczEgPSBsZW5ndGhEZWxldGlvbnMyLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXSkgOiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUID8gbGVuZ3RoSW5zZXJ0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDogbGVuZ3RoRGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGgsIGxhc3RFcXVhbGl0eSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMxLCBsZW5ndGhEZWxldGlvbnMxKSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMyKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICBmb3IgKGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpLCBwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV0sIG92ZXJsYXBMZW5ndGgxID0gZ2V0Q29tbW9uT3ZlcmxhcChkZWxldGlvbiwgaW5zZXJ0aW9uKSwgb3ZlcmxhcExlbmd0aDIgPSBnZXRDb21tb25PdmVybGFwKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgb3ZlcmxhcExlbmd0aDEgPj0gb3ZlcmxhcExlbmd0aDIgPyAob3ZlcmxhcExlbmd0aDEgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMSldKSwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgxKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMSksIHBvaW50ZXIrKykgOiAob3ZlcmxhcExlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgyKV0pLCBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVCwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcExlbmd0aDIpLCBkaWZmc1twb2ludGVyICsgMV1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBMZW5ndGgyKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuY29uc3Qgbm9uQWxwaGFOdW1lcmljUmVnZXggPSAvW15hLXpBLVowLTldLywgd2hpdGVzcGFjZVJlZ2V4ID0gL1xccy8sIGxpbmVicmVha1JlZ2V4ID0gL1tcXHJcXG5dLywgYmxhbmtsaW5lRW5kUmVnZXggPSAvXFxuXFxyP1xcbiQvLCBibGFua2xpbmVTdGFydFJlZ2V4ID0gL15cXHI/XFxuXFxyP1xcbi87XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhyYXdEaWZmcykge1xuICBjb25zdCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBmdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKVxuICAgICAgcmV0dXJuIDY7XG4gICAgY29uc3QgY2hhcjEgPSBvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKSwgY2hhcjIgPSB0d28uY2hhckF0KDApLCBub25BbHBoYU51bWVyaWMxID0gY2hhcjEubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCBub25BbHBoYU51bWVyaWMyID0gY2hhcjIubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiYgY2hhcjEubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgd2hpdGVzcGFjZTIgPSBub25BbHBoYU51bWVyaWMyICYmIGNoYXIyLm1hdGNoKHdoaXRlc3BhY2VSZWdleCksIGxpbmVCcmVhazEgPSB3aGl0ZXNwYWNlMSAmJiBjaGFyMS5tYXRjaChsaW5lYnJlYWtSZWdleCksIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJiBjaGFyMi5tYXRjaChsaW5lYnJlYWtSZWdleCksIGJsYW5rTGluZTEgPSBsaW5lQnJlYWsxICYmIG9uZS5tYXRjaChibGFua2xpbmVFbmRSZWdleCksIGJsYW5rTGluZTIgPSBsaW5lQnJlYWsyICYmIHR3by5tYXRjaChibGFua2xpbmVTdGFydFJlZ2V4KTtcbiAgICByZXR1cm4gYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyID8gNSA6IGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMiA/IDQgOiBub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMiA/IDMgOiB3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMiA/IDIgOiBub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIgPyAxIDogMDtcbiAgfVxuICBsZXQgcG9pbnRlciA9IDE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGxldCBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXSwgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgY29uc3QgY29tbW9uT2Zmc2V0ID0gZ2V0Q29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuICAgICAgbGV0IGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MiwgYmVzdFNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIGZvciAoOyBlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKTsgKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKSwgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKSwgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICBzY29yZSA+PSBiZXN0U2NvcmUgJiYgKGJlc3RTY29yZSA9IHNjb3JlLCBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxLCBiZXN0RWRpdCA9IGVkaXQsIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTIpO1xuICAgICAgfVxuICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9PSBiZXN0RXF1YWxpdHkxICYmIChiZXN0RXF1YWxpdHkxID8gZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MSA6IChkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBwb2ludGVyLS0pLCBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0LCBiZXN0RXF1YWxpdHkyID8gZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MiA6IChkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBwb2ludGVyLS0pKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmZ1bmN0aW9uIGNsZWFudXBNZXJnZShyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCIsIGNvbW1vbmxlbmd0aDtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7IClcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXSwgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgY291bnREZWxldGUgKyBjb3VudEluc2VydCA+IDEgPyAoY291bnREZWxldGUgIT09IDAgJiYgY291bnRJbnNlcnQgIT09IDAgJiYgKGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKSwgY29tbW9ubGVuZ3RoICE9PSAwICYmIChwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCA+IDAgJiYgZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMV0gKz0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKSA6IChkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsIHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dEluc2VydC5zdWJzdHJpbmcodGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV0sIHRleHRJbnNlcnQgPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0RGVsZXRlLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkpKSwgcG9pbnRlciAtPSBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0LCBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnREZWxldGUgKyBjb3VudEluc2VydCksIHRleHREZWxldGUubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfREVMRVRFLCB0ZXh0RGVsZXRlXSksIHBvaW50ZXIrKyksIHRleHRJbnNlcnQubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfSU5TRVJULCB0ZXh0SW5zZXJ0XSksIHBvaW50ZXIrKyksIHBvaW50ZXIrKykgOiBwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKSkgOiBwb2ludGVyKyssIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvblwiKTtcbiAgICB9XG4gIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSBcIlwiICYmIGRpZmZzLnBvcCgpO1xuICBsZXQgaGFzQ2hhbmdlcyA9ICExO1xuICBmb3IgKHBvaW50ZXIgPSAxOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKVxuICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdID8gKGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkgOiBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSAmJiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIHRydWVDb3VudCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKVxuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIHJldHVybiBhcmdzLnJlZHVjZSgobiwgYm9vbCkgPT4gbiArIChib29sID8gMSA6IDApLCAwKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZpY2llbmN5KHJhd0RpZmZzKSB7XG4gIGxldCBlZGl0Q29zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogNCwgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIHByZUlucyA9ICExLCBwcmVEZWwgPSAhMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApXG4gICAgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwgPyAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgZWRpdENvc3QgJiYgKHBvc3RJbnMgfHwgcG9zdERlbCkgPyAoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlciwgcHJlSW5zID0gcG9zdElucywgcHJlRGVsID0gcG9zdERlbCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsKSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0RFTEVURSA/IHBvc3REZWwgPSAhMCA6IHBvc3RJbnMgPSAhMCwgbGFzdEVxdWFsaXR5ICYmIChwcmVJbnMgJiYgcHJlRGVsICYmIHBvc3RJbnMgJiYgcG9zdERlbCB8fCBsYXN0RXF1YWxpdHkubGVuZ3RoIDwgZWRpdENvc3QgLyAyICYmIHRydWVDb3VudChwcmVJbnMsIHByZURlbCwgcG9zdElucywgcG9zdERlbCkgPT09IDMpICYmIChkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5XSksIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVCwgZXF1YWxpdGllc0xlbmd0aC0tLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwcmVJbnMgJiYgcHJlRGVsID8gKHBvc3RJbnMgPSAhMCwgcG9zdERlbCA9ICEwLCBlcXVhbGl0aWVzTGVuZ3RoID0gMCkgOiAoZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGJpc2VjdCh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG4gIGNvbnN0IHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoLCB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aCwgbWF4RCA9IE1hdGguY2VpbCgodGV4dDFMZW5ndGggKyB0ZXh0Mkxlbmd0aCkgLyAyKSwgdk9mZnNldCA9IG1heEQsIHZMZW5ndGggPSAyICogbWF4RCwgdjEgPSBuZXcgQXJyYXkodkxlbmd0aCksIHYyID0gbmV3IEFycmF5KHZMZW5ndGgpO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHZMZW5ndGg7IHgrKylcbiAgICB2MVt4XSA9IC0xLCB2Mlt4XSA9IC0xO1xuICB2MVt2T2Zmc2V0ICsgMV0gPSAwLCB2Mlt2T2Zmc2V0ICsgMV0gPSAwO1xuICBjb25zdCBkZWx0YSA9IHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgsIGZyb250ID0gZGVsdGEgJSAyICE9PSAwO1xuICBsZXQgazFzdGFydCA9IDAsIGsxZW5kID0gMCwgazJzdGFydCA9IDAsIGsyZW5kID0gMDtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBtYXhEICYmICEoRGF0ZS5ub3coKSA+IGRlYWRsaW5lKTsgZCsrKSB7XG4gICAgZm9yIChsZXQgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgazE7XG4gICAgICBsZXQgeDE7XG4gICAgICBrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFPZmZzZXQgLSAxXSA8IHYxW2sxT2Zmc2V0ICsgMV0gPyB4MSA9IHYxW2sxT2Zmc2V0ICsgMV0gOiB4MSA9IHYxW2sxT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkxID0geDEgLSBrMTtcbiAgICAgIGZvciAoOyB4MSA8IHRleHQxTGVuZ3RoICYmIHkxIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHgxKSA9PT0gdGV4dDIuY2hhckF0KHkxKTsgKVxuICAgICAgICB4MSsrLCB5MSsrO1xuICAgICAgaWYgKHYxW2sxT2Zmc2V0XSA9IHgxLCB4MSA+IHRleHQxTGVuZ3RoKVxuICAgICAgICBrMWVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTEgPiB0ZXh0Mkxlbmd0aClcbiAgICAgICAgazFzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyT2Zmc2V0ID49IDAgJiYgazJPZmZzZXQgPCB2TGVuZ3RoICYmIHYyW2syT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MiA9IHRleHQxTGVuZ3RoIC0gdjJbazJPZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4MilcbiAgICAgICAgICAgIHJldHVybiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcbiAgICAgIGNvbnN0IGsyT2Zmc2V0ID0gdk9mZnNldCArIGsyO1xuICAgICAgbGV0IHgyO1xuICAgICAgazIgPT09IC1kIHx8IGsyICE9PSBkICYmIHYyW2syT2Zmc2V0IC0gMV0gPCB2MltrMk9mZnNldCArIDFdID8geDIgPSB2MltrMk9mZnNldCArIDFdIDogeDIgPSB2MltrMk9mZnNldCAtIDFdICsgMTtcbiAgICAgIGxldCB5MiA9IHgyIC0gazI7XG4gICAgICBmb3IgKDsgeDIgPCB0ZXh0MUxlbmd0aCAmJiB5MiA8IHRleHQyTGVuZ3RoICYmIHRleHQxLmNoYXJBdCh0ZXh0MUxlbmd0aCAtIHgyIC0gMSkgPT09IHRleHQyLmNoYXJBdCh0ZXh0Mkxlbmd0aCAtIHkyIC0gMSk7IClcbiAgICAgICAgeDIrKywgeTIrKztcbiAgICAgIGlmICh2MltrMk9mZnNldF0gPSB4MiwgeDIgPiB0ZXh0MUxlbmd0aClcbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKHkyID4gdGV4dDJMZW5ndGgpXG4gICAgICAgIGsyc3RhcnQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKCFmcm9udCkge1xuICAgICAgICBjb25zdCBrMU9mZnNldCA9IHZPZmZzZXQgKyBkZWx0YSAtIGsyO1xuICAgICAgICBpZiAoazFPZmZzZXQgPj0gMCAmJiBrMU9mZnNldCA8IHZMZW5ndGggJiYgdjFbazFPZmZzZXRdICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHgxID0gdjFbazFPZmZzZXRdLCB5MSA9IHZPZmZzZXQgKyB4MSAtIGsxT2Zmc2V0O1xuICAgICAgICAgIGlmICh4MiA9IHRleHQxTGVuZ3RoIC0geDIsIHgxID49IHgyKVxuICAgICAgICAgICAgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xufVxuZnVuY3Rpb24gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4LCB5LCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCksIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KSwgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpLCB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSksIGRpZmZzID0gZG9EaWZmKHRleHQxYSwgdGV4dDJhLCB7XG4gICAgY2hlY2tMaW5lczogITEsXG4gICAgZGVhZGxpbmVcbiAgfSksIGRpZmZzYiA9IGRvRGlmZih0ZXh0MWIsIHRleHQyYiwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pO1xuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59XG5mdW5jdGlvbiBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mikge1xuICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogMSkgPD0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbG9uZ1RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydFRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBpZiAobG9uZ1RleHQubGVuZ3RoIDwgNCB8fCBzaG9ydFRleHQubGVuZ3RoICogMiA8IGxvbmdUZXh0Lmxlbmd0aClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgaGFsZk1hdGNoMSA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKSwgaGFsZk1hdGNoMiA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDIpKTtcbiAgbGV0IGhhbGZNYXRjaDtcbiAgaWYgKGhhbGZNYXRjaDEgJiYgaGFsZk1hdGNoMilcbiAgICBoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gxWzRdLmxlbmd0aCA+IGhhbGZNYXRjaDJbNF0ubGVuZ3RoID8gaGFsZk1hdGNoMSA6IGhhbGZNYXRjaDI7XG4gIGVsc2Uge1xuICAgIGlmICghaGFsZk1hdGNoMSAmJiAhaGFsZk1hdGNoMilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGhhbGZNYXRjaDIgPyBoYWxmTWF0Y2gxIHx8IChoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gyKSA6IGhhbGZNYXRjaCA9IGhhbGZNYXRjaDE7XG4gIH1cbiAgaWYgKCFoYWxmTWF0Y2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYSBoYWxmIG1hdGNoLlwiKTtcbiAgbGV0IHRleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQjtcbiAgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gKHRleHQxQSA9IGhhbGZNYXRjaFswXSwgdGV4dDFCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MkEgPSBoYWxmTWF0Y2hbMl0sIHRleHQyQiA9IGhhbGZNYXRjaFszXSkgOiAodGV4dDJBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbMV0sIHRleHQxQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDFCID0gaGFsZk1hdGNoWzNdKTtcbiAgY29uc3QgbWlkQ29tbW9uID0gaGFsZk1hdGNoWzRdO1xuICByZXR1cm4gW3RleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQiwgbWlkQ29tbW9uXTtcbn1cbmZ1bmN0aW9uIGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgaSkge1xuICBjb25zdCBzZWVkID0gbG9uZ1RleHQuc2xpY2UoaSwgaSArIE1hdGguZmxvb3IobG9uZ1RleHQubGVuZ3RoIC8gNCkpO1xuICBsZXQgaiA9IC0xLCBiZXN0Q29tbW9uID0gXCJcIiwgYmVzdExvbmdUZXh0QSwgYmVzdExvbmdUZXh0QiwgYmVzdFNob3J0VGV4dEEsIGJlc3RTaG9ydFRleHRCO1xuICBmb3IgKDsgKGogPSBzaG9ydFRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KGxvbmdUZXh0LnNsaWNlKGkpLCBzaG9ydFRleHQuc2xpY2UoaikpLCBzdWZmaXhMZW5ndGggPSBnZXRDb21tb25TdWZmaXgobG9uZ1RleHQuc2xpY2UoMCwgaSksIHNob3J0VGV4dC5zbGljZSgwLCBqKSk7XG4gICAgYmVzdENvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGggJiYgKGJlc3RDb21tb24gPSBzaG9ydFRleHQuc2xpY2UoaiAtIHN1ZmZpeExlbmd0aCwgaikgKyBzaG9ydFRleHQuc2xpY2UoaiwgaiArIHByZWZpeExlbmd0aCksIGJlc3RMb25nVGV4dEEgPSBsb25nVGV4dC5zbGljZSgwLCBpIC0gc3VmZml4TGVuZ3RoKSwgYmVzdExvbmdUZXh0QiA9IGxvbmdUZXh0LnNsaWNlKGkgKyBwcmVmaXhMZW5ndGgpLCBiZXN0U2hvcnRUZXh0QSA9IHNob3J0VGV4dC5zbGljZSgwLCBqIC0gc3VmZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEIgPSBzaG9ydFRleHQuc2xpY2UoaiArIHByZWZpeExlbmd0aCkpO1xuICB9XG4gIHJldHVybiBiZXN0Q29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ1RleHQubGVuZ3RoID8gW2Jlc3RMb25nVGV4dEEgfHwgXCJcIiwgYmVzdExvbmdUZXh0QiB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QSB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QiB8fCBcIlwiLCBiZXN0Q29tbW9uIHx8IFwiXCJdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBjaGFycyA9IGRpZmZzW3hdWzFdLCB0ZXh0ID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKylcbiAgICAgIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmVzVG9DaGFycyh0ZXh0QSwgdGV4dEIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW10sIGxpbmVIYXNoID0ge307XG4gIGxpbmVBcnJheVswXSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGRpZmZMaW5lc1RvTXVuZ2UodGV4dCkge1xuICAgIGxldCBjaGFycyA9IFwiXCIsIGxpbmVTdGFydCA9IDAsIGxpbmVFbmQgPSAtMSwgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDsgbGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMTsgKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKGBcbmAsIGxpbmVTdGFydCksIGxpbmVFbmQgPT09IC0xICYmIChsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkgPyBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKSA6IChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzICYmIChsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQpLCBsaW5lRW5kID0gdGV4dC5sZW5ndGgpLCBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCksIGxpbmVIYXNoW2xpbmVdID0gbGluZUFycmF5TGVuZ3RoLCBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZSksIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cbiAgbGV0IG1heExpbmVzID0gNGU0O1xuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb011bmdlKHRleHRBKTtcbiAgbWF4TGluZXMgPSA2NTUzNTtcbiAgY29uc3QgY2hhcnMyID0gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0Qik7XG4gIHJldHVybiB7XG4gICAgY2hhcnMxLFxuICAgIGNoYXJzMixcbiAgICBsaW5lQXJyYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvTGluZU1vZGVEaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgY29uc3QgYSA9IGxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICB0ZXh0MSA9IGEuY2hhcnMxLCB0ZXh0MiA9IGEuY2hhcnMyO1xuICBjb25zdCBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcbiAgbGV0IGRpZmZzID0gZG9EaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lOiBvcHRzLmRlYWRsaW5lXG4gIH0pO1xuICBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljKGRpZmZzKSwgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoY291bnREZWxldGUgPj0gMSAmJiBjb3VudEluc2VydCA+PSAxKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IGFhID0gZG9EaWZmKHRleHREZWxldGUsIHRleHRJbnNlcnQsIHtcbiAgICAgICAgICAgIGNoZWNrTGluZXM6ICExLFxuICAgICAgICAgICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gYWEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYWFbal0pO1xuICAgICAgICAgIHBvaW50ZXIgKz0gYWEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvbi5cIik7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICByZXR1cm4gZGlmZnMucG9wKCksIGRpZmZzO1xufVxuZnVuY3Rpb24gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRzKSB7XG4gIGxldCBkaWZmcztcbiAgaWYgKCF0ZXh0MSlcbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgaWYgKCF0ZXh0MilcbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgY29uc3QgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxLCBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPT0gLTEpXG4gICAgcmV0dXJuIGRpZmZzID0gW1tESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpXSwgW0RJRkZfRVFVQUwsIHNob3J0dGV4dF0sIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dLCB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggJiYgKGRpZmZzWzBdWzBdID0gRElGRl9ERUxFVEUsIGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEUpLCBkaWZmcztcbiAgaWYgKHNob3J0dGV4dC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBjb25zdCBoYWxmTWF0Y2ggPSBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChoYWxmTWF0Y2gpIHtcbiAgICBjb25zdCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10sIG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XSwgZGlmZnNBID0gZG9EaWZmKHRleHQxQSwgdGV4dDJBLCBvcHRzKSwgZGlmZnNCID0gZG9EaWZmKHRleHQxQiwgdGV4dDJCLCBvcHRzKTtcbiAgICByZXR1cm4gZGlmZnNBLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZENvbW1vbl1dLCBkaWZmc0IpO1xuICB9XG4gIHJldHVybiBvcHRzLmNoZWNrTGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCA/IGRvTGluZU1vZGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykgOiBiaXNlY3QodGV4dDEsIHRleHQyLCBvcHRzLmRlYWRsaW5lKTtcbn1cbmNvbnN0IERJRkZfREVMRVRFID0gLTEsIERJRkZfSU5TRVJUID0gMSwgRElGRl9FUVVBTCA9IDA7XG5mdW5jdGlvbiBkaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBpZiAodGV4dEEgPT09IG51bGwgfHwgdGV4dEIgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKGRpZmYpXCIpO1xuICBjb25zdCBkaWZmcyA9IGRvRGlmZih0ZXh0QSwgdGV4dEIsIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzIHx8IHt9KSk7XG4gIHJldHVybiBhZGp1c3REaWZmRm9yU3Vycm9nYXRlUGFpcnMoZGlmZnMpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGRvRGlmZih0ZXh0QSwgdGV4dEIsIG9wdGlvbnMpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpXG4gICAgcmV0dXJuIHRleHQxID8gW1tESUZGX0VRVUFMLCB0ZXh0MV1dIDogW107XG4gIGxldCBjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgY29uc3QgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgbGV0IGRpZmZzID0gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbW1vbnByZWZpeCAmJiBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKSwgY29tbW9uc3VmZml4ICYmIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pLCBkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVhZExpbmUodGltZW91dCkge1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB0eXBlb2YgdGltZW91dCA8IFwidVwiICYmICh0ID0gdGltZW91dCA8PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IHRpbWVvdXQpLCBEYXRlLm5vdygpICsgdCAqIDFlMztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgY2hlY2tMaW5lczogITAsXG4gICAgZGVhZGxpbmU6IGNyZWF0ZURlYWRMaW5lKG9wdHMudGltZW91dCB8fCAxKSxcbiAgICAuLi5vcHRzXG4gIH07XG59XG5mdW5jdGlvbiBjb21iaW5lQ2hhcihkYXRhLCBjaGFyLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRhdGEgKyBjaGFyIDogY2hhciArIGRhdGE7XG59XG5mdW5jdGlvbiBzcGxpdENoYXIoZGF0YSwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBbZGF0YS5zdWJzdHJpbmcoMCwgZGF0YS5sZW5ndGggLSAxKSwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdXSA6IFtkYXRhLnN1YnN0cmluZygxKSwgZGF0YVswXV07XG59XG5mdW5jdGlvbiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpLCBqLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRpZmZzW2ldWzFdW2RpZmZzW2ldWzFdLmxlbmd0aCAtIDFdID09PSBkaWZmc1tqXVsxXVtkaWZmc1tqXVsxXS5sZW5ndGggLSAxXSA6IGRpZmZzW2ldWzFdWzBdID09PSBkaWZmc1tqXVsxXVswXTtcbn1cbmZ1bmN0aW9uIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIGRpcikge1xuICBjb25zdCBpbnYgPSBkaXIgPT09IDEgPyAtMSA6IDE7XG4gIGxldCBpbnNlcnRJZHggPSBudWxsLCBkZWxldGVJZHggPSBudWxsLCBqID0gaSArIGRpcjtcbiAgZm9yICg7IGogPj0gMCAmJiBqIDwgZGlmZnMubGVuZ3RoICYmIChpbnNlcnRJZHggPT09IG51bGwgfHwgZGVsZXRlSWR4ID09PSBudWxsKTsgaiArPSBkaXIpIHtcbiAgICBjb25zdCBbb3AsIHRleHQyXSA9IGRpZmZzW2pdO1xuICAgIGlmICh0ZXh0Mi5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChvcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgaW5zZXJ0SWR4ID09PSBudWxsICYmIChpbnNlcnRJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICBkZWxldGVJZHggPT09IG51bGwgJiYgKGRlbGV0ZUlkeCA9IGopO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAob3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgaWYgKGluc2VydElkeCA9PT0gbnVsbCAmJiBkZWxldGVJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBbcmVzdCwgY2hhcjJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICAgICAgICAgIGRpZmZzW2ldWzFdID0gcmVzdCwgZGlmZnNbal1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tqXVsxXSwgY2hhcjIsIGludik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5zZXJ0SWR4ICE9PSBudWxsICYmIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpbnNlcnRJZHgsIGRlbGV0ZUlkeCwgZGlyKSkge1xuICAgIGNvbnN0IFtpbnNlcnRUZXh0MiwgaW5zZXJ0Q2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgaW52KSwgW2RlbGV0ZVRleHRdID0gc3BsaXRDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGludik7XG4gICAgZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGluc2VydFRleHQyLCBkaWZmc1tkZWxldGVJZHhdWzFdID0gZGVsZXRlVGV4dCwgZGlmZnNbaV1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tpXVsxXSwgaW5zZXJ0Q2hhciwgZGlyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW3RleHQsIGNoYXJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICBkaWZmc1tpXVsxXSA9IHRleHQsIGluc2VydElkeCA9PT0gbnVsbCA/IChkaWZmcy5zcGxpY2UoaiwgMCwgW0RJRkZfSU5TRVJULCBjaGFyXSksIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggPj0gaiAmJiBkZWxldGVJZHgrKykgOiBkaWZmc1tpbnNlcnRJZHhdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgY2hhciwgaW52KSwgZGVsZXRlSWR4ID09PSBudWxsID8gZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0RFTEVURSwgY2hhcl0pIDogZGlmZnNbZGVsZXRlSWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGNoYXIsIGludik7XG59XG5mdW5jdGlvbiBhZGp1c3REaWZmRm9yU3Vycm9nYXRlUGFpcnMoZGlmZnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtkaWZmVHlwZSwgZGlmZlRleHRdID0gZGlmZnNbaV07XG4gICAgaWYgKGRpZmZUZXh0Lmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgY29uc3QgZmlyc3RDaGFyID0gZGlmZlRleHRbMF0sIGxhc3RDaGFyID0gZGlmZlRleHRbZGlmZlRleHQubGVuZ3RoIC0gMV07XG4gICAgaXNIaWdoU3Vycm9nYXRlKGxhc3RDaGFyKSAmJiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCAxKSwgaXNMb3dTdXJyb2dhdGUoZmlyc3RDaGFyKSAmJiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCAtMSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKylcbiAgICBkaWZmc1tpXVsxXS5sZW5ndGggPT09IDAgJiYgZGlmZnMuc3BsaWNlKGksIDEpO1xufVxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAvKipcbiAgICogQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSkuXG4gICAqL1xuICB0aHJlc2hvbGQ6IDAuNSxcbiAgLyoqXG4gICAqIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAgKiBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgICogMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gICAqL1xuICBkaXN0YW5jZTogMWUzXG59O1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbn1cbmNvbnN0IE1BWF9CSVRTJDEgPSAzMjtcbmZ1bmN0aW9uIGJpdGFwKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzNdIDoge307XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTJDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLlwiKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob3B0cyksIHMgPSBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pO1xuICBmdW5jdGlvbiBnZXRCaXRhcFNjb3JlKGUsIHgpIHtcbiAgICBjb25zdCBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuLmxlbmd0aCwgcHJveGltaXR5ID0gTWF0aC5hYnMobG9jIC0geCk7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGlzdGFuY2UgPyBhY2N1cmFjeSArIHByb3hpbWl0eSAvIG9wdGlvbnMuZGlzdGFuY2UgOiBwcm94aW1pdHkgPyAxIDogYWNjdXJhY3k7XG4gIH1cbiAgbGV0IHNjb3JlVGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQsIGJlc3RMb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgbG9jKTtcbiAgYmVzdExvYyAhPT0gLTEgJiYgKHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4oZ2V0Qml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpLCBiZXN0TG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCksIGJlc3RMb2MgIT09IC0xICYmIChzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKGdldEJpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKSkpO1xuICBjb25zdCBtYXRjaG1hc2sgPSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gMTtcbiAgYmVzdExvYyA9IC0xO1xuICBsZXQgYmluTWluLCBiaW5NaWQsIGJpbk1heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGgsIGxhc3RSZCA9IFtdO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcbiAgICBmb3IgKGJpbk1pbiA9IDAsIGJpbk1pZCA9IGJpbk1heDsgYmluTWluIDwgYmluTWlkOyApXG4gICAgICBnZXRCaXRhcFNjb3JlKGQsIGxvYyArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQgPyBiaW5NaW4gPSBiaW5NaWQgOiBiaW5NYXggPSBiaW5NaWQsIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluTWlkICsgMSk7XG4gICAgY29uc3QgZmluaXNoID0gTWF0aC5taW4obG9jICsgYmluTWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aCwgcmQgPSBuZXcgQXJyYXkoZmluaXNoICsgMik7XG4gICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICBjb25zdCBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCA/IHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggOiByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoIHwgKChsYXN0UmRbaiArIDFdIHwgbGFzdFJkW2pdKSA8PCAxIHwgMSkgfCBsYXN0UmRbaiArIDFdLCByZFtqXSAmIG1hdGNobWFzaykge1xuICAgICAgICBjb25zdCBzY29yZSA9IGdldEJpdGFwU2NvcmUoZCwgaiAtIDEpO1xuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVUaHJlc2hvbGQpXG4gICAgICAgICAgaWYgKHNjb3JlVGhyZXNob2xkID0gc2NvcmUsIGJlc3RMb2MgPSBqIC0gMSwgYmVzdExvYyA+IGxvYylcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RMb2MpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0Qml0YXBTY29yZShkICsgMSwgbG9jKSA+IHNjb3JlVGhyZXNob2xkKVxuICAgICAgYnJlYWs7XG4gICAgbGFzdFJkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RMb2M7XG59XG5mdW5jdGlvbiBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pIHtcbiAgY29uc3QgcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG1hdGNoKHRleHQsIHBhdHRlcm4sIHNlYXJjaExvY2F0aW9uKSB7XG4gIGlmICh0ZXh0ID09PSBudWxsIHx8IHBhdHRlcm4gPT09IG51bGwgfHwgc2VhcmNoTG9jYXRpb24gPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoKCkpXCIpO1xuICBjb25zdCBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWFyY2hMb2NhdGlvbiwgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT09IHBhdHRlcm4pXG4gICAgcmV0dXJuIDA7XG4gIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgIGlmICh0ZXh0LnN1YnN0cmluZyhsb2MsIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSA9PT0gcGF0dGVybilcbiAgICAgIHJldHVybiBsb2M7XG4gIH0gZWxzZSByZXR1cm4gLTE7XG4gIHJldHVybiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hPYmplY3Qoc3RhcnQxLCBzdGFydDIpIHtcbiAgcmV0dXJuIHtcbiAgICBkaWZmczogW10sXG4gICAgc3RhcnQxLFxuICAgIHN0YXJ0MixcbiAgICB1dGY4U3RhcnQxOiBzdGFydDEsXG4gICAgdXRmOFN0YXJ0Mjogc3RhcnQyLFxuICAgIGxlbmd0aDE6IDAsXG4gICAgbGVuZ3RoMjogMCxcbiAgICB1dGY4TGVuZ3RoMTogMCxcbiAgICB1dGY4TGVuZ3RoMjogMFxuICB9O1xufVxuZnVuY3Rpb24gZGlmZlRleHQxKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKylcbiAgICBkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQgJiYgKHRleHRbeF0gPSBkaWZmc1t4XVsxXSk7XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBkaWZmVGV4dDIoZGlmZnMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKVxuICAgIGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSAmJiAodGV4dFt4XSA9IGRpZmZzW3hdWzFdKTtcbiAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGNvdW50VXRmOEJ5dGVzKHN0cikge1xuICBsZXQgYnl0ZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICBpZiAodHlwZW9mIGNvZGVQb2ludCA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBjb2RlcG9pbnRcIik7XG4gICAgYnl0ZXMgKz0gdXRmOGxlbihjb2RlUG9pbnQpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGFkanVzdEluZGljaWVzVG9VY3MyKHBhdGNoZXMsIGJhc2UpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9LCBieXRlT2Zmc2V0ID0gMCwgaWR4ID0gMDtcbiAgZnVuY3Rpb24gYWR2YW5jZVRvKHRhcmdldCkge1xuICAgIGZvciAoOyBieXRlT2Zmc2V0IDwgdGFyZ2V0OyApIHtcbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGJhc2UuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpXG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgICBieXRlT2Zmc2V0ICs9IHV0ZjhsZW4oY29kZVBvaW50KSwgY29kZVBvaW50ID4gNjU1MzUgPyBpZHggKz0gMiA6IGlkeCArPSAxO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dFeGNlZWRpbmdJbmRpY2VzICYmIGJ5dGVPZmZzZXQgIT09IHRhcmdldClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZXRlcm1pbmUgYnl0ZSBvZmZzZXRcIik7XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuICBjb25zdCBhZGp1c3RlZCA9IFtdO1xuICBmb3IgKGNvbnN0IHBhdGNoIG9mIHBhdGNoZXMpXG4gICAgYWRqdXN0ZWQucHVzaCh7XG4gICAgICBkaWZmczogcGF0Y2guZGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksXG4gICAgICBzdGFydDE6IGFkdmFuY2VUbyhwYXRjaC5zdGFydDEpLFxuICAgICAgc3RhcnQyOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQyKSxcbiAgICAgIHV0ZjhTdGFydDE6IHBhdGNoLnV0ZjhTdGFydDEsXG4gICAgICB1dGY4U3RhcnQyOiBwYXRjaC51dGY4U3RhcnQyLFxuICAgICAgbGVuZ3RoMTogcGF0Y2gubGVuZ3RoMSxcbiAgICAgIGxlbmd0aDI6IHBhdGNoLmxlbmd0aDIsXG4gICAgICB1dGY4TGVuZ3RoMTogcGF0Y2gudXRmOExlbmd0aDEsXG4gICAgICB1dGY4TGVuZ3RoMjogcGF0Y2gudXRmOExlbmd0aDJcbiAgICB9KTtcbiAgcmV0dXJuIGFkanVzdGVkO1xufVxuZnVuY3Rpb24gdXRmOGxlbihjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA8PSAxMjcgPyAxIDogY29kZVBvaW50IDw9IDIwNDcgPyAyIDogY29kZVBvaW50IDw9IDY1NTM1ID8gMyA6IDQ7XG59XG5jb25zdCBNQVhfQklUUyA9IDMyLCBERUZBVUxUX01BUkdJTiA9IDQ7XG5mdW5jdGlvbiBsZXZlbnNodGVpbihkaWZmcykge1xuICBsZXQgbGV2ZW4gPSAwLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IG9wID0gZGlmZnNbeF1bMF0sIGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGluc2VydGlvbnMgPSAwLCBkZWxldGlvbnMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiBvcGVyYXRpb24uXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV2ZW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKSwgbGV2ZW47XG59XG5mdW5jdGlvbiB4SW5kZXgoZGlmZnMsIGxvYykge1xuICBsZXQgY2hhcnMxID0gMCwgY2hhcnMyID0gMCwgbGFzdENoYXJzMSA9IDAsIGxhc3RDaGFyczIgPSAwLCB4O1xuICBmb3IgKHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoICYmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQgJiYgKGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGgpLCBkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUgJiYgKGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGgpLCAhKGNoYXJzMSA+IGxvYykpOyB4KyspXG4gICAgbGFzdENoYXJzMSA9IGNoYXJzMSwgbGFzdENoYXJzMiA9IGNoYXJzMjtcbiAgcmV0dXJuIGRpZmZzLmxlbmd0aCAhPT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUgPyBsYXN0Q2hhcnMyIDogbGFzdENoYXJzMiArIChsb2MgLSBsYXN0Q2hhcnMxKTtcbn1cbmZ1bmN0aW9uIGFkZFBhZGRpbmcocGF0Y2hlcykge1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX01BUkdJTjtcbiAgbGV0IG51bGxQYWRkaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKVxuICAgIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gIGZvciAoY29uc3QgcCBvZiBwYXRjaGVzKVxuICAgIHAuc3RhcnQxICs9IHBhZGRpbmdMZW5ndGgsIHAuc3RhcnQyICs9IHBhZGRpbmdMZW5ndGgsIHAudXRmOFN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgbGV0IHBhdGNoID0gcGF0Y2hlc1swXSwgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRElGRl9FUVVBTClcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pLCBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2guc3RhcnQyIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDEgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpcnN0RGlmZkxlbmd0aCA9IGRpZmZzWzBdWzFdLmxlbmd0aCwgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZmlyc3REaWZmTGVuZ3RoO1xuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGZpcnN0RGlmZkxlbmd0aCkgKyBkaWZmc1swXVsxXSwgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5zdGFydDIgLT0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDEgLT0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gZXh0cmFMZW5ndGgsIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICBpZiAocGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV0sIGRpZmZzID0gcGF0Y2guZGlmZnMsIGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPT0gRElGRl9FUVVBTClcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pLCBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIGNvbnN0IGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSArPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoMCwgZXh0cmFMZW5ndGgpLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufVxuZnVuY3Rpb24gc3BsaXRNYXgocGF0Y2hlcykge1xuICBsZXQgbWFyZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX01BUkdJTjtcbiAgY29uc3QgcGF0Y2hTaXplID0gTUFYX0JJVFM7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChwYXRjaGVzW3hdLmxlbmd0aDEgPD0gcGF0Y2hTaXplKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgYmlncGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XG4gICAgbGV0IHN0YXJ0MSA9IGJpZ3BhdGNoLnN0YXJ0MSwgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyLCBwcmVDb250ZXh0ID0gXCJcIjtcbiAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwOyApIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2hPYmplY3Qoc3RhcnQxIC0gcHJlQ29udGV4dC5sZW5ndGgsIHN0YXJ0MiAtIHByZUNvbnRleHQubGVuZ3RoKTtcbiAgICAgIGxldCBlbXB0eSA9ICEwO1xuICAgICAgaWYgKHByZUNvbnRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgY29uc3QgcHJlY29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHByZUNvbnRleHQpO1xuICAgICAgICBwYXRjaC5sZW5ndGgxID0gcHJlQ29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxID0gcHJlY29udGV4dEJ5dGVDb3VudCwgcGF0Y2gubGVuZ3RoMiA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHByZUNvbnRleHRdKTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiYgcGF0Y2gubGVuZ3RoMSA8IHBhdGNoU2l6ZSAtIG1hcmdpbjsgKSB7XG4gICAgICAgIGNvbnN0IGRpZmZUeXBlID0gYmlncGF0Y2guZGlmZnNbMF1bMF07XG4gICAgICAgIGxldCBkaWZmVGV4dCA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KTtcbiAgICAgICAgaWYgKGRpZmZUeXBlID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQyICs9IGRpZmZUZXh0Lmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBkaWZmMiA9IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgICAgZGlmZjIgJiYgcGF0Y2guZGlmZnMucHVzaChkaWZmMiksIGVtcHR5ID0gITE7XG4gICAgICAgIH0gZWxzZSBkaWZmVHlwZSA9PT0gRElGRl9ERUxFVEUgJiYgcGF0Y2guZGlmZnMubGVuZ3RoID09PSAxICYmIHBhdGNoLmRpZmZzWzBdWzBdID09PSBESUZGX0VRVUFMICYmIGRpZmZUZXh0Lmxlbmd0aCA+IDIgKiBwYXRjaFNpemUgPyAocGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBlbXB0eSA9ICExLCBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmVHlwZSwgZGlmZlRleHRdKSwgYmlncGF0Y2guZGlmZnMuc2hpZnQoKSkgOiAoZGlmZlRleHQgPSBkaWZmVGV4dC5zdWJzdHJpbmcoMCwgcGF0Y2hTaXplIC0gcGF0Y2gubGVuZ3RoMSAtIG1hcmdpbiksIGRpZmZUZXh0Qnl0ZUNvdW50ID0gY291bnRVdGY4Qnl0ZXMoZGlmZlRleHQpLCBwYXRjaC5sZW5ndGgxICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MSArPSBkaWZmVGV4dC5sZW5ndGgsIGRpZmZUeXBlID09PSBESUZGX0VRVUFMID8gKHBhdGNoLmxlbmd0aDIgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQyICs9IGRpZmZUZXh0Lmxlbmd0aCkgOiBlbXB0eSA9ICExLCBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmVHlwZSwgZGlmZlRleHRdKSwgZGlmZlRleHQgPT09IGJpZ3BhdGNoLmRpZmZzWzBdWzFdID8gYmlncGF0Y2guZGlmZnMuc2hpZnQoKSA6IGJpZ3BhdGNoLmRpZmZzWzBdWzFdID0gYmlncGF0Y2guZGlmZnNbMF1bMV0uc3Vic3RyaW5nKGRpZmZUZXh0Lmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgcHJlQ29udGV4dCA9IGRpZmZUZXh0MihwYXRjaC5kaWZmcyksIHByZUNvbnRleHQgPSBwcmVDb250ZXh0LnN1YnN0cmluZyhwcmVDb250ZXh0Lmxlbmd0aCAtIG1hcmdpbik7XG4gICAgICBjb25zdCBwb3N0Q29udGV4dCA9IGRpZmZUZXh0MShiaWdwYXRjaC5kaWZmcykuc3Vic3RyaW5nKDAsIG1hcmdpbiksIHBvc3RDb250ZXh0Qnl0ZUNvdW50ID0gY291bnRVdGY4Qnl0ZXMocG9zdENvbnRleHQpO1xuICAgICAgcG9zdENvbnRleHQgIT09IFwiXCIgJiYgKHBhdGNoLmxlbmd0aDEgKz0gcG9zdENvbnRleHQubGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gcG9zdENvbnRleHRCeXRlQ291bnQsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiYgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgPyBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVsxXSArPSBwb3N0Q29udGV4dCA6IHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHBvc3RDb250ZXh0XSkpLCBlbXB0eSB8fCBwYXRjaGVzLnNwbGljZSgrK3gsIDAsIHBhdGNoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5KHBhdGNoZXMsIG9yaWdpbmFsVGV4dCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gIGlmICh0eXBlb2YgcGF0Y2hlcyA9PSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGNoZXMgbXVzdCBiZSBhbiBhcnJheSAtIHBhc3MgdGhlIHBhdGNoIHRvIGBwYXJzZVBhdGNoKClgIGZpcnN0XCIpO1xuICBsZXQgdGV4dCA9IG9yaWdpbmFsVGV4dDtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbdGV4dCwgW11dO1xuICBjb25zdCBwYXJzZWQgPSBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCB0ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiBvcHRzLmFsbG93RXhjZWVkaW5nSW5kaWNlc1xuICB9KSwgbWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgREVGQVVMVF9NQVJHSU4sIGRlbGV0ZVRocmVzaG9sZCA9IG9wdHMuZGVsZXRlVGhyZXNob2xkIHx8IDAuNCwgbnVsbFBhZGRpbmcgPSBhZGRQYWRkaW5nKHBhcnNlZCwgbWFyZ2luKTtcbiAgdGV4dCA9IG51bGxQYWRkaW5nICsgdGV4dCArIG51bGxQYWRkaW5nLCBzcGxpdE1heChwYXJzZWQsIG1hcmdpbik7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXJzZWQubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBleHBlY3RlZExvYyA9IHBhcnNlZFt4XS5zdGFydDIgKyBkZWx0YSwgdGV4dDEgPSBkaWZmVGV4dDEocGFyc2VkW3hdLmRpZmZzKTtcbiAgICBsZXQgc3RhcnRMb2MsIGVuZExvYyA9IC0xO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyA/IChzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLnN1YnN0cmluZygwLCBNQVhfQklUUyksIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgIT09IC0xICYmIChlbmRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gTUFYX0JJVFMpLCBleHBlY3RlZExvYyArIHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgKGVuZExvYyA9PT0gLTEgfHwgc3RhcnRMb2MgPj0gZW5kTG9jKSAmJiAoc3RhcnRMb2MgPSAtMSkpKSA6IHN0YXJ0TG9jID0gbWF0Y2godGV4dCwgdGV4dDEsIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgPT09IC0xKVxuICAgICAgcmVzdWx0c1t4XSA9ICExLCBkZWx0YSAtPSBwYXJzZWRbeF0ubGVuZ3RoMiAtIHBhcnNlZFt4XS5sZW5ndGgxO1xuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0c1t4XSA9ICEwLCBkZWx0YSA9IHN0YXJ0TG9jIC0gZXhwZWN0ZWRMb2M7XG4gICAgICBsZXQgdGV4dDI7XG4gICAgICBpZiAoZW5kTG9jID09PSAtMSA/IHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MsIHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKSA6IHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MsIGVuZExvYyArIE1BWF9CSVRTKSwgdGV4dDEgPT09IHRleHQyKVxuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MpICsgZGlmZlRleHQyKHBhcnNlZFt4XS5kaWZmcykgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGRpZmZzID0gZGlmZih0ZXh0MSwgdGV4dDIsIHtcbiAgICAgICAgICBjaGVja0xpbmVzOiAhMVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IE1BWF9CSVRTICYmIGxldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+IGRlbGV0ZVRocmVzaG9sZClcbiAgICAgICAgICByZXN1bHRzW3hdID0gITE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIGxldCBpbmRleDEgPSAwLCBpbmRleDIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcGFyc2VkW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXJzZWRbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBtb2RbMF0gIT09IERJRkZfRVFVQUwgJiYgKGluZGV4MiA9IHhJbmRleChkaWZmcywgaW5kZXgxKSksIG1vZFswXSA9PT0gRElGRl9JTlNFUlQgPyB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyBpbmRleDIpIDogbW9kWzBdID09PSBESUZGX0RFTEVURSAmJiAodGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgeEluZGV4KGRpZmZzLCBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSkpLCBtb2RbMF0gIT09IERJRkZfREVMRVRFICYmIChpbmRleDEgKz0gbW9kWzFdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCksIFt0ZXh0LCByZXN1bHRzXTtcbn1cbmNvbnN0IHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcbmZ1bmN0aW9uIHBhcnNlKHRleHRsaW5lKSB7XG4gIGlmICghdGV4dGxpbmUpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBwYXRjaGVzID0gW10sIGxpbmVzID0gdGV4dGxpbmUuc3BsaXQoYFxuYCk7XG4gIGxldCB0ZXh0UG9pbnRlciA9IDA7XG4gIGZvciAoOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbSA9IGxpbmVzW3RleHRQb2ludGVyXS5tYXRjaChwYXRjaEhlYWRlcik7XG4gICAgaWYgKCFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRjaCBzdHJpbmc6IFwiLmNvbmNhdChsaW5lc1t0ZXh0UG9pbnRlcl0pKTtcbiAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHRvSW50KG1bMV0pLCB0b0ludChtWzNdKSk7XG4gICAgZm9yIChwYXRjaGVzLnB1c2gocGF0Y2gpLCBtWzJdID09PSBcIlwiID8gKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLmxlbmd0aDEgPSAxLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDEpIDogbVsyXSA9PT0gXCIwXCIgPyAocGF0Y2gubGVuZ3RoMSA9IDAsIHBhdGNoLnV0ZjhMZW5ndGgxID0gMCkgOiAocGF0Y2guc3RhcnQxLS0sIHBhdGNoLnV0ZjhTdGFydDEtLSwgcGF0Y2gudXRmOExlbmd0aDEgPSB0b0ludChtWzJdKSwgcGF0Y2gubGVuZ3RoMSA9IHBhdGNoLnV0ZjhMZW5ndGgxKSwgbVs0XSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC5sZW5ndGgyID0gMSwgcGF0Y2gudXRmOExlbmd0aDIgPSAxKSA6IG1bNF0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDIgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMiA9IDApIDogKHBhdGNoLnN0YXJ0Mi0tLCBwYXRjaC51dGY4U3RhcnQyLS0sIHBhdGNoLnV0ZjhMZW5ndGgyID0gdG9JbnQobVs0XSksIHBhdGNoLmxlbmd0aDIgPSBwYXRjaC51dGY4TGVuZ3RoMiksIHRleHRQb2ludGVyKys7IHRleHRQb2ludGVyIDwgbGluZXMubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gbGluZXNbdGV4dFBvaW50ZXJdLCBzaWduID0gY3VycmVudExpbmUuY2hhckF0KDApO1xuICAgICAgaWYgKHNpZ24gPT09IFwiQFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChzaWduID09PSBcIlwiKSB7XG4gICAgICAgIHRleHRQb2ludGVyKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGxpbmU7XG4gICAgICB0cnkge1xuICAgICAgICBsaW5lID0gZGVjb2RlVVJJKGN1cnJlbnRMaW5lLnNsaWNlKDEpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGVzY2FwZSBpbiBwYXJzZTogXCIuY29uY2F0KGN1cnJlbnRMaW5lKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB1dGY4RGlmZiA9IGNvdW50VXRmOEJ5dGVzKGxpbmUpIC0gbGluZS5sZW5ndGg7XG4gICAgICBpZiAoc2lnbiA9PT0gXCItXCIpXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfREVMRVRFLCBsaW5lXSksIHBhdGNoLmxlbmd0aDEgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlIGlmIChzaWduID09PSBcIitcIilcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9JTlNFUlQsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMiAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiIFwiKVxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBsaW5lXSksIHBhdGNoLmxlbmd0aDEgLT0gdXRmOERpZmYsIHBhdGNoLmxlbmd0aDIgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBtb2RlIFwiJy5jb25jYXQoc2lnbiwgJ1wiIGluOiAnKS5jb25jYXQobGluZSkpO1xuICAgICAgdGV4dFBvaW50ZXIrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiB0b0ludChudW0pIHtcbiAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTApO1xufVxuY29uc3QgZGVidWckaSA9IGRlYnVnV2l0aE5hbWUoXCJhcHBseVBhdGNoZXNcIiksIGRlYnVnVmVyYm9zZSQ0ID0gZGVidWckaS5lbmFibGVkICYmICEwO1xuZnVuY3Rpb24gY3JlYXRlQXBwbHlQYXRjaChzY2hlbWFUeXBlcykge1xuICByZXR1cm4gKGVkaXRvciwgcGF0Y2gpID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgIGRlYnVnVmVyYm9zZSQ0ICYmIChkZWJ1ZyRpKGBcblxuTkVXIFBBVENIID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1gKSwgZGVidWckaShKU09OLnN0cmluZ2lmeShwYXRjaCwgbnVsbCwgMikpKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChwYXRjaC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gaW5zZXJ0UGF0Y2goZWRpdG9yLCBwYXRjaCwgc2NoZW1hVHlwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidW5zZXRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gdW5zZXRQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSBzZXRQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpZmZNYXRjaFBhdGNoXCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGRpZmZNYXRjaFBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlYnVnJGkoXCJVbmhhbmRsZWQgcGF0Y2hcIiwgcGF0Y2gudHlwZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBjb25zdCB7XG4gICAgYmxvY2ssXG4gICAgY2hpbGQsXG4gICAgY2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIGRlYnVnJGkoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICBpZiAoIWNoaWxkIHx8ICFjaGlsZFBhdGgpXG4gICAgcmV0dXJuIGRlYnVnJGkoXCJDaGlsZCBub3QgZm91bmRcIiksICExO1xuICBpZiAoIShibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSA0ICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoWzNdID09PSBcInRleHRcIikgfHwgIVRleHQuaXNUZXh0KGNoaWxkKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHBhdGNoZXMgPSBwYXJzZShwYXRjaC52YWx1ZSksIFtuZXdWYWx1ZV0gPSBhcHBseShwYXRjaGVzLCBjaGlsZC50ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiAhMFxuICB9KSwgZGlmZiQxID0gY2xlYW51cEVmZmljaWVuY3koZGlmZihjaGlsZC50ZXh0LCBuZXdWYWx1ZSksIDUpO1xuICBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIik7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IFtvcCwgdGV4dF0gb2YgZGlmZiQxKVxuICAgIG9wID09PSBESUZGX0lOU0VSVCA/IChlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGV4dFxuICAgIH0pLCBvZmZzZXQgKz0gdGV4dC5sZW5ndGgpIDogb3AgPT09IERJRkZfREVMRVRFID8gZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwicmVtb3ZlX3RleHRcIixcbiAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRleHRcbiAgICB9KSA6IG9wID09PSBESUZGX0VRVUFMICYmIChvZmZzZXQgKz0gdGV4dC5sZW5ndGgpO1xuICByZXR1cm4gZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xufVxuZnVuY3Rpb24gaW5zZXJ0UGF0Y2goZWRpdG9yLCBwYXRjaCwgc2NoZW1hVHlwZXMpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrOiB0YXJnZXRCbG9jayxcbiAgICBjaGlsZDogdGFyZ2V0Q2hpbGQsXG4gICAgYmxvY2tQYXRoOiB0YXJnZXRCbG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiB0YXJnZXRDaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCF0YXJnZXRCbG9jayB8fCAhdGFyZ2V0QmxvY2tQYXRoKVxuICAgIHJldHVybiBkZWJ1ZyRpKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMSAmJiBwYXRjaC5wYXRoWzFdICE9PSBcImNoaWxkcmVuXCIpXG4gICAgcmV0dXJuIGRlYnVnJGkoXCJJZ25vcmluZyBwYXRjaCB0YXJnZXRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1zOiBpdGVtczIsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24yXG4gICAgfSA9IHBhdGNoLCBibG9ja3NUb0luc2VydCA9IHRvU2xhdGVWYWx1ZShpdGVtczIsIHtcbiAgICAgIHNjaGVtYVR5cGVzXG4gICAgfSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCB0YXJnZXRCbG9ja0luZGV4ID0gdGFyZ2V0QmxvY2tQYXRoWzBdLCBub3JtYWxpemVkSWR4MiA9IHBvc2l0aW9uMiA9PT0gXCJhZnRlclwiID8gdGFyZ2V0QmxvY2tJbmRleCArIDEgOiB0YXJnZXRCbG9ja0luZGV4O1xuICAgIHJldHVybiBkZWJ1ZyRpKGBJbnNlcnRpbmcgYmxvY2tzIGF0IHBhdGggWyR7bm9ybWFsaXplZElkeDJ9XWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBibG9ja3NUb0luc2VydCwge1xuICAgICAgYXQ6IFtub3JtYWxpemVkSWR4Ml1cbiAgICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpdGVtcyxcbiAgICBwb3NpdGlvblxuICB9ID0gcGF0Y2g7XG4gIGlmICghdGFyZ2V0Q2hpbGQgfHwgIXRhcmdldENoaWxkUGF0aClcbiAgICByZXR1cm4gZGVidWckaShcIkNoaWxkIG5vdCBmb3VuZFwiKSwgITE7XG4gIGNvbnN0IGNoaWxkcmVuVG9JbnNlcnQgPSB0YXJnZXRCbG9jayAmJiB0b1NsYXRlVmFsdWUoW3tcbiAgICAuLi50YXJnZXRCbG9jayxcbiAgICBjaGlsZHJlbjogaXRlbXNcbiAgfV0sIHtcbiAgICBzY2hlbWFUeXBlc1xuICB9LCBLRVlfVE9fU0xBVEVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIHRhcmdldENoaWxkSW5kZXggPSB0YXJnZXRDaGlsZFBhdGhbMV0sIG5vcm1hbGl6ZWRJZHggPSBwb3NpdGlvbiA9PT0gXCJhZnRlclwiID8gdGFyZ2V0Q2hpbGRJbmRleCArIDEgOiB0YXJnZXRDaGlsZEluZGV4LCBjaGlsZEluc2VydFBhdGggPSBbdGFyZ2V0Q2hpbGRQYXRoWzBdLCBub3JtYWxpemVkSWR4XTtcbiAgcmV0dXJuIGRlYnVnJGkoYEluc2VydGluZyBjaGlsZHJlbiBhdCBwYXRoICR7Y2hpbGRJbnNlcnRQYXRofWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGNoaWxkcmVuVG9JbnNlcnQgJiYgRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZHJlblRvSW5zZXJ0WzBdKSAmJiBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGRyZW5Ub0luc2VydFswXS5jaGlsZHJlbiwge1xuICAgIGF0OiBjaGlsZEluc2VydFBhdGhcbiAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIHNldFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgbGV0IHZhbHVlID0gcGF0Y2gudmFsdWU7XG4gIHR5cGVvZiBwYXRjaC5wYXRoWzNdID09IFwic3RyaW5nXCIgJiYgKHZhbHVlID0ge30sIHZhbHVlW3BhdGNoLnBhdGhbM11dID0gcGF0Y2gudmFsdWUpO1xuICBjb25zdCB7XG4gICAgYmxvY2ssXG4gICAgYmxvY2tQYXRoLFxuICAgIGNoaWxkLFxuICAgIGNoaWxkUGF0aFxuICB9ID0gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGNoLnBhdGgpO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBkZWJ1ZyRpKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgY29uc3QgaXNUZXh0QmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spO1xuICBpZiAoaXNUZXh0QmxvY2sgJiYgcGF0Y2gucGF0aC5sZW5ndGggPiAxICYmIHBhdGNoLnBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIilcbiAgICByZXR1cm4gZGVidWckaShcIklnbm9yaW5nIHNldHRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGlzVGV4dEJsb2NrICYmIGNoaWxkICYmIGNoaWxkUGF0aCkge1xuICAgIGlmIChUZXh0LmlzVGV4dCh2YWx1ZSkgJiYgVGV4dC5pc1RleHQoY2hpbGQpKSB7XG4gICAgICBjb25zdCBuZXdUZXh0ID0gY2hpbGQudGV4dDtcbiAgICAgIHZhbHVlLnRleHQgIT09IG5ld1RleHQgJiYgKGRlYnVnJGkoXCJTZXR0aW5nIHRleHQgcHJvcGVydHlcIiksIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlX3RleHRcIixcbiAgICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgIH0pLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcImluc2VydF90ZXh0XCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0OiB2YWx1ZS50ZXh0XG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgIH0gZWxzZVxuICAgICAgZGVidWckaShcIlNldHRpbmcgbm9uLXRleHQgcHJvcGVydHlcIiksIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwic2V0X25vZGVcIixcbiAgICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgbmV3UHJvcGVydGllczogdmFsdWVcbiAgICAgIH0pO1xuICAgIHJldHVybiAhMDtcbiAgfSBlbHNlIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBibG9ja1BhdGgpIHtcbiAgICBkZWJ1ZyRpKFwiU2V0dGluZyBibG9jayBwcm9wZXJ0eVwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLm5leHRSZXN0XG4gICAgfSA9IHZhbHVlLCB7XG4gICAgICBjaGlsZHJlbjogcHJldkNoaWxkcmVuLFxuICAgICAgLi4ucHJldlJlc3RcbiAgICB9ID0gYmxvY2sgfHwge1xuICAgICAgY2hpbGRyZW46IHZvaWQgMFxuICAgIH07XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwic2V0X25vZGVcIixcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLi4ucHJldlJlc3RcbiAgICAgIH0sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXh0UmVzdFxuICAgIH0pLCBkZWJ1ZyRpKFwiU2V0dGluZyBjaGlsZHJlblwiKSwgYmxvY2suY2hpbGRyZW4uZm9yRWFjaCgoYzIsIGNJbmRleCkgPT4ge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfbm9kZVwiLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGguY29uY2F0KGJsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDEgLSBjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSksIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmZvckVhY2goKGMyLCBjSW5kZXgpID0+IHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwiaW5zZXJ0X25vZGVcIixcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLmNvbmNhdChjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYmxvY2sgJiYgXCJ2YWx1ZVwiIGluIGJsb2NrKSB7XG4gICAgY29uc3QgbmV3VmFsID0gYXBwbHlBbGwoW2Jsb2NrLnZhbHVlXSwgW3BhdGNoXSlbMF07XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAuLi5ibG9jayxcbiAgICAgIHZhbHVlOiBuZXdWYWxcbiAgICB9LCB7XG4gICAgICBhdDogYmxvY2tQYXRoXG4gICAgfSksICEwO1xuICB9XG4gIHJldHVybiBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG59XG5mdW5jdGlvbiB1bnNldFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgZGVidWckaShcIlJlbW92aW5nIGV2ZXJ5dGhpbmdcIiksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKTtcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmNoaWxkcmVuLmZvckVhY2goKF9jaGlsZCwgaSkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtpXVxuICAgICAgfSk7XG4gICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgfSkpLCBwcmV2aW91c1NlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSksIGVkaXRvci5vbkNoYW5nZSgpLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZCxcbiAgICBjaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCFibG9jayB8fCAhYmxvY2tQYXRoKVxuICAgICAgcmV0dXJuIGRlYnVnJGkoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICAgIGNvbnN0IGJsb2NrSW5kZXggPSBibG9ja1BhdGhbMF07XG4gICAgcmV0dXJuIGRlYnVnJGkoYFJlbW92aW5nIGJsb2NrIGF0IHBhdGggWyR7YmxvY2tJbmRleH1dYCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbYmxvY2tJbmRleF1cbiAgICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMyA/ICFjaGlsZCB8fCAhY2hpbGRQYXRoID8gKGRlYnVnJGkoXCJDaGlsZCBub3QgZm91bmRcIiksICExKSA6IChkZWJ1ZyRpKGBVbnNldHRpbmcgY2hpbGQgYXQgcGF0aCAke0pTT04uc3RyaW5naWZ5KGNoaWxkUGF0aCl9YCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgZGVidWdWZXJib3NlJDQgJiYgZGVidWckaShgUmVtb3ZpbmcgY2hpbGQgYXQgcGF0aCAke0pTT04uc3RyaW5naWZ5KGNoaWxkUGF0aCl9YCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGNoaWxkUGF0aFxuICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwKSA6ICExO1xufVxuZnVuY3Rpb24gaXNLZXllZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24gZGVidWdTdGF0ZShlZGl0b3IsIHN0YXRlTmFtZSkge1xuICBkZWJ1Z1ZlcmJvc2UkNCAmJiAoZGVidWckaShgQ2hpbGRyZW4gJHtzdGF0ZU5hbWV9OmAsIEpTT04uc3RyaW5naWZ5KGVkaXRvci5jaGlsZHJlbiwgbnVsbCwgMikpLCBkZWJ1ZyRpKGBTZWxlY3Rpb24gJHtzdGF0ZU5hbWV9OiBgLCBKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uLCBudWxsLCAyKSkpO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIGxldCBibG9ja0luZGV4ID0gLTE7XG4gIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4MikgPT4ge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpc0tleWVkU2VnbWVudChwYXRoWzBdKSA/IG5vZGUuX2tleSA9PT0gcGF0aFswXS5fa2V5IDogaW5kZXgyID09PSBwYXRoWzBdO1xuICAgIHJldHVybiBpc01hdGNoICYmIChibG9ja0luZGV4ID0gaW5kZXgyKSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBibG9jayA/IHtcbiAgICBibG9jayxcbiAgICBwYXRoOiBbYmxvY2tJbmRleF1cbiAgfSA6IHt9O1xufVxuZnVuY3Rpb24gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIHBhdGg6IGJsb2NrUGF0aFxuICB9ID0gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCEoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykgJiYgcGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2ssXG4gICAgICBibG9ja1BhdGgsXG4gICAgICBjaGlsZDogdm9pZCAwLFxuICAgICAgY2hpbGRQYXRoOiB2b2lkIDBcbiAgICB9O1xuICBsZXQgY2hpbGRJbmRleCA9IC0xO1xuICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4MikgPT4ge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpc0tleWVkU2VnbWVudChwYXRoWzJdKSA/IG5vZGUuX2tleSA9PT0gcGF0aFsyXS5fa2V5IDogaW5kZXgyID09PSBwYXRoWzJdO1xuICAgIHJldHVybiBpc01hdGNoICYmIChjaGlsZEluZGV4ID0gaW5kZXgyKSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBjaGlsZCA/IHtcbiAgICBibG9jayxcbiAgICBjaGlsZCxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiBibG9ja1BhdGg/LmNvbmNhdChjaGlsZEluZGV4KVxuICB9IDoge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZDogdm9pZCAwLFxuICAgIGNoaWxkUGF0aDogdm9pZCAwXG4gIH07XG59XG5jb25zdCBQQVRDSElORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aG91dFBhdGNoaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUGF0Y2hpbmcoZWRpdG9yKTtcbiAgUEFUQ0hJTkcuc2V0KGVkaXRvciwgITEpLCBmbigpLCBQQVRDSElORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzUGF0Y2hpbmcoZWRpdG9yKSB7XG4gIHJldHVybiBQQVRDSElORy5nZXQoZWRpdG9yKTtcbn1cbmNvbnN0IGRlYnVnJGggPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhVbmRvUmVkb1wiKSwgZGVidWdWZXJib3NlJDMgPSBkZWJ1ZyRoLmVuYWJsZWQgJiYgITEsIFNBVklORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBSRU1PVEVfUEFUQ0hFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBVTkRPX1NURVBfTElNSVQgPSAxZTMsIGlzU2F2aW5nID0gKGVkaXRvcikgPT4ge1xuICBjb25zdCBzdGF0ZSA9IFNBVklORy5nZXQoZWRpdG9yKTtcbiAgcmV0dXJuIHN0YXRlID09PSB2b2lkIDAgPyAhMCA6IHN0YXRlO1xufSwgZ2V0UmVtb3RlUGF0Y2hlcyA9IChlZGl0b3IpID0+IChSRU1PVEVfUEFUQ0hFUy5nZXQoZWRpdG9yKSB8fCBSRU1PVEVfUEFUQ0hFUy5zZXQoZWRpdG9yLCBbXSksIFJFTU9URV9QQVRDSEVTLmdldChlZGl0b3IpIHx8IFtdKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhVbmRvUmVkbyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICByZWFkT25seSxcbiAgICBibG9ja1NjaGVtYVR5cGVcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoZWRpdG9yKSA9PiB7XG4gICAgbGV0IHByZXZpb3VzU25hcHNob3QgPSBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIGJsb2NrU2NoZW1hVHlwZS5uYW1lKTtcbiAgICBjb25zdCByZW1vdGVQYXRjaGVzID0gZ2V0UmVtb3RlUGF0Y2hlcyhlZGl0b3IpO1xuICAgIGVkaXRvci5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgZGVidWckaChcIlN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIik7XG4gICAgICBjb25zdCBzdWIgPSBlZGl0b3JBY3Rvci5vbihcInBhdGNoZXNcIiwgKHtcbiAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgc25hcHNob3RcbiAgICAgIH0pID0+IHtcbiAgICAgICAgbGV0IHJlc2V0ID0gITE7XG4gICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc2V0ICYmIHBhdGNoLm9yaWdpbiAhPT0gXCJsb2NhbFwiICYmIHJlbW90ZVBhdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZGVidWckaChcIlNvbWVvbmUgZWxzZSBjbGVhcmVkIHRoZSBjb250ZW50LCByZXNldHRpbmcgdW5kby9yZWRvIGhpc3RvcnlcIiksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICAgICAgICByZWRvczogW11cbiAgICAgICAgICAgICAgfSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCByZXNldCA9ICEwO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdGVQYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRjaCxcbiAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgICBwcmV2aW91c1NuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBwcmV2aW91c1NuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGgoXCJVbnN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICB1bmRvczogW10sXG4gICAgICByZWRvczogW11cbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICAgIGhpc3RvcnlcbiAgICAgIH0gPSBlZGl0b3IsIHtcbiAgICAgICAgdW5kb3NcbiAgICAgIH0gPSBoaXN0b3J5LCBzdGVwID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV0sIGxhc3RPcCA9IHN0ZXAgJiYgc3RlcC5vcGVyYXRpb25zICYmIHN0ZXAub3BlcmF0aW9uc1tzdGVwLm9wZXJhdGlvbnMubGVuZ3RoIC0gMV0sIG92ZXJ3cml0ZSA9IHNob3VsZE92ZXJ3cml0ZShvcCwgbGFzdE9wKSwgc2F2ZSA9IGlzU2F2aW5nKGVkaXRvcik7XG4gICAgICBsZXQgbWVyZ2UgPSAhMDtcbiAgICAgIGlmIChzYXZlKSB7XG4gICAgICAgIGlmIChzdGVwID8gb3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgKG1lcmdlID0gc2hvdWxkTWVyZ2Uob3AsIGxhc3RPcCkgfHwgb3ZlcndyaXRlKSA6IG1lcmdlID0gITEsIHN0ZXAgJiYgbWVyZ2UpXG4gICAgICAgICAgc3RlcC5vcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXdTdGVwID0ge1xuICAgICAgICAgICAgb3BlcmF0aW9uczogWy4uLmVkaXRvci5zZWxlY3Rpb24gPT09IG51bGwgPyBbXSA6IFtjcmVhdGVTZWxlY3RPcGVyYXRpb24oZWRpdG9yKV0sIG9wXSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHVuZG9zLnB1c2gobmV3U3RlcCksIGRlYnVnJGgoXCJDcmVhdGVkIG5ldyB1bmRvIHN0ZXBcIiwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHVuZG9zLmxlbmd0aCA+IFVORE9fU1RFUF9MSU1JVDsgKVxuICAgICAgICAgIHVuZG9zLnNoaWZ0KCk7XG4gICAgICAgIHNob3VsZENsZWFyKG9wKSAmJiAoaGlzdG9yeS5yZWRvcyA9IFtdKTtcbiAgICAgIH1cbiAgICAgIGFwcGx5MihvcCk7XG4gICAgfSwgZWRpdG9yLnVuZG8gPSAoKSA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdW5kb3NcbiAgICAgIH0gPSBlZGl0b3IuaGlzdG9yeTtcbiAgICAgIGlmICh1bmRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRlYnVnJGgoXCJVbmRvaW5nXCIsIHN0ZXApLCBzdGVwLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG90aGVyUGF0Y2hlcyA9IHJlbW90ZVBhdGNoZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRpbWUgPj0gc3RlcC50aW1lc3RhbXApO1xuICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBzdGVwLm9wZXJhdGlvbnM7XG4gICAgICAgICAgb3RoZXJQYXRjaGVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IGZsYXR0ZW4odHJhbnNmb3JtZWRPcGVyYXRpb25zLm1hcCgob3ApID0+IHRyYW5zZm9ybU9wZXJhdGlvbihlZGl0b3IsIGl0ZW0ucGF0Y2gsIG9wLCBpdGVtLnNuYXBzaG90LCBpdGVtLnByZXZpb3VzU25hcHNob3QpKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmV2ZXJzZWRPcGVyYXRpb25zID0gdHJhbnNmb3JtZWRPcGVyYXRpb25zLm1hcChPcGVyYXRpb24uaW52ZXJzZSkucmV2ZXJzZSgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB3aXRoVW5kb2luZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV2ZXJzZWRPcGVyYXRpb25zLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgZWRpdG9yLm5vcm1hbGl6ZSgpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnJGgoXCJDb3VsZCBub3QgcGVyZm9ybSB1bmRvIHN0ZXBcIiwgZXJyKSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgICB1bmRvczogW10sXG4gICAgICAgICAgICAgIHJlZG9zOiBbXVxuICAgICAgICAgICAgfSwgU0FWSU5HLnNldChlZGl0b3IsICEwKSwgc2V0SXNVbmRvaW5nKGVkaXRvciwgITEpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmhpc3RvcnkucmVkb3MucHVzaChzdGVwKSwgZWRpdG9yLmhpc3RvcnkudW5kb3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBlZGl0b3IucmVkbyA9ICgpID0+IHtcbiAgICAgIGlmIChyZWFkT25seSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWRvc1xuICAgICAgfSA9IGVkaXRvci5oaXN0b3J5O1xuICAgICAgaWYgKHJlZG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHJlZG9zW3JlZG9zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZGVidWckaChcIlJlZG9pbmdcIiwgc3RlcCksIHN0ZXAub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJQYXRjaGVzID0gcmVtb3RlUGF0Y2hlcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udGltZSA+PSBzdGVwLnRpbWVzdGFtcCk7XG4gICAgICAgICAgbGV0IHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IHN0ZXAub3BlcmF0aW9ucztcbiAgICAgICAgICBvdGhlclBhdGNoZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gZmxhdHRlbih0cmFuc2Zvcm1lZE9wZXJhdGlvbnMubWFwKChvcCkgPT4gdHJhbnNmb3JtT3BlcmF0aW9uKGVkaXRvciwgaXRlbS5wYXRjaCwgb3AsIGl0ZW0uc25hcHNob3QsIGl0ZW0ucHJldmlvdXNTbmFwc2hvdCkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgd2l0aFJlZG9pbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2l0aG91dFNhdmluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYXBwbHkob3ApO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZWJ1ZyRoKFwiQ291bGQgbm90IHBlcmZvcm0gcmVkbyBzdGVwXCIsIGVyciksIHJlbW90ZVBhdGNoZXMuc3BsaWNlKDAsIHJlbW90ZVBhdGNoZXMubGVuZ3RoKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgICAgICAgICAgdW5kb3M6IFtdLFxuICAgICAgICAgICAgICByZWRvczogW11cbiAgICAgICAgICAgIH0sIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHNldElzUmVkb2luZyhlZGl0b3IsICExKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvci5oaXN0b3J5LnVuZG9zLnB1c2goc3RlcCksIGVkaXRvci5oaXN0b3J5LnJlZG9zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uKGVkaXRvciwgcGF0Y2gsIG9wZXJhdGlvbiwgc25hcHNob3QsIHByZXZpb3VzU25hcHNob3QpIHtcbiAgZGVidWdWZXJib3NlJDMgJiYgKGRlYnVnJGgoYEFkanVzdGluZyAnJHtvcGVyYXRpb24udHlwZX0nIG9wZXJhdGlvbiBwYXRocyBmb3IgJyR7cGF0Y2gudHlwZX0nIHBhdGNoYCksIGRlYnVnJGgoYE9wZXJhdGlvbiAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbil9YCksIGRlYnVnJGgoYFBhdGNoICR7SlNPTi5zdHJpbmdpZnkocGF0Y2gpfWApKTtcbiAgY29uc3QgdHJhbnNmb3JtZWRPcGVyYXRpb24gPSB7XG4gICAgLi4ub3BlcmF0aW9uXG4gIH07XG4gIGlmIChwYXRjaC50eXBlID09PSBcImluc2VydFwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgaW5zZXJ0QmxvY2tJbmRleCA9IChzbmFwc2hvdCB8fCBbXSkuZmluZEluZGV4KChibGspID0+IGlzRXF1YWwoe1xuICAgICAgX2tleTogYmxrLl9rZXlcbiAgICB9LCBwYXRjaC5wYXRoWzBdKSk7XG4gICAgcmV0dXJuIGRlYnVnJGgoYEFkanVzdGluZyBibG9jayBwYXRoICgrJHtwYXRjaC5pdGVtcy5sZW5ndGh9KSBmb3IgJyR7dHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZX0nIG9wZXJhdGlvbiBhbmQgcGF0Y2ggJyR7cGF0Y2gudHlwZX0nYCksIFthZGp1c3RCbG9ja1BhdGgodHJhbnNmb3JtZWRPcGVyYXRpb24sIHBhdGNoLml0ZW1zLmxlbmd0aCwgaW5zZXJ0QmxvY2tJbmRleCldO1xuICB9XG4gIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB1bnNldEJsb2NrSW5kZXggPSAocHJldmlvdXNTbmFwc2hvdCB8fCBbXSkuZmluZEluZGV4KChibGspID0+IGlzRXF1YWwoe1xuICAgICAgX2tleTogYmxrLl9rZXlcbiAgICB9LCBwYXRjaC5wYXRoWzBdKSk7XG4gICAgcmV0dXJuIFwicGF0aFwiIGluIHRyYW5zZm9ybWVkT3BlcmF0aW9uICYmIEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCkgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSA9PT0gdW5zZXRCbG9ja0luZGV4ID8gKGRlYnVnJGgoXCJTa2lwcGluZyB0cmFuc2Zvcm1hdGlvbiB0aGF0IHRhcmdldGVkIHJlbW92ZWQgYmxvY2tcIiksIFtdKSA6IChkZWJ1Z1ZlcmJvc2UkMyAmJiAoZGVidWckaChgU2VsZWN0aW9uICR7SlNPTi5zdHJpbmdpZnkoZWRpdG9yLnNlbGVjdGlvbil9YCksIGRlYnVnJGgoYEFkanVzdGluZyBibG9jayBwYXRoICgtMSkgZm9yICcke3RyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGV9JyBvcGVyYXRpb24gYW5kIHBhdGNoICcke3BhdGNoLnR5cGV9J2ApKSwgW2FkanVzdEJsb2NrUGF0aCh0cmFuc2Zvcm1lZE9wZXJhdGlvbiwgLTEsIHVuc2V0QmxvY2tJbmRleCldKTtcbiAgfVxuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBkZWJ1ZyRoKGBBZGp1c3Rpbmcgc2VsZWN0aW9uIGZvciB1bnNldCBldmVyeXRoaW5nIHBhdGNoIGFuZCAke29wZXJhdGlvbi50eXBlfSBvcGVyYXRpb25gKSwgW107XG4gIGlmIChwYXRjaC50eXBlID09PSBcImRpZmZNYXRjaFBhdGNoXCIpIHtcbiAgICBjb25zdCBvcGVyYXRpb25UYXJnZXRCbG9jayA9IGZpbmRPcGVyYXRpb25UYXJnZXRCbG9jayhlZGl0b3IsIHRyYW5zZm9ybWVkT3BlcmF0aW9uKTtcbiAgICByZXR1cm4gIW9wZXJhdGlvblRhcmdldEJsb2NrIHx8ICFpc0VxdWFsKHtcbiAgICAgIF9rZXk6IG9wZXJhdGlvblRhcmdldEJsb2NrLl9rZXlcbiAgICB9LCBwYXRjaC5wYXRoWzBdKSA/IFt0cmFuc2Zvcm1lZE9wZXJhdGlvbl0gOiAocGFyc2UocGF0Y2gudmFsdWUpLmZvckVhY2goKGRpZmZQYXRjaCkgPT4ge1xuICAgICAgbGV0IGFkanVzdE9mZnNldEJ5ID0gMCwgY2hhbmdlZE9mZnNldCA9IGRpZmZQYXRjaC51dGY4U3RhcnQxO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkaWZmc1xuICAgICAgfSA9IGRpZmZQYXRjaDtcbiAgICAgIGlmIChkaWZmcy5mb3JFYWNoKChkaWZmMiwgaW5kZXgyKSA9PiB7XG4gICAgICAgIGNvbnN0IFtkaWZmVHlwZSwgdGV4dF0gPSBkaWZmMjtcbiAgICAgICAgZGlmZlR5cGUgPT09IERJRkZfSU5TRVJUID8gKGFkanVzdE9mZnNldEJ5ICs9IHRleHQubGVuZ3RoLCBjaGFuZ2VkT2Zmc2V0ICs9IHRleHQubGVuZ3RoKSA6IGRpZmZUeXBlID09PSBESUZGX0RFTEVURSA/IChhZGp1c3RPZmZzZXRCeSAtPSB0ZXh0Lmxlbmd0aCwgY2hhbmdlZE9mZnNldCAtPSB0ZXh0Lmxlbmd0aCkgOiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiAoZGlmZnMuc2xpY2UoaW5kZXgyKS5ldmVyeSgoW2RUeXBlXSkgPT4gZFR5cGUgPT09IERJRkZfRVFVQUwpIHx8IChjaGFuZ2VkT2Zmc2V0ICs9IHRleHQubGVuZ3RoKSk7XG4gICAgICB9KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIGNoYW5nZWRPZmZzZXQgPCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiAmJiBjaGFuZ2VkT2Zmc2V0IDw9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCAtIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnRleHQubGVuZ3RoICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIikge1xuICAgICAgICBjb25zdCBjdXJyZW50Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0gOiB2b2lkIDAsIGN1cnJlbnRBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ucHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuYW5jaG9yXG4gICAgICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSA6IHZvaWQgMCwgbmV3QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICAoY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgfHwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yKSAmJiAoW2N1cnJlbnRGb2N1cywgY3VycmVudEFuY2hvciwgbmV3Rm9jdXMsIG5ld0FuY2hvcl0uZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgICAgICBwb2ludCAmJiBjaGFuZ2VkT2Zmc2V0IDwgcG9pbnQub2Zmc2V0ICYmIChwb2ludC5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpO1xuICAgICAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgZm9jdXM6IGN1cnJlbnRGb2N1cyxcbiAgICAgICAgICBhbmNob3I6IGN1cnJlbnRBbmNob3JcbiAgICAgICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgICAgICBmb2N1czogbmV3Rm9jdXMsXG4gICAgICAgICAgYW5jaG9yOiBuZXdBbmNob3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pLCBbdHJhbnNmb3JtZWRPcGVyYXRpb25dKTtcbiAgfVxuICByZXR1cm4gW3RyYW5zZm9ybWVkT3BlcmF0aW9uXTtcbn1cbmZ1bmN0aW9uIGFkanVzdEJsb2NrUGF0aChvcGVyYXRpb24sIGxldmVsLCBibG9ja0luZGV4KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0ge1xuICAgIC4uLm9wZXJhdGlvblxuICB9O1xuICBpZiAoYmxvY2tJbmRleCA+PSAwICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCkgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSA+PSBibG9ja0luZGV4ICsgbGV2ZWwgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSArIGxldmVsID4gLTEpIHtcbiAgICBjb25zdCBuZXdQYXRoID0gW3RyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gKyBsZXZlbCwgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aC5zbGljZSgxKV07XG4gICAgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCA9IG5ld1BhdGg7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB7XG4gICAgY29uc3QgY3VycmVudEZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgfSA6IHZvaWQgMCwgY3VycmVudEFuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5wcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5mb2N1c1xuICAgIH0gOiB2b2lkIDAsIG5ld0FuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5uZXdQcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDA7XG4gICAgKGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yIHx8IG5ld0ZvY3VzICYmIG5ld0FuY2hvcikgJiYgKFtjdXJyZW50Rm9jdXMsIGN1cnJlbnRBbmNob3IsIG5ld0ZvY3VzLCBuZXdBbmNob3JdLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICBwb2ludCAmJiBwb2ludC5wYXRoWzBdID49IGJsb2NrSW5kZXggKyBsZXZlbCAmJiBwb2ludC5wYXRoWzBdICsgbGV2ZWwgPiAtMSAmJiAocG9pbnQucGF0aCA9IFtwb2ludC5wYXRoWzBdICsgbGV2ZWwsIC4uLnBvaW50LnBhdGguc2xpY2UoMSldKTtcbiAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICBmb2N1czogY3VycmVudEZvY3VzLFxuICAgICAgYW5jaG9yOiBjdXJyZW50QW5jaG9yXG4gICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICAgIGFuY2hvcjogbmV3QW5jaG9yXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cbmNvbnN0IHNob3VsZE1lcmdlID0gKG9wLCBwcmV2KSA9PiAhIShvcC50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiB8fCBwcmV2ICYmIG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBwcmV2LnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBvcC5vZmZzZXQgPT09IHByZXYub2Zmc2V0ICsgcHJldi50ZXh0Lmxlbmd0aCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpICYmIG9wLnRleHQgIT09IFwiIFwiIHx8IHByZXYgJiYgb3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIHByZXYudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBwcmV2Lm9mZnNldCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSwgc2hvdWxkT3ZlcndyaXRlID0gKG9wLCBwcmV2KSA9PiAhIShwcmV2ICYmIG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIHByZXYudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpLCBzaG91bGRDbGVhciA9IChvcCkgPT4gb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCI7XG5mdW5jdGlvbiB3aXRob3V0U2F2aW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzU2F2aW5nKGVkaXRvcik7XG4gIFNBVklORy5zZXQoZWRpdG9yLCAhMSksIGZuKCksIFNBVklORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdE9wZXJhdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldF9zZWxlY3Rpb25cIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSxcbiAgICBuZXdQcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgb3BlcmF0aW9uKSB7XG4gIGxldCBibG9jaztcbiAgcmV0dXJuIG9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiAmJiBlZGl0b3Iuc2VsZWN0aW9uID8gYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdXSA6IFwicGF0aFwiIGluIG9wZXJhdGlvbiAmJiAoYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSwgYmxvY2s7XG59XG5jb25zdCBkZWJ1ZyRnID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGF0Y2hlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHBhdGNoRnVuY3Rpb25zLFxuICByZWFkT25seSxcbiAgc2NoZW1hVHlwZXNcbn0pIHtcbiAgbGV0IHByZXZpb3VzQ2hpbGRyZW47XG4gIGNvbnN0IGFwcGx5UGF0Y2ggPSBjcmVhdGVBcHBseVBhdGNoKHNjaGVtYVR5cGVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgITEpLCBQQVRDSElORy5zZXQoZWRpdG9yLCAhMCksIHByZXZpb3VzQ2hpbGRyZW4gPSBbLi4uZWRpdG9yLmNoaWxkcmVuXTtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICBsZXQgYnVmZmVyZWRQYXRjaGVzID0gW107XG4gICAgY29uc3QgaGFuZGxlQnVmZmVyZWRSZW1vdGVQYXRjaGVzID0gKCkgPT4ge1xuICAgICAgaWYgKGJ1ZmZlcmVkUGF0Y2hlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXM7XG4gICAgICBidWZmZXJlZFBhdGNoZXMgPSBbXTtcbiAgICAgIGxldCBjaGFuZ2VkID0gITE7XG4gICAgICB3aXRoUmVtb3RlQ2hhbmdlcyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRob3V0UGF0Y2hpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWckZy5lbmFibGVkICYmIGRlYnVnJGcoYEhhbmRsaW5nIHJlbW90ZSBwYXRjaCAke0pTT04uc3RyaW5naWZ5KHBhdGNoKX1gKSwgY2hhbmdlZCA9IGFwcGx5UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBjaGFuZ2VkICYmIChlZGl0b3Iubm9ybWFsaXplKCksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICAgIH0pO1xuICAgIH0sIGhhbmRsZVBhdGNoZXMgPSAoe1xuICAgICAgcGF0Y2hlc1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHJlbW90ZVBhdGNoZXMgPSBwYXRjaGVzLmZpbHRlcigocCkgPT4gcC5vcmlnaW4gIT09IFwibG9jYWxcIik7XG4gICAgICByZW1vdGVQYXRjaGVzLmxlbmd0aCAhPT0gMCAmJiAoYnVmZmVyZWRQYXRjaGVzID0gYnVmZmVyZWRQYXRjaGVzLmNvbmNhdChyZW1vdGVQYXRjaGVzKSwgaGFuZGxlQnVmZmVyZWRSZW1vdGVQYXRjaGVzKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGVkaXRvci5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgZGVidWckZyhcIlN1YnNjcmliaW5nIHRvIHJlbW90ZSBwYXRjaGVzXCIpO1xuICAgICAgY29uc3Qgc3ViID0gZWRpdG9yQWN0b3Iub24oXCJwYXRjaGVzXCIsIGhhbmRsZVBhdGNoZXMpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGVidWckZyhcIlVuc3Vic2NyaWJpbmcgdG8gcmVtb3RlIHBhdGNoZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KSwgZWRpdG9yLmFwcGx5ID0gKG9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKHJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gYXBwbHkyKG9wZXJhdGlvbiksIGVkaXRvcjtcbiAgICAgIGxldCBwYXRjaGVzID0gW107XG4gICAgICBwcmV2aW91c0NoaWxkcmVuID0gZWRpdG9yLmNoaWxkcmVuO1xuICAgICAgY29uc3QgZWRpdG9yV2FzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihwcmV2aW91c0NoaWxkcmVuLCBzY2hlbWFUeXBlcyk7XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgIGNvbnN0IGVkaXRvcklzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihlZGl0b3IuY2hpbGRyZW4sIHNjaGVtYVR5cGVzKTtcbiAgICAgIGlmICghaXNQYXRjaGluZyhlZGl0b3IpKVxuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgc3dpdGNoIChlZGl0b3JXYXNFbXB0eSAmJiAhZWRpdG9ySXNFbXB0eSAmJiBvcGVyYXRpb24udHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgcGF0Y2hlcy5wdXNoKGluc2VydChwcmV2aW91c0NoaWxkcmVuLCBcImJlZm9yZVwiLCBbMF0pKSwgb3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImluc2VydF90ZXh0XCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5pbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZV90ZXh0XCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5yZW1vdmVUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5yZW1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNwbGl0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLnNwbGl0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuaW5zZXJ0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuc2V0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXJnZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5tZXJnZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW92ZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5tb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWVkaXRvcldhc0VtcHR5ICYmIGVkaXRvcklzRW1wdHkgJiYgW1wibWVyZ2Vfbm9kZVwiLCBcInNldF9ub2RlXCIsIFwicmVtb3ZlX3RleHRcIiwgXCJyZW1vdmVfbm9kZVwiXS5pbmNsdWRlcyhvcGVyYXRpb24udHlwZSkgJiYgKHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgdW5zZXQoW10pXSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwidW5zZXRcIixcbiAgICAgICAgcHJldmlvdXNWYWx1ZTogZnJvbVNsYXRlVmFsdWUocHJldmlvdXNDaGlsZHJlbiwgc2NoZW1hVHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpXG4gICAgICB9KSksIGVkaXRvcldhc0VtcHR5ICYmIHBhdGNoZXMubGVuZ3RoID4gMCAmJiAocGF0Y2hlcyA9IFtzZXRJZk1pc3NpbmcoW10sIFtdKSwgLi4ucGF0Y2hlc10pLCBwYXRjaGVzLmxlbmd0aCA+IDAgJiYgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgIC4uLnBhdGNoLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksIGVkaXRvcjtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRmID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGxhY2Vob2xkZXJCbG9ja1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrKCkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcC5ub2RlO1xuICAgICAgICBpZiAob3AucGF0aFswXSA9PT0gMCAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFBhdGgubmV4dChvcC5wYXRoKTtcbiAgICAgICAgICBlZGl0b3IuY2hpbGRyZW5bbmV4dFBhdGhbMF1dIHx8IChkZWJ1ZyRmKFwiQWRkaW5nIHBsYWNlaG9sZGVyIGJsb2NrXCIpLCBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGUgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUoZWRpdG9yQWN0b3IsIHR5cGVzKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVzLnN0eWxlc1swXS52YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhdGhdID0gbm9kZUVudHJ5O1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBlZGl0b3Iub3BlcmF0aW9ucylcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRCbG9jayhvcC5wcm9wZXJ0aWVzKSAmJiBvcC5wcm9wZXJ0aWVzLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgJiYgb3AucGF0aFswXSA9PT0gcGF0aFswXSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgb3AucGF0aCkpIHtcbiAgICAgICAgICBjb25zdCBbY2hpbGRdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSArIDEsIDBdKTtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoY2hpbGQpICYmIGNoaWxkLnRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRlYnVnJGUoYE5vcm1hbGl6aW5nIHNwbGl0IG5vZGUgdG8gJHtkZWZhdWx0U3R5bGV9IHN0eWxlYCwgb3ApLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogW29wLnBhdGhbMF0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3IucHRlSGFzQmxvY2tTdHlsZSA9IChzdHlsZSkgPT4gZWRpdG9yLnNlbGVjdGlvbiA/IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIG5vZGUuc3R5bGUgPT09IHN0eWxlXG4gICAgfSldLmxlbmd0aCA+IDAgOiAhMSwgZWRpdG9yLnB0ZVRvZ2dsZUJsb2NrU3R5bGUgPSAoYmxvY2tTdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiAmJiAoWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gICAgICB9KV0uZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIGVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBub2RlLnN0eWxlID09PSBibG9ja1N0eWxlID8gKGRlYnVnJGUoYFVuc2V0dGluZyBibG9jayBzdHlsZSAnJHtibG9ja1N0eWxlfSdgKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pKSA6IChibG9ja1N0eWxlID8gZGVidWckZShgU2V0dGluZyBzdHlsZSAnJHtibG9ja1N0eWxlfSdgKSA6IGRlYnVnJGUoXCJTZXR0aW5nIGRlZmF1bHQgc3R5bGVcIiwgZGVmYXVsdFN0eWxlKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHN0eWxlOiBibG9ja1N0eWxlIHx8IGRlZmF1bHRTdHlsZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSkpO1xuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRkID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUG9ydGFibGVUZXh0TGlzdHNcIiksIE1BWF9MSVNUX0xFVkVMID0gMTA7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUG9ydGFibGVUZXh0TGlzdHModHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlVG9nZ2xlTGlzdEl0ZW0gPSAobGlzdEl0ZW1TdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnB0ZUhhc0xpc3RTdHlsZShsaXN0SXRlbVN0eWxlKSA/IChkZWJ1ZyRkKGBSZW1vdmUgbGlzdCBpdGVtICcke2xpc3RJdGVtU3R5bGV9J2ApLCBlZGl0b3IucHRlVW5zZXRMaXN0SXRlbShsaXN0SXRlbVN0eWxlKSkgOiAoZGVidWckZChgQWRkIGxpc3QgaXRlbSAnJHtsaXN0SXRlbVN0eWxlfSdgKSwgZWRpdG9yLnB0ZVNldExpc3RJdGVtKGxpc3RJdGVtU3R5bGUpKTtcbiAgICB9LCBlZGl0b3IucHRlVW5zZXRMaXN0SXRlbSA9IChsaXN0SXRlbVN0eWxlKSA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uICYmIFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgfSldLmZvckVhY2goKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLmlzTGlzdEJsb2NrKG5vZGUpKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGlzdEl0ZW0sXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gbm9kZSwgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBsaXN0SXRlbTogdm9pZCAwLFxuICAgICAgICAgICAgbGV2ZWw6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgZGVidWckZChgVW5zZXR0aW5nIGxpc3QgJyR7bGlzdEl0ZW1TdHlsZX0nYCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBuZXdOb2RlLCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IucHRlU2V0TGlzdEl0ZW0gPSAobGlzdEl0ZW1TdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiAmJiBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgICAgIH0pXS5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgZGVidWckZChgU2V0dGluZyBsaXN0ICcke2xpc3RJdGVtU3R5bGV9J2ApLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgICAgbGlzdEl0ZW06IGxpc3RJdGVtU3R5bGUgfHwgdHlwZXMubGlzdHNbMF0gJiYgdHlwZXMubGlzdHNbMF0udmFsdWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnB0ZUVuZExpc3QgPSAoKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBlZGl0b3IuaXNMaXN0QmxvY2sobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgJiYgbm9kZS5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiXG4gICAgICB9KV07XG4gICAgICByZXR1cm4gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID09PSAwID8gITEgOiAoc2VsZWN0ZWRCbG9ja3MuZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgKGRlYnVnJGQoXCJVbnNldCBsaXN0XCIpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgbGV2ZWw6IHZvaWQgMCxcbiAgICAgICAgICBsaXN0SXRlbTogdm9pZCAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSk7XG4gICAgICB9KSwgITApO1xuICAgIH0sIGVkaXRvci5wdGVJbmNyZW1lbnRCbG9ja0xldmVscyA9IChyZXZlcnNlKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gISFlZGl0b3IuaXNMaXN0QmxvY2sobm9kZSlcbiAgICAgIH0pXTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPT09IDAgPyAhMSA6IChzZWxlY3RlZEJsb2Nrcy5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSkge1xuICAgICAgICAgIGxldCBsZXZlbCA9IG5vZGUubGV2ZWwgfHwgMTtcbiAgICAgICAgICByZXZlcnNlID8gKGxldmVsLS0sIGRlYnVnJGQoXCJEZWNyZW1lbnRpbmcgbGlzdCBsZXZlbFwiLCBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgbGV2ZWwpKSkpIDogKGxldmVsKyssIGRlYnVnJGQoXCJJbmNyZW1lbnRpbmcgbGlzdCBsZXZlbFwiLCBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgbGV2ZWwpKSkpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbGV2ZWw6IE1hdGgubWluKE1BWF9MSVNUX0xFVkVMLCBNYXRoLm1heCgxLCBsZXZlbCkpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksICEwKTtcbiAgICB9LCBlZGl0b3IucHRlSGFzTGlzdFN0eWxlID0gKGxpc3RTdHlsZSkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgfSldO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDAgPyBzZWxlY3RlZEJsb2Nrcy5ldmVyeSgoW25vZGVdKSA9PiBlZGl0b3IuaXNMaXN0QmxvY2sobm9kZSkgJiYgbm9kZS5saXN0SXRlbSA9PT0gbGlzdFN0eWxlKSA6ICExO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIiAmJiBcInRleHRcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIG5vZGUubWFya3MgPiBcInVcIiB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MuZXZlcnkoKG1hcmspID0+IHR5cGVvZiBtYXJrID09IFwic3RyaW5nXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgYmxvY2sgZG9lc24ndCBfaGF2ZV8gdG8gYmUgbmFtZWQgJ2Jsb2NrJyAtIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlblxuICAgIC8vIGFsbG93ZWQgY2hpbGQgdHlwZXMgYW5kIG1hcmtzLCBvbmUgbWlnaHQgbmFtZSB0aGVtIGRpZmZlcmVudGx5XG4gICAgdHlwZW9mIG5vZGUuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJiAvLyBUb29sa2l0LXR5cGVzIGxpa2UgbmVzdGVkIHNwYW5zIGFyZSBALXByZWZpeGVkXG4gICAgbm9kZS5fdHlwZVswXSAhPT0gXCJAXCIgJiYgLy8gYG1hcmtEZWZzYCBpc24ndCBfcmVxdWlyZWRfIHBlciBzYXksIGJ1dCBpZiBpdCdzIHRoZXJlLCBpdCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgICghKFwibWFya0RlZnNcIiBpbiBub2RlKSB8fCAhbm9kZS5tYXJrRGVmcyB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpICYmIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoKGRlZikgPT4gdHlwZW9mIGRlZi5fa2V5ID09IFwic3RyaW5nXCIpKSAmJiAvLyBgY2hpbGRyZW5gIGlzIHJlcXVpcmVkIGFuZCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgJiYgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoKGNoaWxkKSA9PiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpXG4gICk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1NwYW4oe1xuICBlZGl0b3IsXG4gIGJsb2NrUGF0aCxcbiAgc3BhblBhdGhcbn0pIHtcbiAgbGV0IHByZXZpb3VzU3BhbjtcbiAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCwge1xuICAgIHJldmVyc2U6ICEwXG4gIH0pKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0JlZm9yZShjaGlsZFBhdGgsIHNwYW5QYXRoKSkge1xuICAgICAgcHJldmlvdXNTcGFuID0gY2hpbGQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBwcmV2aW91c1NwYW47XG59XG5mdW5jdGlvbiBnZXROZXh0U3Bhbih7XG4gIGVkaXRvcixcbiAgYmxvY2tQYXRoLFxuICBzcGFuUGF0aFxufSkge1xuICBsZXQgbmV4dFNwYW47XG4gIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0FmdGVyKGNoaWxkUGF0aCwgc3BhblBhdGgpKSB7XG4gICAgICBuZXh0U3BhbiA9IGNoaWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gbmV4dFNwYW47XG59XG5jb25zdCBkZWJ1ZyRjID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChlZGl0b3JBY3RvciwgdHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTIsXG4gICAgICBub3JtYWxpemVOb2RlXG4gICAgfSA9IGVkaXRvciwgZGVjb3JhdG9ycyA9IHR5cGVzLmRlY29yYXRvcnMubWFwKCh0KSA9PiB0LnZhbHVlKSwgZm9yY2VOZXdTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uICYmIChUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgICAgLi4uZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSksIGVkaXRvci5zZWxlY3Rpb24gPSB7XG4gICAgICAgIC4uLmVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHRSYW5nZSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UoZWRpdG9yLmNoaWxkcmVuLCBlZGl0b3Iuc2VsZWN0aW9uLCB0eXBlcyk7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgc2VsZWN0aW9uOiBwdFJhbmdlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IG5vZGVFbnRyeTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBub2RlLmNoaWxkcmVuW2NoaWxkUGF0aFsxXSArIDFdO1xuICAgICAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgZWRpdG9yLmlzVGV4dFNwYW4obmV4dE5vZGUpICYmIGlzRXF1YWwoY2hpbGQubWFya3MsIG5leHROb2RlLm1hcmtzKSkge1xuICAgICAgICAgICAgZGVidWckYyhcIk1lcmdpbmcgc3BhbnNcIiwgSlNPTi5zdHJpbmdpZnkoY2hpbGQsIG51bGwsIDIpLCBKU09OLnN0cmluZ2lmeShuZXh0Tm9kZSwgbnVsbCwgMikpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogW2NoaWxkUGF0aFswXSwgY2hpbGRQYXRoWzFdICsgMV0sXG4gICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmICFBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpKSB7XG4gICAgICAgIGRlYnVnJGMoXCJBZGRpbmcgLm1hcmtEZWZzIHRvIGJsb2NrIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrRGVmczogW11cbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKG5vZGUpICYmICFBcnJheS5pc0FycmF5KG5vZGUubWFya3MpKSB7XG4gICAgICAgIGRlYnVnJGMoXCJBZGRpbmcgLm1hcmtzIHRvIHNwYW4gbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tQYXRoID0gUGF0aC5wYXJlbnQocGF0aCksIFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGJsb2NrUGF0aCksIGRlY29yYXRvcnMyID0gdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKSwgYW5ub3RhdGlvbnMgPSBub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIG5vZGUudGV4dCA9PT0gXCJcIiAmJiBhbm5vdGF0aW9ucyAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWckYyhcIlJlbW92aW5nIGFubm90YXRpb25zIGZyb20gZW1wdHkgc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya3M6IG5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSkge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IHR5cGVzLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IGNoaWxkLm1hcmtzID8/IFtdLCBvcnBoYW5lZEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykgJiYgIW5vZGUubWFya0RlZnM/LmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgICAgICAgIGlmIChvcnBoYW5lZEFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZGVidWckYyhcIlJlbW92aW5nIG9ycGhhbmVkIGFubm90YXRpb25zIGZyb20gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWFya3M6IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSkge1xuICAgICAgICBjb25zdCBibG9ja1BhdGggPSBQYXRoLnBhcmVudChwYXRoKSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IHR5cGVzLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSksIG1hcmtzID0gbm9kZS5tYXJrcyA/PyBbXSwgb3JwaGFuZWRBbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMyLmluY2x1ZGVzKG1hcmspICYmICFibG9jay5tYXJrRGVmcz8uZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgICAgIGlmIChvcnBoYW5lZEFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnJGMoXCJSZW1vdmluZyBvcnBoYW5lZCBhbm5vdGF0aW9ucyBmcm9tIHNwYW4gbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hcmtzOiBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFvcnBoYW5lZEFubm90YXRpb25zLmluY2x1ZGVzKG1hcmspKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IG1hcmtEZWZzID0gbm9kZS5tYXJrRGVmcyA/PyBbXSwgbWFya0RlZktleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuZXdNYXJrRGVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcmtEZWYgb2YgbWFya0RlZnMpXG4gICAgICAgICAgbWFya0RlZktleXMuaGFzKG1hcmtEZWYuX2tleSkgfHwgKG1hcmtEZWZLZXlzLmFkZChtYXJrRGVmLl9rZXkpLCBuZXdNYXJrRGVmcy5wdXNoKG1hcmtEZWYpKTtcbiAgICAgICAgaWYgKG1hcmtEZWZzLmxlbmd0aCAhPT0gbmV3TWFya0RlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgZGVidWckYyhcIlJlbW92aW5nIGR1cGxpY2F0ZSBtYXJrRGVmc1wiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgIWVkaXRvci5vcGVyYXRpb25zLnNvbWUoKG9wKSA9PiBvcC50eXBlID09PSBcIm1lcmdlX25vZGVcIiAmJiBcIm1hcmtEZWZzXCIgaW4gb3AucHJvcGVydGllcyAmJiBvcC5wYXRoLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgICAgY29uc3QgbmV3TWFya0RlZnMgPSAobm9kZS5tYXJrRGVmcyB8fCBbXSkuZmlsdGVyKChkZWYpID0+IG5vZGUuY2hpbGRyZW4uZmluZCgoY2hpbGQpID0+IFRleHQuaXNUZXh0KGNoaWxkKSAmJiBBcnJheS5pc0FycmF5KGNoaWxkLm1hcmtzKSAmJiBjaGlsZC5tYXJrcy5pbmNsdWRlcyhkZWYuX2tleSkpKTtcbiAgICAgICAgaWYgKG5vZGUubWFya0RlZnMgJiYgIWlzRXF1YWwobmV3TWFya0RlZnMsIG5vZGUubWFya0RlZnMpKSB7XG4gICAgICAgICAgZGVidWckYyhcIlJlbW92aW5nIG1hcmtEZWYgbm90IGluIHVzZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIEVkaXRvci5tYXJrcyhlZGl0b3IpICYmIG9wLnByb3BlcnRpZXMgJiYgb3AubmV3UHJvcGVydGllcyAmJiBvcC5wcm9wZXJ0aWVzLmFuY2hvciAmJiBvcC5wcm9wZXJ0aWVzLmZvY3VzICYmIG9wLm5ld1Byb3BlcnRpZXMuYW5jaG9yICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHtcbiAgICAgICAgICBhbmNob3I6IG9wLnByb3BlcnRpZXMuYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBvcC5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0pLCBuZXdTZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHtcbiAgICAgICAgICBhbmNob3I6IG9wLm5ld1Byb3BlcnRpZXMuYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldmlvdXNTZWxlY3Rpb25Jc0NvbGxhcHNlZCAmJiBuZXdTZWxlY3Rpb25Jc0NvbGxhcHNlZCkge1xuICAgICAgICAgIGNvbnN0IGZvY3VzU3BhbiA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiBvcC5wcm9wZXJ0aWVzLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXT8uWzBdLCBuZXdGb2N1c1NwYW4gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDogb3AubmV3UHJvcGVydGllcy5mb2N1cyxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0/LlswXSwgbW92ZWRUb05leHRTcGFuID0gZm9jdXNTcGFuICYmIG5ld0ZvY3VzU3BhbiAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFswXSAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFsxXSArIDEgJiYgZm9jdXNTcGFuLnRleHQubGVuZ3RoID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLm9mZnNldCAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLm9mZnNldCA9PT0gMCwgbW92ZWRUb1ByZXZpb3VzU3BhbiA9IGZvY3VzU3BhbiAmJiBuZXdGb2N1c1NwYW4gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzBdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzFdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gLSAxICYmIG9wLnByb3BlcnRpZXMuZm9jdXMub2Zmc2V0ID09PSAwICYmIG5ld0ZvY3VzU3Bhbi50ZXh0Lmxlbmd0aCA9PT0gb3AubmV3UHJvcGVydGllcy5mb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgaWYgKG1vdmVkVG9OZXh0U3BhbiB8fCBtb3ZlZFRvUHJldmlvdXNTcGFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IFtfYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgcHJldmlvdXNTcGFuID0gZ2V0UHJldmlvdXNTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoOiBvcC5wYXRoXG4gICAgICAgICAgfSksIHByZXZpb3VzU3BhbkFubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6IFtdLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoOiBbb3AucGF0aFswXSwgb3AucGF0aFsxXSAtIDFdXG4gICAgICAgICAgfSksIG5leHRTcGFuQW5ub3RhdGlvbnMgPSBuZXh0U3BhbiA/IG5leHRTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6IFtdLCBhbm5vdGF0aW9uc0VuZGluZyA9IHByZXZpb3VzU3BhbkFubm90YXRpb25zPy5maWx0ZXIoKGFubm90YXRpb24pID0+ICFuZXh0U3BhbkFubm90YXRpb25zPy5pbmNsdWRlcyhhbm5vdGF0aW9uKSkgPz8gW107XG4gICAgICAgICAgaWYgKGFubm90YXRpb25zRW5kaW5nLmxlbmd0aCA+IDAgJiYgaXNQb3J0YWJsZVRleHRTcGFuKG9wLm5vZGUpICYmIG9wLm5vZGUubWFya3M/LnNvbWUoKG1hcmspID0+IGFubm90YXRpb25zRW5kaW5nLmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgLi4ub3Aubm9kZSxcbiAgICAgICAgICAgICAgbWFya3M6IG9wLm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWFubm90YXRpb25zRW5kaW5nLmluY2x1ZGVzKG1hcmspKSA/PyBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zU3RhcnRpbmcgPSBuZXh0U3BhbkFubm90YXRpb25zPy5maWx0ZXIoKGFubm90YXRpb24pID0+ICFwcmV2aW91c1NwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMoYW5ub3RhdGlvbikpID8/IFtdO1xuICAgICAgICAgIGlmIChhbm5vdGF0aW9uc1N0YXJ0aW5nLmxlbmd0aCA+IDAgJiYgaXNQb3J0YWJsZVRleHRTcGFuKG9wLm5vZGUpICYmIG9wLm5vZGUubWFya3M/LnNvbWUoKG1hcmspID0+IGFubm90YXRpb25zU3RhcnRpbmcuaW5jbHVkZXMobWFyaykpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAuLi5vcC5ub2RlLFxuICAgICAgICAgICAgICBtYXJrczogb3Aubm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhYW5ub3RhdGlvbnNTdGFydGluZy5pbmNsdWRlcyhtYXJrKSkgPz8gW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3IsIGNvbGxhcHNlZFNlbGVjdGlvbiA9IHNlbGVjdGlvbiA/IFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgOiAhMTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBjb2xsYXBzZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBbX2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSksIFtzcGFuLCBzcGFuUGF0aF0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDogc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdLCBtYXJrcyA9IHNwYW4ubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSwgc3Bhbkhhc0Fubm90YXRpb25zID0gbWFya3MubGVuZ3RoID4gbWFya3NXaXRob3V0QW5ub3RhdGlvbnMubGVuZ3RoLCBzcGFuSXNFbXB0eSA9IHNwYW4udGV4dC5sZW5ndGggPT09IDAsIGF0VGhlQmVnaW5uaW5nT2ZTcGFuID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAsIGF0VGhlRW5kT2ZTcGFuID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IHNwYW4udGV4dC5sZW5ndGgsIHByZXZpb3VzU3BhbiA9IGdldFByZXZpb3VzU3Bhbih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgIH0pLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgfSksIG5leHRTcGFuQW5ub3RhdGlvbnMgPSBuZXh0U3Bhbj8ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpID8/IFtdLCBzcGFuQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSwgcHJldmlvdXNTcGFuSGFzQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpLmV2ZXJ5KChtYXJrKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24gPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lTWFya3MgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgbmV4dFNwYW5TaGFyZXNTb21lQW5ub3RhdGlvbnMgPSBzcGFuQW5ub3RhdGlvbnMuc29tZSgobWFyaykgPT4gbmV4dFNwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMobWFyaykpO1xuICAgICAgICAgIGlmIChzcGFuSGFzQW5ub3RhdGlvbnMgJiYgIXNwYW5Jc0VtcHR5KSB7XG4gICAgICAgICAgICBpZiAoYXRUaGVCZWdpbm5pbmdPZlNwYW4pIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVNYXJrcykge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbj8ubWFya3MgPz8gW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogcHJldmlvdXNTcGFuPy5tYXJrcyA/PyBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmV2aW91c1NwYW4pIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0VGhlRW5kT2ZTcGFuKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucyAmJiBuZXh0U3BhbkFubm90YXRpb25zLmxlbmd0aCA8IHNwYW5Bbm5vdGF0aW9ucy5sZW5ndGggfHwgIW5leHRTcGFuU2hhcmVzU29tZUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogbmV4dFNwYW4/Lm1hcmtzID8/IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghbmV4dFNwYW4pIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXRUaGVCZWdpbm5pbmdPZlNwYW4gJiYgIXNwYW5Jc0VtcHR5ICYmIHByZXZpb3VzU3Bhbikge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgIG1hcmtzOiBwcmV2aW91c1NwYW5IYXNBbm5vdGF0aW9ucyA/IFtdIDogKHByZXZpb3VzU3Bhbi5tYXJrcyA/PyBbXSkuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgW3NwYW4sIHNwYW5QYXRoXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICAgIHBhdGg6IG9wLnBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogb3Aub2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdO1xuICAgICAgICAgIGlmIChzcGFuICYmIGJsb2NrICYmIGlzUG9ydGFibGVUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzID8/IFtdLCBtYXJrcyA9IHNwYW4ubWFya3MgPz8gW10sIHNwYW5IYXNBbm5vdGF0aW9ucyA9IG1hcmtzLnNvbWUoKG1hcmspID0+IG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyaykpLCBkZWxldGluZ0Zyb21UaGVFbmQgPSBvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA9PT0gc3Bhbi50ZXh0Lmxlbmd0aCwgZGVsZXRpbmdBbGxUZXh0ID0gb3Aub2Zmc2V0ID09PSAwICYmIGRlbGV0aW5nRnJvbVRoZUVuZCwgcHJldmlvdXNTcGFuID0gZ2V0UHJldmlvdXNTcGFuKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgICB9KSwgbmV4dFNwYW4gPSBnZXROZXh0U3Bhbih7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgICAgfSksIHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgbmV4dFNwYW5IYXNTYW1lQW5ub3RhdGlvbiA9IG5leHRTcGFuID8gbmV4dFNwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExO1xuICAgICAgICAgICAgaWYgKHNwYW5IYXNBbm5vdGF0aW9ucyAmJiBkZWxldGluZ0FsbFRleHQgJiYgIXByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uICYmICFuZXh0U3Bhbkhhc1NhbWVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtzV2l0aG91dEFubm90YXRpb25NYXJrcyA9ICh7XG4gICAgICAgICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgICAgICAgICAgfS5tYXJrcyB8fCBbXSkuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICBhcHBseTIob3ApLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgbWFya3M6IG1hcmtzV2l0aG91dEFubm90YXRpb25NYXJrc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBvcC5wYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWUgJiYgQXJyYXkuaXNBcnJheShvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzKSAmJiBvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzLmxlbmd0aCA+IDAgJiYgb3AucGF0aFswXSAtIDEgPj0gMCkge1xuICAgICAgICBjb25zdCBbdGFyZ2V0QmxvY2ssIHRhcmdldFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSAtIDFdKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayh0YXJnZXRCbG9jaykpIHtcbiAgICAgICAgICBjb25zdCBvbGREZWZzID0gQXJyYXkuaXNBcnJheSh0YXJnZXRCbG9jay5tYXJrRGVmcykgJiYgdGFyZ2V0QmxvY2subWFya0RlZnMgfHwgW10sIG5ld01hcmtEZWZzID0gdW5pcShbLi4ub2xkRGVmcywgLi4ub3AucHJvcGVydGllcy5tYXJrRGVmc10pO1xuICAgICAgICAgIGRlYnVnJGMoXCJDb3B5aW5nIG1hcmtEZWZzIG92ZXIgdG8gbWVyZ2VkIGJsb2NrXCIsIG9wKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSksIGFwcGx5MihvcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvci5hZGRNYXJrID0gKG1hcmspID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKGVkaXRvci5zZWxlY3Rpb24pKVxuICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICAgICAgICBzcGxpdDogITAsXG4gICAgICAgICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0VGV4dE5vZGVzID0gUmFuZ2UuaXNSYW5nZShlZGl0b3Iuc2VsZWN0aW9uKSA/IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICAgICAgICAgIH0pXSA6IFtdO1xuICAgICAgICAgICAgc3BsaXRUZXh0Tm9kZXMubGVuZ3RoID4gMSAmJiBzcGxpdFRleHROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZVswXS5tYXJrcz8uaW5jbHVkZXMobWFyaykpID8gZWRpdG9yLnJlbW92ZU1hcmsobWFyaykgOiBzcGxpdFRleHROb2Rlcy5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya3MgPSBbLi4uKEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgPyBub2RlLm1hcmtzIDogW10pLmZpbHRlcigoZU1hcmspID0+IGVNYXJrICE9PSBtYXJrKSwgbWFya107XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWFya3NcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICAgICAgICBzcGxpdDogITAsXG4gICAgICAgICAgICAgICAgaGFuZ2luZzogITBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pLCBsb25lbHlFbXB0eVNwYW4gPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlblswXSkgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIiA/IGJsb2NrLmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChsb25lbHlFbXB0eVNwYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSBsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10sIGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yID0gZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGV4aXN0aW5nTWFyaykgPT4gZXhpc3RpbmdNYXJrICE9PSBtYXJrKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hcmtzOiBleGlzdGluZ01hcmtzLmxlbmd0aCA9PT0gZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IubGVuZ3RoID8gWy4uLmV4aXN0aW5nTWFya3MsIG1hcmtdIDogZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3JcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSB7XG4gICAgICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgICAgICAgICB9Lm1hcmtzIHx8IFtdLCBtYXJrcyA9IHtcbiAgICAgICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30sXG4gICAgICAgICAgICAgIG1hcmtzOiBbLi4uZXhpc3RpbmdNYXJrcywgbWFya11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yLm1hcmtzID0gbWFya3MsIGZvcmNlTmV3U2VsZWN0aW9uKCksIGVkaXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCksIGZvcmNlTmV3U2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH0sIGVkaXRvci5yZW1vdmVNYXJrID0gKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKVxuICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICAgICAgICBzcGxpdDogITAsXG4gICAgICAgICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICAgICAgICB9KSwgZWRpdG9yLnNlbGVjdGlvbiAmJiBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICAgICAgICB9KV0uZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW3BhdGhbMF1dO1xuICAgICAgICAgICAgICBFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5pbmNsdWRlcyhub2RlKSAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIG1hcmtzOiAoQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSA/IG5vZGUubWFya3MgOiBbXSkuZmlsdGVyKChlTWFyaykgPT4gZU1hcmsgIT09IG1hcmspLFxuICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgbG9uZWx5RW1wdHlTcGFuID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bMF0pICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIgPyBibG9jay5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAobG9uZWx5RW1wdHlTcGFuKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvciA9IChsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10pLmZpbHRlcigoZXhpc3RpbmdNYXJrKSA9PiBleGlzdGluZ01hcmsgIT09IG1hcmspO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWFya3M6IGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dFNwYW4obm9kZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzID0ge1xuICAgICAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgICAgICAgfS5tYXJrcyB8fCBbXSwgbWFya3MgPSB7XG4gICAgICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9LFxuICAgICAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyaylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yLm1hcmtzID0ge1xuICAgICAgICAgICAgICBtYXJrczogbWFya3MubWFya3MsXG4gICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIlxuICAgICAgICAgICAgfSwgZm9yY2VOZXdTZWxlY3Rpb24oKSwgZWRpdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKSwgZm9yY2VOZXdTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfSwgZWRpdG9yLnB0ZUlzTWFya0FjdGl2ZSA9IChtYXJrKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIFJhbmdlLmlzRXhwYW5kZWQoZWRpdG9yLnNlbGVjdGlvbikgPyBzZWxlY3RlZE5vZGVzLmV2ZXJ5KChuKSA9PiB7XG4gICAgICAgIGNvbnN0IFtub2RlXSA9IG47XG4gICAgICAgIHJldHVybiBub2RlLm1hcmtzPy5pbmNsdWRlcyhtYXJrKTtcbiAgICAgIH0pIDogKHtcbiAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgIH0ubWFya3MgfHwgW10pLmluY2x1ZGVzKG1hcmspO1xuICAgIH0sIGVkaXRvci5wdGVUb2dnbGVNYXJrID0gKG1hcmspID0+IHtcbiAgICAgIGVkaXRvci5wdGVJc01hcmtBY3RpdmUobWFyaykgPyAoZGVidWckYyhgUmVtb3ZlIG1hcmsgJyR7bWFya30nYCksIEVkaXRvci5yZW1vdmVNYXJrKGVkaXRvciwgbWFyaykpIDogKGRlYnVnJGMoYEFkZCBtYXJrICcke21hcmt9J2ApLCBFZGl0b3IuYWRkTWFyayhlZGl0b3IsIG1hcmssICEwKSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckYiA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnNcIiksIGRlYnVnVmVyYm9zZSQyID0gZGVidWckYi5lbmFibGVkICYmICExO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZWRpdG9yQWN0b3IsIHR5cGVzKSB7XG4gIGxldCBwcmV2U2VsZWN0aW9uID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IGVtaXRQb3J0YWJsZVRleHRTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICBpZiAocHJldlNlbGVjdGlvbiAhPT0gZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBsZXQgcHRSYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLmdldChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmcpXG4gICAgICAgICAgICBwdFJhbmdlID0gZXhpc3Rpbmc7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVkaXRvci5jaGlsZHJlbjtcbiAgICAgICAgICAgIHB0UmFuZ2UgPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCBlZGl0b3Iuc2VsZWN0aW9uLCB0eXBlcyksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0Uuc2V0KGVkaXRvci5zZWxlY3Rpb24sIHB0UmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z1ZlcmJvc2UkMiAmJiBkZWJ1ZyRiKGBFbWl0dGluZyBzZWxlY3Rpb24gJHtKU09OLnN0cmluZ2lmeShwdFJhbmdlIHx8IG51bGwpfSAoJHtKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uKX0pYCksIHB0UmFuZ2UgPyBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogcHRSYW5nZVxuICAgICAgICB9KSA6IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJldlNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgfSwge1xuICAgICAgb25DaGFuZ2VcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iub25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoYXNDaGFuZ2VzID0gZWRpdG9yLm9wZXJhdGlvbnMubGVuZ3RoID4gMDtcbiAgICAgIG9uQ2hhbmdlKCksIGhhc0NoYW5nZXMgJiYgZW1pdFBvcnRhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGEgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhTY2hlbWFUeXBlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhTY2hlbWFUeXBlcyh7XG4gIGVkaXRvckFjdG9yLFxuICBzY2hlbWFUeXBlc1xufSkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmlzVGV4dEJsb2NrID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIGVkaXRvci5pc1RleHRTcGFuID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dFNwYW4kMSh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSwgZWRpdG9yLmlzTGlzdEJsb2NrID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dExpc3RCbG9jayh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIGVkaXRvci5pc1ZvaWQgPSAoZWxlbWVudCkgPT4gc2NoZW1hVHlwZXMuYmxvY2submFtZSAhPT0gZWxlbWVudC5fdHlwZSAmJiAoc2NoZW1hVHlwZXMuYmxvY2tPYmplY3RzLm1hcCgob2JqKSA9PiBvYmoubmFtZSkuaW5jbHVkZXMoZWxlbWVudC5fdHlwZSkgfHwgc2NoZW1hVHlwZXMuaW5saW5lT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpKSwgZWRpdG9yLmlzSW5saW5lID0gKGVsZW1lbnQpID0+IHNjaGVtYVR5cGVzLmlubGluZU9iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSAmJiBcIl9faW5saW5lXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50Ll9faW5saW5lID09PSAhMDtcbiAgICBjb25zdCB7XG4gICAgICBub3JtYWxpemVOb2RlXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKG5vZGUuX3R5cGUgPT09IHZvaWQgMCAmJiBwYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBkZWJ1ZyRhKFwiU2V0dGluZyBzcGFuIHR5cGUgb24gdGV4dCBub2RlIHdpdGhvdXQgYSB0eXBlXCIpO1xuICAgICAgICBjb25zdCBzcGFuID0gbm9kZSwga2V5ID0gc3Bhbi5fa2V5IHx8IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKTtcbiAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIC4uLnNwYW4sXG4gICAgICAgICAgX3R5cGU6IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSxcbiAgICAgICAgICBfa2V5OiBrZXlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuX2tleSA9PT0gdm9pZCAwICYmIChwYXRoLmxlbmd0aCA9PT0gMSB8fCBwYXRoLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgZGVidWckYShcIlNldHRpbmcgbWlzc2luZyBrZXkgb24gY2hpbGQgbm9kZSB3aXRob3V0IGEga2V5XCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBfa2V5OiBrZXlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckOSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFV0aWxzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFV0aWxzKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHNjaGVtYVR5cGVzLFxuICBwb3J0YWJsZVRleHRFZGl0b3Jcbn0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlRXhwYW5kVG9Xb3JkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICBpZiAoc2VsZWN0aW9uICYmICFSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgW3RleHROb2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzLCB7XG4gICAgICAgICAgZGVwdGg6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIVRleHQuaXNUZXh0KHRleHROb2RlKSB8fCB0ZXh0Tm9kZS50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlYnVnJDkoXCJwdGVFeHBhbmRUb1dvcmQ6IENhbid0IGV4cGFuZCB0byB3b3JkIGhlcmVcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb2N1c1xuICAgICAgICB9ID0gc2VsZWN0aW9uLCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldCwgY2hhcnNCZWZvcmUgPSB0ZXh0Tm9kZS50ZXh0LnNsaWNlKDAsIGZvY3VzT2Zmc2V0KSwgY2hhcnNBZnRlciA9IHRleHROb2RlLnRleHQuc2xpY2UoZm9jdXNPZmZzZXQsIC0xKSwgaXNFbXB0eSA9IChzdHIpID0+IHN0ci5tYXRjaCgvXFxzL2cpLCB3aGl0ZVNwYWNlQmVmb3JlSW5kZXggPSBjaGFyc0JlZm9yZS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuZmluZEluZGV4KChzdHIpID0+IGlzRW1wdHkoc3RyKSksIG5ld1N0YXJ0T2Zmc2V0ID0gd2hpdGVTcGFjZUJlZm9yZUluZGV4ID4gLTEgPyBjaGFyc0JlZm9yZS5sZW5ndGggLSB3aGl0ZVNwYWNlQmVmb3JlSW5kZXggOiAwLCB3aGl0ZVNwYWNlQWZ0ZXJJbmRleCA9IGNoYXJzQWZ0ZXIuc3BsaXQoXCJcIikuZmluZEluZGV4KChvYmopID0+IGlzRW1wdHkob2JqKSksIG5ld0VuZE9mZnNldCA9IGNoYXJzQmVmb3JlLmxlbmd0aCArICh3aGl0ZVNwYWNlQWZ0ZXJJbmRleCA+IC0xID8gd2hpdGVTcGFjZUFmdGVySW5kZXggOiBjaGFyc0FmdGVyLmxlbmd0aCArIDEpO1xuICAgICAgICBpZiAoIShuZXdTdGFydE9mZnNldCA9PT0gbmV3RW5kT2Zmc2V0IHx8IE51bWJlci5pc05hTihuZXdTdGFydE9mZnNldCkgfHwgTnVtYmVyLmlzTmFOKG5ld0VuZE9mZnNldCkpKSB7XG4gICAgICAgICAgZGVidWckOShcInB0ZUV4cGFuZFRvV29yZDogRXhwYW5kaW5nIHRvIGZvY3VzZWQgd29yZFwiKSwgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgICAgLi4uc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgICAgICAgb2Zmc2V0OiBuZXdTdGFydE9mZnNldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgIC4uLnNlbGVjdGlvbi5mb2N1cyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBuZXdFbmRPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWckOShcInB0ZUV4cGFuZFRvV29yZDogQ2FuJ3QgZXhwYW5kIHRvIHdvcmQgaGVyZVwiKTtcbiAgICAgIH1cbiAgICB9LCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrID0gKG9wdGlvbnMpID0+IHRvU2xhdGVWYWx1ZShbe1xuICAgICAgX3R5cGU6IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsXG4gICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICBzdHlsZTogc2NoZW1hVHlwZXMuc3R5bGVzWzBdLnZhbHVlIHx8IFwibm9ybWFsXCIsXG4gICAgICAuLi5vcHRpb25zLmxpc3RJdGVtID8ge1xuICAgICAgICBsaXN0SXRlbTogb3B0aW9ucy5saXN0SXRlbVxuICAgICAgfSA6IHt9LFxuICAgICAgLi4ub3B0aW9ucy5sZXZlbCA/IHtcbiAgICAgICAgbGV2ZWw6IG9wdGlvbnMubGV2ZWxcbiAgICAgIH0gOiB7fSxcbiAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWFya3M6IG9wdGlvbnMuZGVjb3JhdG9ycy5maWx0ZXIoKGRlY29yYXRvcikgPT4gc2NoZW1hVHlwZXMuZGVjb3JhdG9ycy5maW5kKCh7XG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSkgPT4gdmFsdWUgPT09IGRlY29yYXRvcikpXG4gICAgICB9XVxuICAgIH1dLCBwb3J0YWJsZVRleHRFZGl0b3IpWzBdLCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyQ4ID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoSG90S2V5c1wiKSwgREVGQVVMVF9IT1RLRVlTID0ge1xuICBtYXJrczoge1xuICAgIFwibW9kK2JcIjogXCJzdHJvbmdcIixcbiAgICBcIm1vZCtpXCI6IFwiZW1cIixcbiAgICBcIm1vZCt1XCI6IFwidW5kZXJsaW5lXCIsXG4gICAgXCJtb2QrJ1wiOiBcImNvZGVcIlxuICB9LFxuICBjdXN0b206IHt9XG59O1xuZnVuY3Rpb24gY3JlYXRlV2l0aEhvdGtleXMocG9ydGFibGVUZXh0RWRpdG9yLCBob3RrZXlzRnJvbU9wdGlvbnMpIHtcbiAgY29uc3QgcmVzZXJ2ZWRIb3RrZXlzID0gW1wiZW50ZXJcIiwgXCJ0YWJcIiwgXCJzaGlmdFwiLCBcImRlbGV0ZVwiLCBcImVuZFwiXSwgYWN0aXZlSG90a2V5cyA9IGhvdGtleXNGcm9tT3B0aW9ucyB8fCBERUZBVUxUX0hPVEtFWVM7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnB0ZVdpdGhIb3RLZXlzID0gKGV2ZW50KSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhhY3RpdmVIb3RrZXlzKS5mb3JFYWNoKChjYXQpID0+IHtcbiAgICAgICAgaWYgKGNhdCA9PT0gXCJtYXJrc1wiKVxuICAgICAgICAgIGZvciAoY29uc3QgaG90a2V5IGluIGFjdGl2ZUhvdGtleXNbY2F0XSkge1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkSG90a2V5cy5pbmNsdWRlcyhob3RrZXkpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBob3RrZXkgJHtob3RrZXl9IGlzIHJlc2VydmVkIWApO1xuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGhvdGtleSwgZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlTWFyayA9IGFjdGl2ZUhvdGtleXNbY2F0XTtcbiAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlTWFyaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsgPSBwb3NzaWJsZU1hcmtbaG90a2V5XTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQ4KGBIb3RLZXkgJHtob3RrZXl9IHRvIHRvZ2dsZSAke21hcmt9YCksIGVkaXRvci5wdGVUb2dnbGVNYXJrKG1hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoY2F0ID09PSBcImN1c3RvbVwiKVxuICAgICAgICAgIGZvciAoY29uc3QgaG90a2V5IGluIGFjdGl2ZUhvdGtleXNbY2F0XSkge1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkSG90a2V5cy5pbmNsdWRlcyhob3RrZXkpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBob3RrZXkgJHtob3RrZXl9IGlzIHJlc2VydmVkIWApO1xuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGhvdGtleSwgZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlQ29tbWFuZCA9IGFjdGl2ZUhvdGtleXNbY2F0XTtcbiAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBwb3NzaWJsZUNvbW1hbmRbaG90a2V5XTtcbiAgICAgICAgICAgICAgICBjb21tYW5kKGV2ZW50LCBwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBpc0VudGVyID0gaXNIb3RrZXkoXCJlbnRlclwiLCBldmVudC5uYXRpdmVFdmVudCksIGlzVGFiID0gaXNIb3RrZXkoXCJ0YWJcIiwgZXZlbnQubmF0aXZlRXZlbnQpLCBpc1NoaWZ0RW50ZXIgPSBpc0hvdGtleShcInNoaWZ0K2VudGVyXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KSwgaXNTaGlmdFRhYiA9IGlzSG90a2V5KFwic2hpZnQrdGFiXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KSwgaXNBcnJvd0Rvd24gPSBpc0hvdGtleShcImRvd25cIiwgZXZlbnQubmF0aXZlRXZlbnQpLCBpc0Fycm93VXAgPSBpc0hvdGtleShcInVwXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGlmIChpc0Fycm93RG93biAmJiBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICBpZiAoZm9jdXNCbG9jayAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgZm9jdXNCbG9jaykpIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFBhdGgubmV4dChlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICAgIGlmICghTm9kZS5oYXMoZWRpdG9yLCBuZXh0UGF0aCkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgIGF0OiBuZXh0UGF0aFxuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwge1xuICAgICAgICAgICAgICBwYXRoOiBbLi4ubmV4dFBhdGgsIDBdLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0Fycm93VXAgJiYgZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBpc0ZpcnN0QmxvY2sgPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0gPT09IDAsIGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICBpZiAoaXNGaXJzdEJsb2NrICYmIGZvY3VzQmxvY2sgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIGZvY3VzQmxvY2spKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IFswXVxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgoaXNUYWIgfHwgaXNTaGlmdFRhYikgJiYgZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBbZm9jdXNDaGlsZF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMsIHtcbiAgICAgICAgICBkZXB0aDogMlxuICAgICAgICB9KSwgW2ZvY3VzQmxvY2tdID0gaXNQb3J0YWJsZVRleHRTcGFuJDEoZm9jdXNDaGlsZCkgPyBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMsIHtcbiAgICAgICAgICBkZXB0aDogMVxuICAgICAgICB9KSA6IFtdLCBoYXNBbm5vdGF0aW9uRm9jdXMgPSBmb2N1c0NoaWxkICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGZvY3VzQmxvY2spICYmIGlzUG9ydGFibGVUZXh0U3BhbiQxKGZvY3VzQ2hpbGQpICYmIChmb2N1c0NoaWxkLm1hcmtzIHx8IFtdKS5maWx0ZXIoKG0pID0+IChmb2N1c0Jsb2NrLm1hcmtEZWZzIHx8IFtdKS5tYXAoKGRlZikgPT4gZGVmLl9rZXkpLmluY2x1ZGVzKG0pKS5sZW5ndGggPiAwLCBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoZWRpdG9yLnNlbGVjdGlvbiksIGF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgICAgZm9jdXNDaGlsZCAmJiBpc1BvcnRhYmxlVGV4dFNwYW4kMShmb2N1c0NoaWxkKSAmJiAoIWhhc0Fubm90YXRpb25Gb2N1cyB8fCBhdFN0YXJ0T2ZOb2RlKSAmJiBlZGl0b3IucHRlSW5jcmVtZW50QmxvY2tMZXZlbHMoaXNTaGlmdFRhYikgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VudGVyICYmICFpc1NoaWZ0RW50ZXIgJiYgZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBmb2N1c0Jsb2NrUGF0aCA9IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSwgZm9jdXNCbG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGZvY3VzQmxvY2tQYXRoKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc0xpc3RCbG9jayhmb2N1c0Jsb2NrKSkge1xuICAgICAgICAgIGVkaXRvci5wdGVFbmRMaXN0KCkgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlLCB0eXBlcywga2V5R2VuZXJhdG9yKSB7XG4gIGxldCByZXNvbHV0aW9uID0gbnVsbCwgdmFsaWQgPSAhMDtcbiAgY29uc3QgdmFsaWRDaGlsZFR5cGVzID0gW3R5cGVzLnNwYW4ubmFtZSwgLi4udHlwZXMuaW5saW5lT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldLCB2YWxpZEJsb2NrVHlwZXMgPSBbdHlwZXMuYmxvY2submFtZSwgLi4udHlwZXMuYmxvY2tPYmplY3RzLm1hcCgodCkgPT4gdC5uYW1lKV07XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgIHZhbGlkOiAhMCxcbiAgICByZXNvbHV0aW9uOiBudWxsLFxuICAgIHZhbHVlXG4gIH0gOiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwID8ge1xuICAgIHZhbGlkOiAhMSxcbiAgICByZXNvbHV0aW9uOiB7XG4gICAgICBwYXRjaGVzOiBbdW5zZXQoW10pXSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkVkaXRvciB2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIFBvcnRhYmxlIFRleHQgYmxvY2tzLCBvciB1bmRlZmluZWQuXCIsXG4gICAgICBhY3Rpb246IFwiVW5zZXQgdGhlIHZhbHVlXCIsXG4gICAgICBpdGVtOiB2YWx1ZSxcbiAgICAgIGkxOG46IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tYXJyYXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmFjdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZVxuICB9IDogKHZhbHVlLnNvbWUoKGJsaywgaW5kZXgyKSA9PiB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGJsaykpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFtpbmRleDJdKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCAke1N0cmluZyhibGspfWAsXG4gICAgICAgIGFjdGlvbjogXCJVbnNldCBpbnZhbGlkIGl0ZW1cIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tb2JqZWN0LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLW9iamVjdC5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl9rZXkgfHwgdHlwZW9mIGJsay5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgIH0sIFtpbmRleDJdKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgYXQgaW5kZXggJHtpbmRleDJ9IGlzIG1pc3NpbmcgcmVxdWlyZWQgX2tleS5gLFxuICAgICAgICBhY3Rpb246IFwiU2V0IHRoZSBibG9jayB3aXRoIGEgcmFuZG9tIF9rZXkgdmFsdWVcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmcta2V5LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4MlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITA7XG4gICAgaWYgKCFibGsuX3R5cGUgfHwgIXZhbGlkQmxvY2tUeXBlcy5pbmNsdWRlcyhibGsuX3R5cGUpKSB7XG4gICAgICBpZiAoYmxrLl90eXBlID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEJsb2NrVHlwZU5hbWUgPSB0eXBlcy5ibG9jay5uYW1lO1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAgIC4uLmJsayxcbiAgICAgICAgICAgIF90eXBlOiBjdXJyZW50QmxvY2tUeXBlTmFtZVxuICAgICAgICAgIH0sIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCB0eXBlIG5hbWUgJyR7YmxrLl90eXBlfScuIEFjY29yZGluZyB0byB0aGUgc2NoZW1hLCB0aGUgYmxvY2sgdHlwZSBuYW1lIGlzICcke2N1cnJlbnRCbG9ja1R5cGVOYW1lfSdgLFxuICAgICAgICAgIGFjdGlvbjogYFVzZSB0eXBlICcke2N1cnJlbnRCbG9ja1R5cGVOYW1lfSdgLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmluY29ycmVjdC1ibG9jay10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbmNvcnJlY3QtYmxvY2stdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBleHBlY3RlZFR5cGVOYW1lOiBjdXJyZW50QmxvY2tUeXBlTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWJsay5fdHlwZSAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayh7XG4gICAgICAgIC4uLmJsayxcbiAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgIH0pID8gKHJlc29sdXRpb24gPSB7XG4gICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgIC4uLmJsayxcbiAgICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZVxuICAgICAgICB9LCBbe1xuICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgIH1dKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyBhIHR5cGUgbmFtZS4gQWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEsIHRoZSBibG9jayB0eXBlIG5hbWUgaXMgJyR7dHlwZXMuYmxvY2submFtZX0nYCxcbiAgICAgICAgYWN0aW9uOiBgVXNlIHR5cGUgJyR7dHlwZXMuYmxvY2submFtZX0nYCxcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWJsb2NrLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWJsb2NrLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlTmFtZTogdHlwZXMuYmxvY2submFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApIDogYmxrLl90eXBlID8gKHJlc29sdXRpb24gPSB7XG4gICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgIH1dKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaGFzIGludmFsaWQgX3R5cGUgJyR7YmxrLl90eXBlfSdgLFxuICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBibG9ja1wiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICB0eXBlTmFtZTogYmxrLl90eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMCkgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgfV0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBpcyBtaXNzaW5nIGFuIF90eXBlIHByb3BlcnR5YCxcbiAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgYmxvY2tcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBrZXk6IGJsay5fa2V5XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMCk7XG4gICAgfVxuICAgIGlmIChibGsuX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWUpIHtcbiAgICAgIGNvbnN0IHRleHRCbG9jayA9IGJsaztcbiAgICAgIGlmICh0ZXh0QmxvY2suY2hpbGRyZW4gJiYgIUFycmF5LmlzQXJyYXkodGV4dEJsb2NrLmNoaWxkcmVuKSlcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICB9LCBbe1xuICAgICAgICAgICAgX2tleTogdGV4dEJsb2NrLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgVGV4dCBibG9jayB3aXRoIF9rZXkgJyR7dGV4dEJsb2NrLl9rZXl9JyBoYXMgYSBpbnZhbGlkIHJlcXVpcmVkIHByb3BlcnR5ICdjaGlsZHJlbicuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVzZXQgdGhlIGNoaWxkcmVuIHByb3BlcnR5XCIsXG4gICAgICAgICAgaXRlbTogdGV4dEJsb2NrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1vci1pbnZhbGlkLWNoaWxkcmVuLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLW9yLWludmFsaWQtY2hpbGRyZW4uYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiB0ZXh0QmxvY2suX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITA7XG4gICAgICBpZiAodGV4dEJsb2NrLmNoaWxkcmVuID09PSB2b2lkIDAgfHwgQXJyYXkuaXNBcnJheSh0ZXh0QmxvY2suY2hpbGRyZW4pICYmIHRleHRCbG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgbmV3U3BhbiA9IHtcbiAgICAgICAgICBfdHlwZTogdHlwZXMuc3Bhbi5uYW1lLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0SWZNaXNzaW5nKFtdLCBbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCJdKSwgaW5zZXJ0KFtuZXdTcGFuXSwgXCJhZnRlclwiLCBbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIDBdKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZHJlbiBmb3IgdGV4dCBibG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBpcyBlbXB0eS5gLFxuICAgICAgICAgIGFjdGlvbjogXCJJbnNlcnQgYW4gZW1wdHkgdGV4dFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmVtcHR5LWNoaWxkcmVuLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5lbXB0eS1jaGlsZHJlbi5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsbFVzZWRNYXJrcyA9IHVuaXEoZmxhdHRlbih0ZXh0QmxvY2suY2hpbGRyZW4uZmlsdGVyKChjbGQpID0+IGNsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lKS5tYXAoKGNsZCkgPT4gY2xkLm1hcmtzIHx8IFtdKSkpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmxrLm1hcmtEZWZzKSAmJiBibGsubWFya0RlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB1bnVzZWRNYXJrRGVmcyA9IHVuaXEoYmxrLm1hcmtEZWZzLm1hcCgoZGVmKSA9PiBkZWYuX2tleSkuZmlsdGVyKChrZXkpID0+ICFhbGxVc2VkTWFya3MuaW5jbHVkZXMoa2V5KSkpO1xuICAgICAgICBpZiAodW51c2VkTWFya0RlZnMubGVuZ3RoID4gMClcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICAgIHBhdGNoZXM6IHVudXNlZE1hcmtEZWZzLm1hcCgobWFya0RlZktleSkgPT4gdW5zZXQoW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwibWFya0RlZnNcIiwge1xuICAgICAgICAgICAgICBfa2V5OiBtYXJrRGVmS2V5XG4gICAgICAgICAgICB9XSkpLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBjb250YWlucyBvcnBoYW5lZCBkYXRhICh1bnVzZWQgbWFyayBkZWZpbml0aW9ucyk6ICR7dW51c2VkTWFya0RlZnMuam9pbihcIiwgXCIpfS5gLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB1bnVzZWQgbWFyayBkZWZpbml0aW9uIGl0ZW1cIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrLWRlZnMuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFyay1kZWZzLmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIHVudXNlZE1hcmtEZWZzOiB1bnVzZWRNYXJrRGVmcy5tYXAoKG0pID0+IG0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JwaGFuZWRNYXJrcyA9IGFsbFVzZWRNYXJrcy5maWx0ZXIoKG1hcmspID0+ICF0eXBlcy5kZWNvcmF0b3JzLm1hcCgoZGVjKSA9PiBkZWMudmFsdWUpLmluY2x1ZGVzKG1hcmspKS5maWx0ZXIoKG1hcmspID0+IHRleHRCbG9jay5tYXJrRGVmcyA9PT0gdm9pZCAwIHx8ICF0ZXh0QmxvY2subWFya0RlZnMuZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgaWYgKG9ycGhhbmVkTWFya3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzcGFuQ2hpbGRyZW4gPSB0ZXh0QmxvY2suY2hpbGRyZW4uZmlsdGVyKChjbGQpID0+IGNsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIEFycmF5LmlzQXJyYXkoY2xkLm1hcmtzKSAmJiBjbGQubWFya3Muc29tZSgobWFyaykgPT4gb3JwaGFuZWRNYXJrcy5pbmNsdWRlcyhtYXJrKSkpO1xuICAgICAgICBpZiAoc3BhbkNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3Qgb3JwaGFuZWQgPSBvcnBoYW5lZE1hcmtzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICAgIHBhdGNoZXM6IHNwYW5DaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBzZXQoKGNoaWxkLm1hcmtzIHx8IFtdKS5maWx0ZXIoKGNNcmspID0+ICFvcnBoYW5lZE1hcmtzLmluY2x1ZGVzKGNNcmspKSwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9LCBcIm1hcmtzXCJdKSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGNvbnRhaW5zIG1hcmtzICgke29ycGhhbmVkfSkgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBjb250ZW50IG1vZGVsLmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIGludmFsaWQgbWFya3NcIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICBvcnBoYW5lZE1hcmtzOiBvcnBoYW5lZE1hcmtzLm1hcCgobSkgPT4gbS50b1N0cmluZygpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRleHRCbG9jay5jaGlsZHJlbi5zb21lKChjaGlsZCwgY0luZGV4KSA9PiB7XG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdChjaGlsZCkpXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgY0luZGV4XSldLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCBhdCBpbmRleCAnJHtjSW5kZXh9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGlzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGl0ZW1cIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub24tb2JqZWN0LWNoaWxkLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vbi1vYmplY3QtY2hpbGQuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGNJbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIGlmICghY2hpbGQuX2tleSB8fCB0eXBlb2YgY2hpbGQuX2tleSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICAgIHBhdGNoZXM6IFtzZXQobmV3Q2hpbGQsIFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIGNJbmRleF0pXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgYXQgaW5kZXggJHtjSW5kZXh9IGlzIG1pc3NpbmcgcmVxdWlyZWQgX2tleSBpbiBibG9jayB3aXRoIF9rZXkgJHtibGsuX2tleX0uYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJTZXQgYSBuZXcgcmFuZG9tIF9rZXkgb24gdGhlIG9iamVjdFwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQta2V5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQta2V5LmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIGluZGV4OiBjSW5kZXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZC5fdHlwZSA/IHZhbGlkQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC5fdHlwZSkgPyBjaGlsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIHR5cGVvZiBjaGlsZC50ZXh0ICE9IFwic3RyaW5nXCIgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH0sIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaGFzIG1pc3Npbmcgb3IgaW52YWxpZCB0ZXh0IHByb3BlcnR5IWAsXG4gICAgICAgICAgYWN0aW9uOiBcIldyaXRlIGFuIGVtcHR5IHRleHQgcHJvcGVydHkgdG8gdGhlIG9iamVjdFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmludmFsaWQtc3Bhbi10ZXh0LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbnZhbGlkLXNwYW4tdGV4dC5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApIDogITEgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCAnX3R5cGUnIHByb3BlcnR5ICgke2NoaWxkLl90eXBlfSkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLWNoaWxkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtY2hpbGQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRUeXBlOiBjaGlsZC5fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyAnX3R5cGUnIHByb3BlcnR5LmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRLZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwKTtcbiAgICAgIH0pICYmICh2YWxpZCA9ICExKTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9KSAmJiAodmFsaWQgPSAhMSksIHtcbiAgICB2YWxpZCxcbiAgICByZXNvbHV0aW9uLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuY29uc3QgZGVidWckNyA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aEluc2VydERhdGFcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoSW5zZXJ0RGF0YShlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IGJsb2NrVHlwZU5hbWUgPSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBzcGFuVHlwZU5hbWUgPSBzY2hlbWFUeXBlcy5zcGFuLm5hbWUsIHdoaXRlc3BhY2VPblBhc3RlTW9kZSA9IHNjaGVtYVR5cGVzLmJsb2NrLm9wdGlvbnMudW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlLCB0b1BsYWluVGV4dCA9IChibG9ja3MpID0+IGJsb2Nrcy5tYXAoKGJsb2NrKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spID8gYmxvY2suY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuX3R5cGUgPT09IHNwYW5UeXBlTmFtZSA/IGNoaWxkLnRleHQgOiBgWyR7c2NoZW1hVHlwZXMuaW5saW5lT2JqZWN0cy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGNoaWxkLl90eXBlKT8udGl0bGUgfHwgXCJPYmplY3RcIn1dYCkuam9pbihcIlwiKSA6IGBbJHtzY2hlbWFUeXBlcy5ibG9ja09iamVjdHMuZmluZCgodCkgPT4gdC5uYW1lID09PSBibG9jay5fdHlwZSk/LnRpdGxlIHx8IFwiT2JqZWN0XCJ9XWApLmpvaW4oYFxuXG5gKTtcbiAgICByZXR1cm4gZWRpdG9yLnNldEZyYWdtZW50RGF0YSA9IChkYXRhLCBvcmlnaW5FdmVudCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKSwgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgICB9KSwgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLnBhdGhcbiAgICAgIH0pO1xuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgIXN0YXJ0Vm9pZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZG9tUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGxldCBjb250ZW50cyA9IGRvbVJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICAgIGNvbnN0IFt2b2lkTm9kZV0gPSBlbmRWb2lkLCByID0gZG9tUmFuZ2UuY2xvbmVSYW5nZSgpLCBkb21Ob2RlID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgdm9pZE5vZGUpO1xuICAgICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpLCBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpO1xuICAgICAgfVxuICAgICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtc2xhdGUtemVyby13aWR0aF1cIikpLmZvckVhY2goKHp3KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZShcImRhdGEtc2xhdGUtemVyby13aWR0aFwiKSA9PT0gXCJuXCI7XG4gICAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gYFxuYCA6IFwiXCI7XG4gICAgICB9KSwgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZm9yRWFjaCgoZWxtKSA9PiB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNsYXRlLWlubGluZVwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtbGVhZlwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtbm9kZVwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtc3BhY2VyXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1zdHJpbmdcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNsYXRlLXplcm8td2lkdGhcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGVsbS5hdHRyaWJ1dGVzKVxuICAgICAgICAgIGVsbS5oYXNBdHRyaWJ1dGUoa2V5KSAmJiBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRpdiA9IGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50cyksIGRpdi5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgXCJ0cnVlXCIpLCBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIGNvbnN0IGFzSFRNTCA9IGRpdi5pbm5lckhUTUw7XG4gICAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZWRpdG9yLmdldEZyYWdtZW50KCksIHBvcnRhYmxlVGV4dCA9IGZyb21TbGF0ZVZhbHVlKGZyYWdtZW50LCBibG9ja1R5cGVOYW1lKSwgYXNKU09OID0gSlNPTi5zdHJpbmdpZnkocG9ydGFibGVUZXh0KSwgYXNQbGFpblRleHQgPSB0b1BsYWluVGV4dChwb3J0YWJsZVRleHQpO1xuICAgICAgZGF0YS5jbGVhckRhdGEoKSwgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBhc1BsYWluVGV4dCksIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBhc0hUTUwpLCBkYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9qc29uXCIsIGFzSlNPTiksIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLCBhc0pTT04pLCBkZWJ1ZyQ3KFwidGV4dFwiLCBhc1BsYWluVGV4dCksIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dC1ldmVudC1vcmlnaW5cIiwgb3JpZ2luRXZlbnQgfHwgXCJleHRlcm5hbFwiKSwgZGVidWckNyhcIlNldCBmcmFnbWVudCBkYXRhXCIsIGFzSlNPTiwgYXNIVE1MKTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0UG9ydGFibGVUZXh0RGF0YSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHBUZXh0ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIpLCBvcmlnaW4gPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHQtZXZlbnQtb3JpZ2luXCIpO1xuICAgICAgaWYgKGRlYnVnJDcoYEluc2VydGluZyBwb3J0YWJsZSB0ZXh0IGZyb20gJHtvcmlnaW59IGV2ZW50YCwgcFRleHQpLCBwVGV4dCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHBUZXh0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkKSAmJiBwYXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNsYXRlVmFsdWUgPSBfcmVnZW5lcmF0ZUtleXMoZWRpdG9yLCB0b1NsYXRlVmFsdWUocGFyc2VkLCB7XG4gICAgICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLCBzcGFuVHlwZU5hbWUsIHNjaGVtYVR5cGVzKSwgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUocGFyc2VkLCBzY2hlbWFUeXBlcywgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgICAgaWYgKCF2YWxpZGF0aW9uLnZhbGlkICYmICF2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gYCR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5kZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIG5hbWU6IFwicGFzdGVFcnJvclwiLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyb3JEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgZGF0YTogdmFsaWRhdGlvblxuICAgICAgICAgICAgfSksIGRlYnVnJDcoXCJJbnZhbGlkIGluc2VydCByZXN1bHRcIiwgdmFsaWRhdGlvbiksICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX2luc2VydEZyYWdtZW50KGVkaXRvciwgc2xhdGVWYWx1ZSwgc2NoZW1hVHlwZXMpLCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGVkaXRvci5pbnNlcnRUZXh0T3JIVE1MRGF0YSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiBkZWJ1ZyQ3KFwiTm8gc2VsZWN0aW9uLCBub3QgaW5zZXJ0aW5nXCIpLCAhMTtcbiAgICAgIGNvbnN0IGh0bWwgPSBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHRleHQgPSBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgaWYgKGh0bWwgfHwgdGV4dCkge1xuICAgICAgICBkZWJ1ZyQ3KFwiSW5zZXJ0aW5nIGRhdGFcIiwgZGF0YSk7XG4gICAgICAgIGxldCBwb3J0YWJsZVRleHQsIGZyYWdtZW50LCBpbnNlcnRlZFR5cGU7XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaWYgKHBvcnRhYmxlVGV4dCA9IGh0bWxUb0Jsb2NrcyhodG1sLCBzY2hlbWFUeXBlcy5wb3J0YWJsZVRleHQsIHtcbiAgICAgICAgICAgIHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZTogd2hpdGVzcGFjZU9uUGFzdGVNb2RlXG4gICAgICAgICAgfSkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHtcbiAgICAgICAgICAgIGJsb2NrVHlwZU5hbWVcbiAgICAgICAgICB9KSksIGZyYWdtZW50ID0gdG9TbGF0ZVZhbHVlKHBvcnRhYmxlVGV4dCwge1xuICAgICAgICAgICAgc2NoZW1hVHlwZXNcbiAgICAgICAgICB9KSwgaW5zZXJ0ZWRUeXBlID0gXCJIVE1MXCIsIHBvcnRhYmxlVGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGV4dFRvSHRtbCA9IGA8aHRtbD48Ym9keT4ke2VzY2FwZUh0bWwodGV4dCkuc3BsaXQoL1xcbnsyLH0vKS5tYXAoKGxpbmUpID0+IGxpbmUgPyBgPHA+JHtsaW5lLnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCBcIjxici8+XCIpfTwvcD5gIDogXCI8cD48L3A+XCIpLmpvaW4oXCJcIil9PC9ib2R5PjwvaHRtbD5gO1xuICAgICAgICAgIHBvcnRhYmxlVGV4dCA9IGh0bWxUb0Jsb2Nrcyh0ZXh0VG9IdG1sLCBzY2hlbWFUeXBlcy5wb3J0YWJsZVRleHQpLm1hcCgoYmxvY2spID0+IG5vcm1hbGl6ZUJsb2NrKGJsb2NrLCB7XG4gICAgICAgICAgICBibG9ja1R5cGVOYW1lXG4gICAgICAgICAgfSkpLCBmcmFnbWVudCA9IHRvU2xhdGVWYWx1ZShwb3J0YWJsZVRleHQsIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGVzXG4gICAgICAgICAgfSksIGluc2VydGVkVHlwZSA9IFwidGV4dFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZVZhbHVlKHBvcnRhYmxlVGV4dCwgc2NoZW1hVHlwZXMsIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IpO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gYENvdWxkIG5vdCB2YWxpZGF0ZSB0aGUgcmVzdWx0aW5nIHBvcnRhYmxlIHRleHQgdG8gaW5zZXJ0LlxuJHt2YWxpZGF0aW9uLnJlc29sdXRpb24/LmRlc2NyaXB0aW9ufVxuVHJ5IHRvIGluc2VydCBhcyBwbGFpbiB0ZXh0IChzaGlmdC1wYXN0ZSkgaW5zdGVhZC5gO1xuICAgICAgICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG5hbWU6IFwicGFzdGVFcnJvclwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yRGVzY3JpcHRpb24sXG4gICAgICAgICAgICBkYXRhOiB2YWxpZGF0aW9uXG4gICAgICAgICAgfSksIGRlYnVnJDcoXCJJbnZhbGlkIGluc2VydCByZXN1bHRcIiwgdmFsaWRhdGlvbiksICExO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWJ1ZyQ3KGBJbnNlcnRpbmcgJHtpbnNlcnRlZFR5cGV9IGZyYWdtZW50IGF0ICR7SlNPTi5zdHJpbmdpZnkoZWRpdG9yLnNlbGVjdGlvbil9YCksIF9pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBzY2hlbWFUeXBlcyksICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGVkaXRvci5pbnNlcnREYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGVkaXRvci5pbnNlcnRQb3J0YWJsZVRleHREYXRhKGRhdGEpIHx8IGVkaXRvci5pbnNlcnRUZXh0T3JIVE1MRGF0YShkYXRhKTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIpO1xuICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gZWRpdG9yLmluc2VydEZyYWdtZW50KHBhcnNlZCksICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGVudGl0eU1hcCA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCIsXG4gIFwiL1wiOiBcIiYjeDJGO1wiLFxuICBcImBcIjogXCImI3g2MDtcIixcbiAgXCI9XCI6IFwiJiN4M0Q7XCJcbn07XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvWyY8PlwiJ2A9L10vZywgKHMpID0+IGVudGl0eU1hcFtzXSk7XG59XG5mdW5jdGlvbiBfcmVnZW5lcmF0ZUtleXMoZWRpdG9yLCBmcmFnbWVudCwga2V5R2VuZXJhdG9yLCBzcGFuVHlwZU5hbWUsIGVkaXRvclR5cGVzKSB7XG4gIHJldHVybiBmcmFnbWVudC5tYXAoKG5vZGUpID0+IHtcbiAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgLi4ubm9kZVxuICAgIH07XG4gICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhuZXdOb2RlKSkge1xuICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBlZGl0b3JUeXBlcy5hbm5vdGF0aW9ucy5tYXAoKHQpID0+IHQubmFtZSk7XG4gICAgICBpZiAoYW5ub3RhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtYXJrRGVmcyxcbiAgICAgICAgICAuLi5OZXdOb2RlTm9EZWZzXG4gICAgICAgIH0gPSBuZXdOb2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLk5ld05vZGVOb0RlZnMsXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICgobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkuc29tZSgoZGVmKSA9PiAhYW5ub3RhdGlvbnMuaW5jbHVkZXMoZGVmLl90eXBlKSkpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZEFubm90YXRpb25zID0gKG5ld05vZGUubWFya0RlZnMgfHwgW10pLmZpbHRlcigoZGVmKSA9PiBhbm5vdGF0aW9ucy5pbmNsdWRlcyhkZWYuX3R5cGUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdOb2RlLFxuICAgICAgICAgIG1hcmtEZWZzOiBhbGxvd2VkQW5ub3RhdGlvbnMsXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG5ld05vZGUubWFya0RlZnMgPSAobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkubWFwKChkZWYpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkS2V5ID0gZGVmLl9rZXksIG5ld0tleSA9IGtleUdlbmVyYXRvcigpO1xuICAgICAgICByZXR1cm4gbmV3Tm9kZS5jaGlsZHJlbiA9IG5ld05vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuX3R5cGUgPT09IHNwYW5UeXBlTmFtZSAmJiBlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgPyB7XG4gICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgbWFya3M6IGNoaWxkLm1hcmtzICYmIGNoaWxkLm1hcmtzLmluY2x1ZGVzKG9sZEtleSkgPyBbLi4uY2hpbGQubWFya3NdLmZpbHRlcigobWFyaykgPT4gbWFyayAhPT0gb2xkS2V5KS5jb25jYXQobmV3S2V5KSA6IGNoaWxkLm1hcmtzXG4gICAgICAgIH0gOiBjaGlsZCksIHtcbiAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgX2tleTogbmV3S2V5XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVdpdGhOZXdLZXlzID0ge1xuICAgICAgLi4ubmV3Tm9kZSxcbiAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgfTtcbiAgICByZXR1cm4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGVXaXRoTmV3S2V5cykgJiYgKG5vZGVXaXRoTmV3S2V5cy5jaGlsZHJlbiA9IG5vZGVXaXRoTmV3S2V5cy5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiAoe1xuICAgICAgLi4uY2hpbGQsXG4gICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgIH0pKSksIG5vZGVXaXRoTmV3S2V5cztcbiAgfSk7XG59XG5mdW5jdGlvbiBfaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCwgc2NoZW1hVHlwZXMpIHtcbiAgZWRpdG9yLndpdGhvdXROb3JtYWxpemluZygoKSA9PiB7XG4gICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFtmb2N1c0Jsb2NrLCBmb2N1c1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICBkZXB0aDogMVxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKGZyYWdtZW50WzBdKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYXJrRGVmc1xuICAgICAgfSA9IGZvY3VzQmxvY2s7XG4gICAgICBkZWJ1ZyQ3KFwiTWl4aW5nIG1hcmtEZWZzIG9mIGZvY3VzQmxvY2sgYW5kIGZyYWdtZW50c1swXSBibG9ja1wiLCBtYXJrRGVmcywgZnJhZ21lbnRbMF0ubWFya0RlZnMpLCBpc0VxdWFsKG1hcmtEZWZzLCBmcmFnbWVudFswXS5tYXJrRGVmcykgfHwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya0RlZnM6IHVuaXEoWy4uLmZyYWdtZW50WzBdLm1hcmtEZWZzIHx8IFtdLCAuLi5tYXJrRGVmcyB8fCBbXV0pXG4gICAgICB9LCB7XG4gICAgICAgIGF0OiBmb2N1c1BhdGgsXG4gICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgIHZvaWRzOiAhMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzRXF1YWxUb0VtcHR5RWRpdG9yKGVkaXRvci5jaGlsZHJlbiwgc2NoZW1hVHlwZXMpID8gKFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbMCwgMF1cbiAgICB9KSwgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50KSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbMF1cbiAgICB9KSkgOiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG59XG5jb25zdCBvcmlnaW5hbEZuTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHdpdGhQbHVnaW5zID0gKGVkaXRvciwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBlID0gZWRpdG9yLCB7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgcG9ydGFibGVUZXh0RWRpdG9yLFxuICAgIHJlYWRPbmx5LFxuICAgIG1heEJsb2Nrc1xuICB9ID0gb3B0aW9ucywge1xuICAgIHNjaGVtYVR5cGVzXG4gIH0gPSBwb3J0YWJsZVRleHRFZGl0b3I7XG4gIGUuc3Vic2NyaXB0aW9ucyA9IFtdLCBlLmRlc3Ryb3kgPyBlLmRlc3Ryb3koKSA6IG9yaWdpbmFsRm5NYXAuc2V0KGUsIHtcbiAgICBhcHBseTogZS5hcHBseSxcbiAgICBvbkNoYW5nZTogZS5vbkNoYW5nZSxcbiAgICBub3JtYWxpemVOb2RlOiBlLm5vcm1hbGl6ZU5vZGVcbiAgfSk7XG4gIGNvbnN0IG9wZXJhdGlvblRvUGF0Y2hlcyA9IGNyZWF0ZU9wZXJhdGlvblRvUGF0Y2hlcyhzY2hlbWFUeXBlcyksIHdpdGhPYmplY3RLZXlzID0gY3JlYXRlV2l0aE9iamVjdEtleXMoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKSwgd2l0aFNjaGVtYVR5cGVzID0gY3JlYXRlV2l0aFNjaGVtYVR5cGVzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBzY2hlbWFUeXBlc1xuICB9KSwgd2l0aEVkaXRhYmxlQVBJID0gY3JlYXRlV2l0aEVkaXRhYmxlQVBJKGVkaXRvckFjdG9yLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNjaGVtYVR5cGVzKSwgd2l0aFBhdGNoZXMgPSBjcmVhdGVXaXRoUGF0Y2hlcyh7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgcGF0Y2hGdW5jdGlvbnM6IG9wZXJhdGlvblRvUGF0Y2hlcyxcbiAgICByZWFkT25seSxcbiAgICBzY2hlbWFUeXBlc1xuICB9KSwgd2l0aE1heEJsb2NrcyA9IGNyZWF0ZVdpdGhNYXhCbG9ja3MobWF4QmxvY2tzIHx8IC0xKSwgd2l0aFBvcnRhYmxlVGV4dExpc3RzID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dExpc3RzKHNjaGVtYVR5cGVzKSwgd2l0aFVuZG9SZWRvID0gY3JlYXRlV2l0aFVuZG9SZWRvKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICByZWFkT25seSxcbiAgICBibG9ja1NjaGVtYVR5cGU6IHNjaGVtYVR5cGVzLmJsb2NrXG4gIH0pLCB3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpLCB3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyksIHdpdGhQbGFjZWhvbGRlckJsb2NrID0gY3JlYXRlV2l0aFBsYWNlaG9sZGVyQmxvY2soKSwgd2l0aFV0aWxzID0gY3JlYXRlV2l0aFV0aWxzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBzY2hlbWFUeXBlcyxcbiAgICBwb3J0YWJsZVRleHRFZGl0b3JcbiAgfSksIHdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKSwgd2l0aEV2ZW50TGlzdGVuZXJzID0gY3JlYXRlV2l0aEV2ZW50TGlzdGVuZXJzKGVkaXRvckFjdG9yKTtcbiAgcmV0dXJuIGUuZGVzdHJveSA9ICgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEZ1bmN0aW9ucyA9IG9yaWdpbmFsRm5NYXAuZ2V0KGUpO1xuICAgIGlmICghb3JpZ2luYWxGdW5jdGlvbnMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBwcmlzdGluZSB2ZXJzaW9ucyBvZiBlZGl0b3IgZnVuY3Rpb25zXCIpO1xuICAgIGUuYXBwbHkgPSBvcmlnaW5hbEZ1bmN0aW9ucy5hcHBseSwgZS5oaXN0b3J5ID0ge1xuICAgICAgdW5kb3M6IFtdLFxuICAgICAgcmVkb3M6IFtdXG4gICAgfSwgZS5ub3JtYWxpemVOb2RlID0gb3JpZ2luYWxGdW5jdGlvbnMubm9ybWFsaXplTm9kZSwgZS5vbkNoYW5nZSA9IG9yaWdpbmFsRnVuY3Rpb25zLm9uQ2hhbmdlO1xuICB9LCByZWFkT25seSA/IHtcbiAgICBlZGl0b3I6IHdpdGhTY2hlbWFUeXBlcyh3aXRoT2JqZWN0S2V5cyh3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsKHdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKHdpdGhVdGlscyh3aXRoUGxhY2Vob2xkZXJCbG9jayh3aXRoUG9ydGFibGVUZXh0TGlzdHMod2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMod2l0aEVkaXRhYmxlQVBJKGUpKSkpKSkpKSksXG4gICAgc3Vic2NyaWJlOiAoKSA9PiBub29wXG4gIH0gOiB7XG4gICAgZWRpdG9yOiB3aXRoRXZlbnRMaXN0ZW5lcnMod2l0aFNjaGVtYVR5cGVzKHdpdGhPYmplY3RLZXlzKHdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwod2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUod2l0aFBvcnRhYmxlVGV4dExpc3RzKHdpdGhQbGFjZWhvbGRlckJsb2NrKHdpdGhVdGlscyh3aXRoTWF4QmxvY2tzKHdpdGhVbmRvUmVkbyh3aXRoUGF0Y2hlcyh3aXRoUG9ydGFibGVUZXh0U2VsZWN0aW9ucyh3aXRoRWRpdGFibGVBUEkoZSkpKSkpKSkpKSkpKSksXG4gICAgc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZXMgPSBbXTtcbiAgICAgIHJldHVybiBlZGl0b3Iuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWJzY3JpYmVGbikgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZXMucHVzaChzdWJzY3JpYmVGbigpKTtcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlcy5mb3JFYWNoKCh1bnN1YnNjcmliZUZuKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVGbigpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufSwgZGVidWckNiA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlNsYXRlQ29udGFpbmVyXCIpO1xuZnVuY3Rpb24gU2xhdGVDb250YWluZXIocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoMjYpLCB7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgcG9ydGFibGVUZXh0RWRpdG9yLFxuICAgIHJlYWRPbmx5LFxuICAgIG1heEJsb2Nrc1xuICB9ID0gcHJvcHM7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxXSAhPT0gbWF4QmxvY2tzIHx8ICRbMl0gIT09IHBvcnRhYmxlVGV4dEVkaXRvciB8fCAkWzNdICE9PSByZWFkT25seSA/ICh0MCA9ICgpID0+IHtcbiAgICBkZWJ1ZyQ2KFwiQ3JlYXRpbmcgbmV3IFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdWJzY3JpYmU6IF9zdWJcbiAgICB9ID0gd2l0aFBsdWdpbnMod2l0aFJlYWN0KGNyZWF0ZUVkaXRvcigpKSwge1xuICAgICAgZWRpdG9yQWN0b3IsXG4gICAgICBtYXhCbG9ja3MsXG4gICAgICBwb3J0YWJsZVRleHRFZGl0b3IsXG4gICAgICByZWFkT25seVxuICAgIH0pO1xuICAgIHJldHVybiBLRVlfVE9fVkFMVUVfRUxFTUVOVC5zZXQoZWRpdG9yLCB7fSksIEtFWV9UT19TTEFURV9FTEVNRU5ULnNldChlZGl0b3IsIHt9KSwgW2VkaXRvciwgX3N1Yl07XG4gIH0sICRbMF0gPSBlZGl0b3JBY3RvciwgJFsxXSA9IG1heEJsb2NrcywgJFsyXSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgJFszXSA9IHJlYWRPbmx5LCAkWzRdID0gdDApIDogdDAgPSAkWzRdO1xuICBjb25zdCBbdDFdID0gdXNlU3RhdGUodDApLCBbc2xhdGVFZGl0b3IsIHN1YnNjcmliZV0gPSB0MTtcbiAgbGV0IHQyLCB0MztcbiAgJFs1XSAhPT0gc3Vic2NyaWJlID8gKHQyID0gKCkgPT4ge1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDMgPSBbc3Vic2NyaWJlXSwgJFs1XSA9IHN1YnNjcmliZSwgJFs2XSA9IHQyLCAkWzddID0gdDMpIDogKHQyID0gJFs2XSwgdDMgPSAkWzddKSwgdXNlRWZmZWN0KHQyLCB0Myk7XG4gIGxldCB0NCwgdDU7XG4gICRbOF0gIT09IHNsYXRlRWRpdG9yIHx8ICRbOV0gIT09IGVkaXRvckFjdG9yIHx8ICRbMTBdICE9PSBtYXhCbG9ja3MgfHwgJFsxMV0gIT09IHBvcnRhYmxlVGV4dEVkaXRvciB8fCAkWzEyXSAhPT0gcmVhZE9ubHkgPyAodDQgPSAoKSA9PiB7XG4gICAgZGVidWckNihcIlJlLWluaXRpYWxpemluZyBwbHVnaW4gY2hhaW5cIiksIHdpdGhQbHVnaW5zKHNsYXRlRWRpdG9yLCB7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIG1heEJsb2NrcyxcbiAgICAgIHBvcnRhYmxlVGV4dEVkaXRvcixcbiAgICAgIHJlYWRPbmx5XG4gICAgfSk7XG4gIH0sIHQ1ID0gW2VkaXRvckFjdG9yLCBwb3J0YWJsZVRleHRFZGl0b3IsIG1heEJsb2NrcywgcmVhZE9ubHksIHNsYXRlRWRpdG9yXSwgJFs4XSA9IHNsYXRlRWRpdG9yLCAkWzldID0gZWRpdG9yQWN0b3IsICRbMTBdID0gbWF4QmxvY2tzLCAkWzExXSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgJFsxMl0gPSByZWFkT25seSwgJFsxM10gPSB0NCwgJFsxNF0gPSB0NSkgOiAodDQgPSAkWzEzXSwgdDUgPSAkWzE0XSksIHVzZUVmZmVjdCh0NCwgdDUpO1xuICBsZXQgdDYsIHQ3O1xuICAkWzE1XSAhPT0gc2xhdGVFZGl0b3IgPyAodDcgPSBzbGF0ZUVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgIGRlY29yYXRvcnM6IFtdXG4gIH0pLCAkWzE1XSA9IHNsYXRlRWRpdG9yLCAkWzE2XSA9IHQ3KSA6IHQ3ID0gJFsxNl07XG4gIGxldCB0ODtcbiAgJFsxN10gIT09IHQ3ID8gKHQ4ID0gW3Q3XSwgJFsxN10gPSB0NywgJFsxOF0gPSB0OCkgOiB0OCA9ICRbMThdLCB0NiA9IHQ4O1xuICBjb25zdCBpbml0aWFsVmFsdWUgPSB0NjtcbiAgbGV0IHQ5LCB0MTA7XG4gICRbMTldICE9PSBzbGF0ZUVkaXRvciA/ICh0OSA9ICgpID0+ICgpID0+IHtcbiAgICBkZWJ1ZyQ2KFwiRGVzdHJveWluZyBTbGF0ZSBlZGl0b3JcIiksIHNsYXRlRWRpdG9yLmRlc3Ryb3koKTtcbiAgfSwgdDEwID0gW3NsYXRlRWRpdG9yXSwgJFsxOV0gPSBzbGF0ZUVkaXRvciwgJFsyMF0gPSB0OSwgJFsyMV0gPSB0MTApIDogKHQ5ID0gJFsyMF0sIHQxMCA9ICRbMjFdKSwgdXNlRWZmZWN0KHQ5LCB0MTApO1xuICBsZXQgdDExO1xuICByZXR1cm4gJFsyMl0gIT09IHNsYXRlRWRpdG9yIHx8ICRbMjNdICE9PSBpbml0aWFsVmFsdWUgfHwgJFsyNF0gIT09IHByb3BzLmNoaWxkcmVuID8gKHQxMSA9IC8qIEBfX1BVUkVfXyAqLyBqc3goU2xhdGUsIHsgZWRpdG9yOiBzbGF0ZUVkaXRvciwgaW5pdGlhbFZhbHVlLCBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSksICRbMjJdID0gc2xhdGVFZGl0b3IsICRbMjNdID0gaW5pdGlhbFZhbHVlLCAkWzI0XSA9IHByb3BzLmNoaWxkcmVuLCAkWzI1XSA9IHQxMSkgOiB0MTEgPSAkWzI1XSwgdDExO1xufVxuU2xhdGVDb250YWluZXIuZGlzcGxheU5hbWUgPSBcIlNsYXRlQ29udGFpbmVyXCI7XG5jb25zdCBQb3J0YWJsZVRleHRFZGl0b3JSZWFkT25seUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCExKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yUmVhZE9ubHlTdGF0dXMgPSAoKSA9PiB7XG4gIGNvbnN0IHJlYWRPbmx5ID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JSZWFkT25seUNvbnRleHQpO1xuICBpZiAocmVhZE9ubHkgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVBvcnRhYmxlVGV4dEVkaXRvclJlYWRPbmx5YCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICByZXR1cm4gcmVhZE9ubHk7XG59LCBkZWJ1ZyQ1ID0gZGVidWdXaXRoTmFtZShcImhvb2s6dXNlU3luY1ZhbHVlXCIpLCBDVVJSRU5UX1ZBTFVFID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB1c2VTeW5jVmFsdWUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHBvcnRhYmxlVGV4dEVkaXRvcixcbiAgICByZWFkT25seVxuICB9ID0gcHJvcHMsIHNjaGVtYVR5cGVzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgcHJldmlvdXNWYWx1ZSA9IHVzZVJlZigpLCBzbGF0ZUVkaXRvciA9IHVzZVNsYXRlKCksIHVwZGF0ZVZhbHVlRnVuY3Rpb25SZWYgPSB1c2VSZWYoKSwgdXBkYXRlRnJvbUN1cnJlbnRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBDVVJSRU5UX1ZBTFVFLmdldChwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlLmN1cnJlbnQgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgZGVidWckNShcIlZhbHVlIGlzIHRoZSBzYW1lIG9iamVjdCBhcyBwcmV2aW91cywgbm90IG5lZWQgdG8gc3luY1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlVmFsdWVGdW5jdGlvblJlZi5jdXJyZW50ICYmIGN1cnJlbnRWYWx1ZSAmJiAoZGVidWckNShcIlVwZGF0aW5nIHRoZSB2YWx1ZSBkZWJvdW5jZWRcIiksIHVwZGF0ZVZhbHVlRnVuY3Rpb25SZWYuY3VycmVudChjdXJyZW50VmFsdWUpKTtcbiAgfSwgW3BvcnRhYmxlVGV4dEVkaXRvcl0pLCB1cGRhdGVWYWx1ZURlYm91bmNlZCA9IHVzZU1lbW8oKCkgPT4gZGVib3VuY2UodXBkYXRlRnJvbUN1cnJlbnRWYWx1ZSwgMWUzLCB7XG4gICAgdHJhaWxpbmc6ICEwLFxuICAgIGxlYWRpbmc6ICExXG4gIH0pLCBbdXBkYXRlRnJvbUN1cnJlbnRWYWx1ZV0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlRnVuY3Rpb24gPSAodmFsdWUpID0+IHtcbiAgICAgIENVUlJFTlRfVkFMVUUuc2V0KHBvcnRhYmxlVGV4dEVkaXRvciwgdmFsdWUpO1xuICAgICAgY29uc3QgaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzID0gaXNDaGFuZ2luZ0xvY2FsbHkoc2xhdGVFZGl0b3IpLCBpc1Byb2Nlc3NpbmdSZW1vdGVDaGFuZ2VzID0gaXNDaGFuZ2luZ1JlbW90ZWx5KHNsYXRlRWRpdG9yKTtcbiAgICAgIGlmICghcmVhZE9ubHkpIHtcbiAgICAgICAgaWYgKGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlcykge1xuICAgICAgICAgIGRlYnVnJDUoXCJIYXMgbG9jYWwgY2hhbmdlcywgbm90IHN5bmNpbmcgdmFsdWUgcmlnaHQgbm93XCIpLCB1cGRhdGVWYWx1ZURlYm91bmNlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9jZXNzaW5nUmVtb3RlQ2hhbmdlcykge1xuICAgICAgICAgIGRlYnVnJDUoXCJIYXMgcmVtb3RlIGNoYW5nZXMsIG5vdCBzeW5jaW5nIHZhbHVlIHJpZ2h0IG5vd1wiKSwgdXBkYXRlVmFsdWVEZWJvdW5jZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBpc0NoYW5nZWQgPSAhMSwgaXNWYWxpZCA9ICEwO1xuICAgICAgY29uc3QgaGFkU2VsZWN0aW9uID0gISFzbGF0ZUVkaXRvci5zZWxlY3Rpb247XG4gICAgICBpZiAoKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApICYmIChkZWJ1ZyQ1KFwiVmFsdWUgaXMgZW1wdHlcIiksIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgd2l0aG91dFNhdmluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgaGFkU2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuZGVzZWxlY3Qoc2xhdGVFZGl0b3IpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBzbGF0ZUVkaXRvci5jaGlsZHJlbi5mb3JFYWNoKChfLCBpbmRleDIpID0+IHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBbY2hpbGRyZW5MZW5ndGggLSAxIC0gaW5kZXgyXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgICBkZWNvcmF0b3JzOiBbXVxuICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgYXQ6IFswXVxuICAgICAgICAgICAgfSksIGhhZFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgWzAsIDBdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgaXNDaGFuZ2VkID0gITApLCB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNsYXRlVmFsdWVGcm9tUHJvcHMgPSB0b1NsYXRlVmFsdWUodmFsdWUsIHtcbiAgICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgICB9KTtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB3aXRob3V0U2F2aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoXzAgPSBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNsYXRlVmFsdWVGcm9tUHJvcHMubGVuZ3RoIDwgY2hpbGRyZW5MZW5ndGhfMCkge1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuTGVuZ3RoXzAgLSAxOyBpID4gc2xhdGVWYWx1ZUZyb21Qcm9wcy5sZW5ndGggLSAxOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdDogW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaXNDaGFuZ2VkID0gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsYXRlVmFsdWVGcm9tUHJvcHMuZm9yRWFjaCgoY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQmxvY2sgPSBzbGF0ZUVkaXRvci5jaGlsZHJlbltjdXJyZW50QmxvY2tJbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAob2xkQmxvY2sgJiYgIWlzRXF1YWwoY3VycmVudEJsb2NrLCBvbGRCbG9jaykgJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uVmFsdWUgPSBbdmFsdWVbY3VycmVudEJsb2NrSW5kZXhdXSwgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUodmFsaWRhdGlvblZhbHVlLCBzY2hlbWFUeXBlcywgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICF2YWxpZGF0aW9uLnZhbGlkICYmIHZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUgJiYgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5wYXRjaGVzLmxlbmd0aCA+IDAgJiYgIXJlYWRPbmx5ICYmIHByZXZpb3VzVmFsdWUuY3VycmVudCAmJiBwcmV2aW91c1ZhbHVlLmN1cnJlbnQgIT09IHZhbHVlICYmIChjb25zb2xlLndhcm4oYCR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uLmFjdGlvbn0gZm9yIGJsb2NrIHdpdGggX2tleSAnJHt2YWxpZGF0aW9uVmFsdWVbMF0uX2tleX0nLiAke3ZhbGlkYXRpb24ucmVzb2x1dGlvbj8uZGVzY3JpcHRpb259YCksIHZhbGlkYXRpb24ucmVzb2x1dGlvbi5wYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSksIHZhbGlkYXRpb24udmFsaWQgfHwgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5hdXRvUmVzb2x2ZSA/IChvbGRCbG9jay5fa2V5ID09PSBjdXJyZW50QmxvY2suX2tleSA/IChkZWJ1ZyQ1LmVuYWJsZWQgJiYgZGVidWckNShcIlVwZGF0aW5nIGJsb2NrXCIsIG9sZEJsb2NrLCBjdXJyZW50QmxvY2spLCBfdXBkYXRlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgb2xkQmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSkgOiAoZGVidWckNS5lbmFibGVkICYmIGRlYnVnJDUoXCJSZXBsYWNpbmcgYmxvY2tcIiwgb2xkQmxvY2ssIGN1cnJlbnRCbG9jayksIF9yZXBsYWNlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpKSwgaXNDaGFuZ2VkID0gITApIDogKGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZCB2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdXRpb246IHZhbGlkYXRpb24ucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KSwgaXNWYWxpZCA9ICExKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghb2xkQmxvY2sgJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uVmFsdWVfMCA9IFt2YWx1ZVtjdXJyZW50QmxvY2tJbmRleF1dLCB2YWxpZGF0aW9uXzAgPSB2YWxpZGF0ZVZhbHVlKHZhbGlkYXRpb25WYWx1ZV8wLCBzY2hlbWFUeXBlcywgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDUuZW5hYmxlZCAmJiBkZWJ1ZyQ1KFwiVmFsaWRhdGluZyBhbmQgaW5zZXJ0aW5nIG5ldyBibG9jayBpbiB0aGUgZW5kIG9mIHRoZSB2YWx1ZVwiLCBjdXJyZW50QmxvY2spLCB2YWxpZGF0aW9uXzAudmFsaWQgfHwgdmFsaWRhdGlvbl8wLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlID8gVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfSkgOiAoZGVidWckNShcIkludmFsaWRcIiwgdmFsaWRhdGlvbl8wKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogdmFsaWRhdGlvbl8wLnJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSksIGlzVmFsaWQgPSAhMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIGRlYnVnJDUoXCJJbnZhbGlkIHZhbHVlLCByZXR1cm5pbmdcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgZGVidWckNShcIlNlcnZlciB2YWx1ZSBjaGFuZ2VkLCBzeW5jaW5nIGVkaXRvclwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVyciksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiBudWxsLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFkU2VsZWN0aW9uICYmICFzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJ2YWx1ZSBjaGFuZ2VkXCIsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZGVidWckNShcIlNlcnZlciB2YWx1ZSBhbmQgZWRpdG9yIHZhbHVlIGlzIGVxdWFsLCBubyBuZWVkIHRvIHN5bmMuXCIpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5jdXJyZW50ID0gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlVmFsdWVGdW5jdGlvblJlZi5jdXJyZW50ID0gdXBkYXRlRnVuY3Rpb24sIHVwZGF0ZUZ1bmN0aW9uO1xuICB9LCBbZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgcmVhZE9ubHksIHNjaGVtYVR5cGVzLCBzbGF0ZUVkaXRvciwgdXBkYXRlVmFsdWVEZWJvdW5jZWRdKTtcbn1cbmZ1bmN0aW9uIF9yZXBsYWNlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IHNsYXRlRWRpdG9yLnNlbGVjdGlvbiwgc2VsZWN0aW9uRm9jdXNPbkJsb2NrID0gY3VycmVudFNlbGVjdGlvbiAmJiBjdXJyZW50U2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0gPT09IGN1cnJlbnRCbG9ja0luZGV4O1xuICBzZWxlY3Rpb25Gb2N1c09uQmxvY2sgJiYgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvciksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7XG4gICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCksIHNlbGVjdGlvbkZvY3VzT25CbG9jayAmJiBUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgY3VycmVudFNlbGVjdGlvbik7XG59XG5mdW5jdGlvbiBfdXBkYXRlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgb2xkQmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSB7XG4gIGlmIChUcmFuc2Zvcm1zLnNldE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICB9KSwgc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2soY3VycmVudEJsb2NrKSAmJiBzbGF0ZUVkaXRvci5pc1RleHRCbG9jayhvbGRCbG9jaykpIHtcbiAgICBjb25zdCBvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoID0gb2xkQmxvY2suY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGN1cnJlbnRCbG9jay5jaGlsZHJlbi5sZW5ndGggPCBvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoICYmIEFycmF5LmZyb20oQXJyYXkob2xkQmxvY2tDaGlsZHJlbkxlbmd0aCAtIGN1cnJlbnRCbG9jay5jaGlsZHJlbi5sZW5ndGgpKS5mb3JFYWNoKChfLCBpbmRleDIpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkSW5kZXggPSBvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoIC0gMSAtIGluZGV4MjtcbiAgICAgIGNoaWxkSW5kZXggPiAwICYmIChkZWJ1ZyQ1KFwiUmVtb3ZpbmcgY2hpbGRcIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY2hpbGRJbmRleF1cbiAgICAgIH0pKTtcbiAgICB9KSwgY3VycmVudEJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGN1cnJlbnRCbG9ja0NoaWxkLCBjdXJyZW50QmxvY2tDaGlsZEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBvbGRCbG9ja0NoaWxkID0gb2xkQmxvY2suY2hpbGRyZW5bY3VycmVudEJsb2NrQ2hpbGRJbmRleF0sIGlzQ2hpbGRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQsIG9sZEJsb2NrQ2hpbGQpLCBpc1RleHRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQudGV4dCwgb2xkQmxvY2tDaGlsZD8udGV4dCksIHBhdGggPSBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdO1xuICAgICAgaWYgKGlzQ2hpbGRDaGFuZ2VkKVxuICAgICAgICBpZiAoY3VycmVudEJsb2NrQ2hpbGQuX2tleSA9PT0gb2xkQmxvY2tDaGlsZD8uX2tleSkge1xuICAgICAgICAgIGRlYnVnJDUoXCJVcGRhdGluZyBjaGFuZ2VkIGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkLCBvbGRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNTcGFuTm9kZSA9IFRleHQuaXNUZXh0KGN1cnJlbnRCbG9ja0NoaWxkKSAmJiBjdXJyZW50QmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgVGV4dC5pc1RleHQob2xkQmxvY2tDaGlsZCkgJiYgb2xkQmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCI7XG4gICAgICAgICAgaXNTcGFuTm9kZSAmJiBpc1RleHRDaGFuZ2VkID8gKFRyYW5zZm9ybXMuZGVsZXRlKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBhdDoge1xuICAgICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvbGRCbG9ja0NoaWxkLnRleHQubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZC50ZXh0LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSA6IGlzU3Bhbk5vZGUgfHwgKGRlYnVnJDUoXCJVcGRhdGluZyBjaGFuZ2VkIGlubGluZSBvYmplY3QgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgMF0sXG4gICAgICAgICAgICB2b2lkczogITBcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBvbGRCbG9ja0NoaWxkID8gKGRlYnVnJDUoXCJSZXBsYWNpbmcgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpIDogb2xkQmxvY2tDaGlsZCB8fCAoZGVidWckNShcIkluc2VydGluZyBuZXcgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZCwge1xuICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdXG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgZGVidWckNCA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlN5bmNocm9uaXplclwiKSwgZGVidWdWZXJib3NlJDEgPSBkZWJ1ZyQ0LmVuYWJsZWQgJiYgITEsIEZMVVNIX1BBVENIRVNfVEhST1RUTEVEX01TID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gNTAwIDogMWUzO1xuZnVuY3Rpb24gU3luY2hyb25pemVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDM1KSwgcG9ydGFibGVUZXh0RWRpdG9yID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yKCksIHJlYWRPbmx5ID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yUmVhZE9ubHlTdGF0dXMoKSwge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGdldFZhbHVlLFxuICAgIG9uQ2hhbmdlLFxuICAgIHZhbHVlXG4gIH0gPSBwcm9wcztcbiAgbGV0IHQwO1xuICAkWzBdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MCA9IFtdLCAkWzBdID0gdDApIDogdDAgPSAkWzBdO1xuICBjb25zdCBwZW5kaW5nUGF0Y2hlcyA9IHVzZVJlZih0MCk7XG4gIGxldCB0MTtcbiAgJFsxXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsyXSAhPT0gcG9ydGFibGVUZXh0RWRpdG9yIHx8ICRbM10gIT09IHJlYWRPbmx5ID8gKHQxID0ge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHBvcnRhYmxlVGV4dEVkaXRvcixcbiAgICByZWFkT25seVxuICB9LCAkWzFdID0gZWRpdG9yQWN0b3IsICRbMl0gPSBwb3J0YWJsZVRleHRFZGl0b3IsICRbM10gPSByZWFkT25seSwgJFs0XSA9IHQxKSA6IHQxID0gJFs0XTtcbiAgY29uc3Qgc3luY1ZhbHVlID0gdXNlU3luY1ZhbHVlKHQxKSwgc2xhdGVFZGl0b3IgPSB1c2VTbGF0ZSgpO1xuICBsZXQgdDIsIHQzO1xuICAkWzVdICE9PSBzbGF0ZUVkaXRvciA/ICh0MiA9ICgpID0+IHtcbiAgICBJU19QUk9DRVNTSU5HX0xPQ0FMX0NIQU5HRVMuc2V0KHNsYXRlRWRpdG9yLCAhMSk7XG4gIH0sIHQzID0gW3NsYXRlRWRpdG9yXSwgJFs1XSA9IHNsYXRlRWRpdG9yLCAkWzZdID0gdDIsICRbN10gPSB0MykgOiAodDIgPSAkWzZdLCB0MyA9ICRbN10pLCB1c2VFZmZlY3QodDIsIHQzKTtcbiAgbGV0IHQ0O1xuICAkWzhdICE9PSBnZXRWYWx1ZSB8fCAkWzldICE9PSBlZGl0b3JBY3RvciB8fCAkWzEwXSAhPT0gc2xhdGVFZGl0b3IgPyAodDQgPSAoKSA9PiB7XG4gICAgaWYgKHBlbmRpbmdQYXRjaGVzLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgZGVidWckNChcIkZsdXNoaW5nIHBlbmRpbmcgcGF0Y2hlc1wiKSwgZGVidWdWZXJib3NlJDEgJiYgZGVidWckNChgUGF0Y2hlczpcbiR7SlNPTi5zdHJpbmdpZnkocGVuZGluZ1BhdGNoZXMuY3VycmVudCwgbnVsbCwgMil9YCk7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGdldFZhbHVlKCk7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgICBwYXRjaGVzOiBwZW5kaW5nUGF0Y2hlcy5jdXJyZW50LFxuICAgICAgICBzbmFwc2hvdFxuICAgICAgfSksIHBlbmRpbmdQYXRjaGVzLmN1cnJlbnQgPSBbXTtcbiAgICB9XG4gICAgSVNfUFJPQ0VTU0lOR19MT0NBTF9DSEFOR0VTLnNldChzbGF0ZUVkaXRvciwgITEpO1xuICB9LCAkWzhdID0gZ2V0VmFsdWUsICRbOV0gPSBlZGl0b3JBY3RvciwgJFsxMF0gPSBzbGF0ZUVkaXRvciwgJFsxMV0gPSB0NCkgOiB0NCA9ICRbMTFdO1xuICBjb25zdCBvbkZsdXNoUGVuZGluZ1BhdGNoZXMgPSB0NDtcbiAgbGV0IHQ1LCB0NjtcbiAgJFsxMl0gIT09IG9uRmx1c2hQZW5kaW5nUGF0Y2hlcyA/ICh0NSA9ICgpID0+ICgpID0+IHtcbiAgICBvbkZsdXNoUGVuZGluZ1BhdGNoZXMoKTtcbiAgfSwgdDYgPSBbb25GbHVzaFBlbmRpbmdQYXRjaGVzXSwgJFsxMl0gPSBvbkZsdXNoUGVuZGluZ1BhdGNoZXMsICRbMTNdID0gdDUsICRbMTRdID0gdDYpIDogKHQ1ID0gJFsxM10sIHQ2ID0gJFsxNF0pLCB1c2VFZmZlY3QodDUsIHQ2KTtcbiAgbGV0IHQ3O1xuICAkWzE1XSAhPT0gb25DaGFuZ2UgPyAodDcgPSAoY2hhbmdlKSA9PiBvbkNoYW5nZShjaGFuZ2UpLCAkWzE1XSA9IG9uQ2hhbmdlLCAkWzE2XSA9IHQ3KSA6IHQ3ID0gJFsxNl07XG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHQ3KTtcbiAgbGV0IHQ4LCB0OTtcbiAgJFsxN10gIT09IHNsYXRlRWRpdG9yIHx8ICRbMThdICE9PSBvbkZsdXNoUGVuZGluZ1BhdGNoZXMgfHwgJFsxOV0gIT09IGVkaXRvckFjdG9yIHx8ICRbMjBdICE9PSBoYW5kbGVDaGFuZ2UgPyAodDggPSAoKSA9PiB7XG4gICAgY29uc3Qgb25GbHVzaFBlbmRpbmdQYXRjaGVzVGhyb3R0bGVkID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgaWYgKEVkaXRvci5pc05vcm1hbGl6aW5nKHNsYXRlRWRpdG9yKSkge1xuICAgICAgICBvbkZsdXNoUGVuZGluZ1BhdGNoZXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25GbHVzaFBlbmRpbmdQYXRjaGVzVGhyb3R0bGVkKCk7XG4gICAgfSwgRkxVU0hfUEFUQ0hFU19USFJPVFRMRURfTVMsIHtcbiAgICAgIGxlYWRpbmc6ICExLFxuICAgICAgdHJhaWxpbmc6ICEwXG4gICAgfSk7XG4gICAgZGVidWckNChcIlN1YnNjcmliaW5nIHRvIGVkaXRvciBjaGFuZ2VzXCIpO1xuICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGJiMTg6IHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFwicGF0Y2hcIjoge1xuICAgICAgICAgIElTX1BST0NFU1NJTkdfTE9DQUxfQ0hBTkdFUy5zZXQoc2xhdGVFZGl0b3IsICEwKSwgcGVuZGluZ1BhdGNoZXMuY3VycmVudC5wdXNoKGV2ZW50LnBhdGNoKSwgb25GbHVzaFBlbmRpbmdQYXRjaGVzVGhyb3R0bGVkKCksIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgYnJlYWsgYmIxODtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibG9hZGluZ1wiOiB7XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiAhMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiMTg7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImRvbmUgbG9hZGluZ1wiOiB7XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiAhMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiMTg7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm9mZmxpbmVcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBcImNvbm5lY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBcIm9mZmxpbmVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiMTg7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm9ubGluZVwiOiB7XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29ubmVjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IFwib25saW5lXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjE4O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ2YWx1ZSBjaGFuZ2VkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmIxODtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaW52YWxpZCB2YWx1ZVwiOiB7XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFZhbHVlXCIsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiBldmVudC5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmIxODtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgIGxldmVsOiBcIndhcm5pbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiMTg7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdGNoZXNcIjpcbiAgICAgICAgICBicmVhayBiYjE4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlYnVnJDQoXCJVbnN1YnNjcmliaW5nIHRvIGNoYW5nZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQ5ID0gW2VkaXRvckFjdG9yLCBoYW5kbGVDaGFuZ2UsIG9uRmx1c2hQZW5kaW5nUGF0Y2hlcywgc2xhdGVFZGl0b3JdLCAkWzE3XSA9IHNsYXRlRWRpdG9yLCAkWzE4XSA9IG9uRmx1c2hQZW5kaW5nUGF0Y2hlcywgJFsxOV0gPSBlZGl0b3JBY3RvciwgJFsyMF0gPSBoYW5kbGVDaGFuZ2UsICRbMjFdID0gdDgsICRbMjJdID0gdDkpIDogKHQ4ID0gJFsyMV0sIHQ5ID0gJFsyMl0pLCB1c2VFZmZlY3QodDgsIHQ5KTtcbiAgbGV0IHQxMDtcbiAgJFsyM10gIT09IHN5bmNWYWx1ZSB8fCAkWzI0XSAhPT0gdmFsdWUgPyAodDEwID0gKCkgPT4ge1xuICAgIGRlYnVnJDQoXCJFZGl0b3IgaXMgb25saW5lLCBzeW5jaW5nIGZyb20gcHJvcHMudmFsdWVcIiksIHN5bmNWYWx1ZSh2YWx1ZSk7XG4gIH0sICRbMjNdID0gc3luY1ZhbHVlLCAkWzI0XSA9IHZhbHVlLCAkWzI1XSA9IHQxMCkgOiB0MTAgPSAkWzI1XTtcbiAgY29uc3QgaGFuZGxlT25saW5lID0gdDEwO1xuICBsZXQgdDExLCB0MTI7XG4gICRbMjZdICE9PSBlZGl0b3JBY3RvciB8fCAkWzI3XSAhPT0gaGFuZGxlT25saW5lID8gKHQxMSA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBlZGl0b3JBY3Rvci5vbihcIm9ubGluZVwiLCBoYW5kbGVPbmxpbmUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MTIgPSBbaGFuZGxlT25saW5lLCBlZGl0b3JBY3Rvcl0sICRbMjZdID0gZWRpdG9yQWN0b3IsICRbMjddID0gaGFuZGxlT25saW5lLCAkWzI4XSA9IHQxMSwgJFsyOV0gPSB0MTIpIDogKHQxMSA9ICRbMjhdLCB0MTIgPSAkWzI5XSksIHVzZUVmZmVjdCh0MTEsIHQxMik7XG4gIGNvbnN0IGlzSW5pdGlhbFZhbHVlRnJvbVByb3BzID0gdXNlUmVmKCEwKTtcbiAgbGV0IHQxMywgdDE0O1xuICByZXR1cm4gJFszMF0gIT09IHN5bmNWYWx1ZSB8fCAkWzMxXSAhPT0gdmFsdWUgfHwgJFszMl0gIT09IGVkaXRvckFjdG9yID8gKHQxMyA9ICgpID0+IHtcbiAgICBkZWJ1ZyQ0KFwiVmFsdWUgZnJvbSBwcm9wcyBjaGFuZ2VkLCBzeW5jaW5nIG5ldyB2YWx1ZVwiKSwgc3luY1ZhbHVlKHZhbHVlKSwgaXNJbml0aWFsVmFsdWVGcm9tUHJvcHMuY3VycmVudCAmJiAoZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInJlYWR5XCJcbiAgICB9KSwgaXNJbml0aWFsVmFsdWVGcm9tUHJvcHMuY3VycmVudCA9ICExKTtcbiAgfSwgdDE0ID0gW2VkaXRvckFjdG9yLCBzeW5jVmFsdWUsIHZhbHVlXSwgJFszMF0gPSBzeW5jVmFsdWUsICRbMzFdID0gdmFsdWUsICRbMzJdID0gZWRpdG9yQWN0b3IsICRbMzNdID0gdDEzLCAkWzM0XSA9IHQxNCkgOiAodDEzID0gJFszM10sIHQxNCA9ICRbMzRdKSwgdXNlRWZmZWN0KHQxMywgdDE0KSwgbnVsbDtcbn1cblN5bmNocm9uaXplci5kaXNwbGF5TmFtZSA9IFwiU3luY2hyb25pemVyXCI7XG5jb25zdCBFZGl0b3JBY3RvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KSwgaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBrZXlHZW5lcmF0b3IgPSBjb250ZXh0LmtleUdlbmVyYXRvciwgc2NoZW1hID0gY29udGV4dC5zY2hlbWEsIGVkaXRvciA9IGFjdGlvbi5lZGl0b3I7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IFtmb2N1c1NwYW5dID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cyxcbiAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgIHZvaWRzOiAhMVxuICB9KSlbMF0gPz8gW3ZvaWQgMF0sIGZvY3VzRGVjb3JhdG9ycyA9IGZvY3VzU3Bhbi5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBzY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSA9PT0gbWFyaykpID8/IFtdLCBmb2N1c0Fubm90YXRpb25zID0gZm9jdXNTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFzY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSA9PT0gbWFyaykpID8/IFtdLCBmb2N1c0Jsb2NrUGF0aCA9IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSwgZm9jdXNCbG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGZvY3VzQmxvY2tQYXRoKTtcbiAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhmb2N1c0Jsb2NrKSkge1xuICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGVkaXRvci5zZWxlY3Rpb24pLCBhdFRoZVN0YXJ0T2ZCbG9jayA9IGlzRXF1YWwoZW5kLCB7XG4gICAgICBwYXRoOiBbLi4uZm9jdXNCbG9ja1BhdGgsIDBdLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG4gICAgaWYgKGF0VGhlU3RhcnRPZkJsb2NrICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICBkZWNvcmF0b3JzOiBmb2N1c0Fubm90YXRpb25zLmxlbmd0aCA9PT0gMCA/IGZvY3VzRGVjb3JhdG9ycyA6IFtdLFxuICAgICAgICBsaXN0SXRlbTogZm9jdXNCbG9jay5saXN0SXRlbSxcbiAgICAgICAgbGV2ZWw6IGZvY3VzQmxvY2subGV2ZWxcbiAgICAgIH0pKTtcbiAgICAgIGNvbnN0IFtuZXh0QmxvY2tQYXRoXSA9IFBhdGgubmV4dChmb2N1c0Jsb2NrUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogW25leHRCbG9ja1BhdGgsIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0QmxvY2tQYXRoLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RGb2N1c0Jsb2NrQ2hpbGQgPSBmb2N1c0Jsb2NrLmNoaWxkcmVuW2ZvY3VzQmxvY2suY2hpbGRyZW4ubGVuZ3RoIC0gMV0sIGF0VGhlRW5kT2ZCbG9jayA9IGlzRXF1YWwoc3RhcnQsIHtcbiAgICAgIHBhdGg6IFsuLi5mb2N1c0Jsb2NrUGF0aCwgZm9jdXNCbG9jay5jaGlsZHJlbi5sZW5ndGggLSAxXSxcbiAgICAgIG9mZnNldDogZWRpdG9yLmlzVGV4dFNwYW4obGFzdEZvY3VzQmxvY2tDaGlsZCkgPyBsYXN0Rm9jdXNCbG9ja0NoaWxkLnRleHQubGVuZ3RoIDogMFxuICAgIH0pO1xuICAgIGlmIChhdFRoZUVuZE9mQmxvY2sgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICAgIEVkaXRvci5pbnNlcnROb2RlKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgIGRlY29yYXRvcnM6IFtdLFxuICAgICAgICBsaXN0SXRlbTogZm9jdXNCbG9jay5saXN0SXRlbSxcbiAgICAgICAgbGV2ZWw6IGZvY3VzQmxvY2subGV2ZWxcbiAgICAgIH0pKTtcbiAgICAgIGNvbnN0IFtuZXh0QmxvY2tQYXRoXSA9IFBhdGgubmV4dChmb2N1c0Jsb2NrUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogW25leHRCbG9ja1BhdGgsIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0QmxvY2tQYXRoLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghYXRUaGVTdGFydE9mQmxvY2sgJiYgIWF0VGhlRW5kT2ZCbG9jaykge1xuICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBbbmV4dE5vZGUsIG5leHROb2RlUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgubmV4dChmb2N1c0Jsb2NrUGF0aCksIHtcbiAgICAgICAgICBkZXB0aDogMVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgcGF0aDogWy4uLm5leHROb2RlUGF0aCwgMF0sXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICBwYXRoOiBbLi4ubmV4dE5vZGVQYXRoLCAwXSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSksIGVkaXRvci5pc1RleHRCbG9jayhuZXh0Tm9kZSkgJiYgbmV4dE5vZGUubWFya0RlZnMgJiYgbmV4dE5vZGUubWFya0RlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5ld01hcmtEZWZLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcHJldk5vZGVTcGFucyA9IEFycmF5LmZyb20oTm9kZS5jaGlsZHJlbihlZGl0b3IsIGZvY3VzQmxvY2tQYXRoKSkubWFwKChlbnRyeSkgPT4gZW50cnlbMF0pLmZpbHRlcigobm9kZSkgPT4gZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkpLCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBuZXh0Tm9kZVBhdGgpO1xuICAgICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSlcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IGNoaWxkLm1hcmtzID8/IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXJrIG9mIG1hcmtzKVxuICAgICAgICAgICAgICBzY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSA9PT0gbWFyaykgfHwgcHJldk5vZGVTcGFucy5zb21lKChwcmV2Tm9kZVNwYW4pID0+IHByZXZOb2RlU3Bhbi5tYXJrcz8uaW5jbHVkZXMobWFyaykpICYmICFuZXdNYXJrRGVmS2V5cy5oYXMobWFyaykgJiYgbmV3TWFya0RlZktleXMuc2V0KG1hcmssIGtleUdlbmVyYXRvcigpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld01hcmtzID0gbWFya3MubWFwKChtYXJrKSA9PiBuZXdNYXJrRGVmS2V5cy5nZXQobWFyaykgPz8gbWFyayk7XG4gICAgICAgICAgICBpc0VxdWFsKG1hcmtzLCBuZXdNYXJrcykgfHwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWFya3M6IG5ld01hcmtzXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXdNYXJrRGVmcyA9IG5leHROb2RlLm1hcmtEZWZzLm1hcCgobWFya0RlZikgPT4gKHtcbiAgICAgICAgICAgIC4uLm1hcmtEZWYsXG4gICAgICAgICAgICBfa2V5OiBuZXdNYXJrRGVmS2V5cy5nZXQobWFya0RlZi5fa2V5KSA/PyBtYXJrRGVmLl9rZXlcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgaXNFcXVhbChuZXh0Tm9kZS5tYXJrRGVmcywgbmV3TWFya0RlZnMpIHx8IFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrRGVmczogbmV3TWFya0RlZnNcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogbmV4dE5vZGVQYXRoLFxuICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufSwgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMgPSB7XG4gIFwic2V0IGJsb2NrXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgYWN0aW9uLnBhdGhzKSB7XG4gICAgICBjb25zdCBhdCA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSwgYWN0aW9uLmVkaXRvcik7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgICAgLi4uYWN0aW9uLnN0eWxlID8ge1xuICAgICAgICAgIHN0eWxlOiBhY3Rpb24uc3R5bGVcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICAuLi5hY3Rpb24ubGlzdEl0ZW0gPyB7XG4gICAgICAgICAgbGlzdEl0ZW06IGFjdGlvbi5saXN0SXRlbVxuICAgICAgICB9IDoge30sXG4gICAgICAgIC4uLmFjdGlvbi5sZXZlbCA/IHtcbiAgICAgICAgICBsZXZlbDogYWN0aW9uLmxldmVsXG4gICAgICAgIH0gOiB7fVxuICAgICAgfSwge1xuICAgICAgICBhdFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBcInVuc2V0IGJsb2NrXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgYWN0aW9uLnBhdGhzKSB7XG4gICAgICBjb25zdCBhdCA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSwgYWN0aW9uLmVkaXRvcik7XG4gICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnByb3BzLCB7XG4gICAgICAgIGF0XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIFwiZGVsZXRlIGJhY2t3YXJkXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBkZWxldGVCYWNrd2FyZChhY3Rpb24uZWRpdG9yLCBhY3Rpb24udW5pdCk7XG4gIH0sXG4gIFwiZGVsZXRlIGZvcndhcmRcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGRlbGV0ZUZvcndhcmQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnVuaXQpO1xuICB9LFxuICBkZWxldGU6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHRvU2xhdGVSYW5nZShhY3Rpb24uc2VsZWN0aW9uLCBhY3Rpb24uZWRpdG9yKTtcbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgZmluZCBTbGF0ZSBsb2NhdGlvbiBmcm9tIHNlbGVjdGlvbiAke2FjdGlvbi5zZWxlY3Rpb259YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvY2F0aW9uLmFuY2hvci5wYXRoLmxlbmd0aCA9PT0gMSAmJiBsb2NhdGlvbi5mb2N1cy5wYXRoLmxlbmd0aCA9PT0gMSA/IFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQ6IGxvY2F0aW9uXG4gICAgfSkgOiBUcmFuc2Zvcm1zLmRlbGV0ZShhY3Rpb24uZWRpdG9yLCB7XG4gICAgICBhdDogbG9jYXRpb25cbiAgICB9KTtcbiAgfSxcbiAgXCJpbnNlcnQgYnJlYWtcIjogaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgLy8gVGhpcyBtaW1pY3MgU2xhdGUncyBpbnRlcm5hbCB3aGljaCBhbHNvIGp1c3QgZG9lcyBhIHJlZ3VsYXIgaW5zZXJ0IGJyZWFrXG4gIC8vIHdoZW4gb24gc29mdCBicmVha1xuICBcImluc2VydCBzb2Z0IGJyZWFrXCI6IGluc2VydEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0IHRleHRcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGluc2VydFRleHQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnRleHQpO1xuICB9LFxuICBcImluc2VydCB0ZXh0IGJsb2NrXCI6ICh7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIEVkaXRvci5pbnNlcnROb2RlKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICBfdHlwZTogY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgIHN0eWxlOiBjb250ZXh0LnNjaGVtYS5zdHlsZXNbMF0udmFsdWUgPz8gXCJub3JtYWxcIixcbiAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIHRleHQ6IFwiXCJcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0sXG4gIGVmZmVjdDogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGFjdGlvbi5lZmZlY3QoKTtcbiAgfSxcbiAgc2VsZWN0OiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoYWN0aW9uLmVkaXRvciwgdG9TbGF0ZVJhbmdlKGFjdGlvbi5zZWxlY3Rpb24sIGFjdGlvbi5lZGl0b3IpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHBlcmZvcm1BY3Rpb24oe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJkZWxldGVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMuZGVsZXRlKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0IHRleHQgYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQgdGV4dCBibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNldCBibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInNldCBibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInVuc2V0IGJsb2NrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1widW5zZXQgYmxvY2tcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJlZmZlY3RcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMuZWZmZWN0KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2VsZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLnNlbGVjdCh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHBlcmZvcm1EZWZhdWx0QWN0aW9uKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGVyZm9ybURlZmF1bHRBY3Rpb24oe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJkZWxldGUgYmFja3dhcmRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWxldGUgYmFja3dhcmRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWxldGUgZm9yd2FyZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlbGV0ZSBmb3J3YXJkXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0IGJyZWFrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0IGJyZWFrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0IHNvZnQgYnJlYWtcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQgc29mdCBicmVha1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0IHRleHRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICB9XG59XG5jb25zdCBicmVha2luZ1ZvaWRCbG9jayA9IHtcbiAgb246IFwiaW5zZXJ0IGJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHRcbiAgfSkgPT4gISFnZXRGb2N1c0Jsb2NrT2JqZWN0KGNvbnRleHQpLFxuICBhY3Rpb25zOiBbKCkgPT4gW3tcbiAgICB0eXBlOiBcImluc2VydCB0ZXh0IGJsb2NrXCIsXG4gICAgZGVjb3JhdG9yczogW11cbiAgfV1dXG59LCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCA9IHtcbiAgb246IFwiZGVsZXRlIGJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soY29udGV4dCksIHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBwcmV2aW91c0Jsb2NrID0gZ2V0UHJldmlvdXNCbG9jayhjb250ZXh0KTtcbiAgICByZXR1cm4gIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIXByZXZpb3VzQmxvY2sgPyAhMSA6IGlzRW1wdHlUZXh0QmxvY2soZm9jdXNUZXh0QmxvY2subm9kZSkgJiYgIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKHByZXZpb3VzQmxvY2subm9kZSkgPyB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIHByZXZpb3VzQmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIHByZXZpb3VzQmxvY2tcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogcHJldmlvdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBwcmV2aW91c0Jsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH1cbiAgfV1dXG59LCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQmVmb3JlQmxvY2tPYmplY3QgPSB7XG4gIG9uOiBcImRlbGV0ZSBmb3J3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soY29udGV4dCksIHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBuZXh0QmxvY2sgPSBnZXROZXh0QmxvY2soY29udGV4dCk7XG4gICAgcmV0dXJuICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFuZXh0QmxvY2sgPyAhMSA6IGlzRW1wdHlUZXh0QmxvY2soZm9jdXNUZXh0QmxvY2subm9kZSkgJiYgIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG5leHRCbG9jay5ub2RlKSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgbmV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBuZXh0QmxvY2tcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogbmV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IG5leHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH1dXVxufSwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzID0gW2JyZWFraW5nVm9pZEJsb2NrLCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCwgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0XSwgY2xlYXJMaXN0T25CYWNrc3BhY2UgPSB7XG4gIG9uOiBcImRlbGV0ZSBiYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZChjb250ZXh0KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhjb250ZXh0KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKGNvbnRleHQpO1xuICAgIHJldHVybiAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuID8gITEgOiBmb2N1c1RleHRCbG9jay5ub2RlLmNoaWxkcmVuWzBdLl9rZXkgPT09IGZvY3VzU3Bhbi5ub2RlLl9rZXkgJiYgY29udGV4dC5zZWxlY3Rpb24uZm9jdXMub2Zmc2V0ID09PSAwICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgPT09IDEgPyB7XG4gICAgICBmb2N1c1RleHRCbG9ja1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2tcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcInVuc2V0IGJsb2NrXCIsXG4gICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgcGF0aHM6IFtmb2N1c1RleHRCbG9jay5wYXRoXVxuICB9XV1cbn0sIHVuaW5kZW50TGlzdE9uQmFja3NwYWNlID0ge1xuICBvbjogXCJkZWxldGUgYmFja3dhcmRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoY29udGV4dCksIGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soY29udGV4dCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3Bhbihjb250ZXh0KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbiA/ICExIDogZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gMCAmJiBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsICE9PSB2b2lkIDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCA+IDEgPyB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIGxldmVsOiBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsIC0gMVxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgbGV2ZWxcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcInNldCBibG9ja1wiLFxuICAgIGxldmVsLFxuICAgIHBhdGhzOiBbZm9jdXNUZXh0QmxvY2sucGF0aF1cbiAgfV1dXG59LCBjb3JlTGlzdEJlaGF2aW9ycyA9IFtjbGVhckxpc3RPbkJhY2tzcGFjZSwgdW5pbmRlbnRMaXN0T25CYWNrc3BhY2VdLCBzb2Z0UmV0dXJuID0ge1xuICBvbjogXCJpbnNlcnQgc29mdCBicmVha1wiLFxuICBhY3Rpb25zOiBbKCkgPT4gW3tcbiAgICB0eXBlOiBcImluc2VydCB0ZXh0XCIsXG4gICAgdGV4dDogYFxuYFxuICB9XV1cbn0sIGNvcmVCZWhhdmlvcnMgPSBbc29mdFJldHVybiwgLi4uY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLCAuLi5jb3JlTGlzdEJlaGF2aW9yc10sIG5ldHdvcmtMb2dpYyA9IGZyb21DYWxsYmFjaygoe1xuICBzZW5kQmFja1xufSkgPT4ge1xuICBjb25zdCBvbmxpbmVIYW5kbGVyID0gKCkgPT4ge1xuICAgIHNlbmRCYWNrKHtcbiAgICAgIHR5cGU6IFwib25saW5lXCJcbiAgICB9KTtcbiAgfSwgb2ZmbGluZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgc2VuZEJhY2soe1xuICAgICAgdHlwZTogXCJvZmZsaW5lXCJcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9ubGluZUhhbmRsZXIpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb2ZmbGluZUhhbmRsZXIpLCAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25saW5lSGFuZGxlciksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvZmZsaW5lSGFuZGxlcik7XG4gIH07XG59KSwgZWRpdG9yTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9LFxuICAgIGlucHV0OiB7fVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJhc3NpZ24gYmVoYXZpb3JzXCI6IGFzc2lnbih7XG4gICAgICBiZWhhdmlvcnM6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIGJlaGF2aW9yc1wiKSwgWy4uLmNvcmVCZWhhdmlvcnMsIC4uLmV2ZW50LmJlaGF2aW9yc10pXG4gICAgfSksXG4gICAgXCJhc3NpZ24gc2NoZW1hXCI6IGFzc2lnbih7XG4gICAgICBzY2hlbWE6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHNjaGVtYVwiKSwgZXZlbnQuc2NoZW1hKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwYXRjaCBldmVudFwiOiBlbWl0KCh7XG4gICAgICBldmVudFxuICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJwYXRjaFwiKSwgZXZlbnQpKSxcbiAgICBcImVtaXQgbXV0YXRpb24gZXZlbnRcIjogZW1pdCgoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibXV0YXRpb25cIiksIGV2ZW50KSksXG4gICAgXCJkZWZlciBldmVudFwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ0V2ZW50czogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgW1wicGF0Y2hcIiwgXCJtdXRhdGlvblwiXSksIFsuLi5jb250ZXh0LnBlbmRpbmdFdmVudHMsIGV2ZW50XSlcbiAgICB9KSxcbiAgICBcImVtaXQgcGVuZGluZyBldmVudHNcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBlbnF1ZXVlXG4gICAgfSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LnBlbmRpbmdFdmVudHMpXG4gICAgICAgIGVucXVldWUoZW1pdChldmVudCkpO1xuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdFdmVudHM6IFtdXG4gICAgfSksXG4gICAgXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBhc3NlcnRFdmVudChldmVudCwgW1wiYmVoYXZpb3IgZXZlbnRcIl0pO1xuICAgICAgY29uc3QgZGVmYXVsdEFjdGlvbiA9IHtcbiAgICAgICAgLi4uZXZlbnQuYmVoYXZpb3JFdmVudCxcbiAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3JcbiAgICAgIH0sIGV2ZW50QmVoYXZpb3JzID0gY29udGV4dC5iZWhhdmlvcnMuZmlsdGVyKChiZWhhdmlvcikgPT4gYmVoYXZpb3Iub24gPT09IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSk7XG4gICAgICBpZiAoZXZlbnRCZWhhdmlvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBlcmZvcm1EZWZhdWx0QWN0aW9uKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGFjdGlvbjogZGVmYXVsdEFjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBmcm9tU2xhdGVWYWx1ZShldmVudC5lZGl0b3IuY2hpbGRyZW4sIGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChldmVudC5lZGl0b3IpKSwgc2VsZWN0aW9uID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgZXZlbnQuZWRpdG9yLnNlbGVjdGlvbiwgY29udGV4dC5zY2hlbWEpO1xuICAgICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gaGFuZGxlIGV2ZW50ICR7ZXZlbnQudHlwZX0gZHVlIHRvIG1pc3Npbmcgc2VsZWN0aW9uYCksIHBlcmZvcm1EZWZhdWx0QWN0aW9uKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGFjdGlvbjogZGVmYXVsdEFjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYmVoYXZpb3JDb250ZXh0ID0ge1xuICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9O1xuICAgICAgbGV0IGJlaGF2aW9yT3ZlcndyaXR0ZW4gPSAhMTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnRCZWhhdmlvciBvZiBldmVudEJlaGF2aW9ycykge1xuICAgICAgICBjb25zdCBzaG91bGRSdW4gPSBldmVudEJlaGF2aW9yLmd1YXJkPy4oe1xuICAgICAgICAgIGNvbnRleHQ6IGJlaGF2aW9yQ29udGV4dCxcbiAgICAgICAgICBldmVudDogZXZlbnQuYmVoYXZpb3JFdmVudFxuICAgICAgICB9KSA/PyAhMDtcbiAgICAgICAgaWYgKCFzaG91bGRSdW4pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGFjdGlvbkludGVuZFNldHMgPSBldmVudEJlaGF2aW9yLmFjdGlvbnMubWFwKChhY3Rpb25TZXQpID0+IGFjdGlvblNldCh7XG4gICAgICAgICAgY29udGV4dDogYmVoYXZpb3JDb250ZXh0LFxuICAgICAgICAgIGV2ZW50OiBldmVudC5iZWhhdmlvckV2ZW50XG4gICAgICAgIH0sIHNob3VsZFJ1bikpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbkludGVuZHMgb2YgYWN0aW9uSW50ZW5kU2V0cylcbiAgICAgICAgICBiZWhhdmlvck92ZXJ3cml0dGVuID0gYWN0aW9uSW50ZW5kcy5sZW5ndGggPiAwICYmIGFjdGlvbkludGVuZHMuc29tZSgoYWN0aW9uSW50ZW5kKSA9PiBhY3Rpb25JbnRlbmQudHlwZSAhPT0gXCJlZmZlY3RcIiksIGVucXVldWUucmFpc2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBhY3Rpb24gaW50ZW5kc1wiLFxuICAgICAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3IsXG4gICAgICAgICAgICBhY3Rpb25JbnRlbmRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChiZWhhdmlvck92ZXJ3cml0dGVuKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYmVoYXZpb3JPdmVyd3JpdHRlbiB8fCBwZXJmb3JtRGVmYXVsdEFjdGlvbih7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvbjogZGVmYXVsdEFjdGlvblxuICAgICAgfSk7XG4gICAgfSlcbiAgfSxcbiAgYWN0b3JzOiB7XG4gICAgbmV0d29ya0xvZ2ljXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJlZGl0b3JcIixcbiAgY29udGV4dDogKHtcbiAgICBpbnB1dFxuICB9KSA9PiAoe1xuICAgIGJlaGF2aW9yczogaW5wdXQuYmVoYXZpb3JzID8gWy4uLmNvcmVCZWhhdmlvcnMsIC4uLmlucHV0LmJlaGF2aW9yc10gOiBjb3JlQmVoYXZpb3JzLFxuICAgIGtleUdlbmVyYXRvcjogaW5wdXQua2V5R2VuZXJhdG9yLFxuICAgIHBlbmRpbmdFdmVudHM6IFtdLFxuICAgIHNjaGVtYTogaW5wdXQuc2NoZW1hXG4gIH0pLFxuICBpbnZva2U6IHtcbiAgICBpZDogXCJuZXR3b3JrTG9naWNcIixcbiAgICBzcmM6IFwibmV0d29ya0xvZ2ljXCJcbiAgfSxcbiAgb246IHtcbiAgICByZWFkeToge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICB1bnNldDoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBcInZhbHVlIGNoYW5nZWRcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBcImludmFsaWQgdmFsdWVcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBlcnJvcjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBzZWxlY3Rpb246IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgYmx1cjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBvbmxpbmU6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICAgICAgICB0eXBlOiBcIm9ubGluZVwiXG4gICAgICB9KVxuICAgIH0sXG4gICAgb2ZmbGluZToge1xuICAgICAgYWN0aW9uczogZW1pdCh7XG4gICAgICAgIHR5cGU6IFwib2ZmbGluZVwiXG4gICAgICB9KVxuICAgIH0sXG4gICAgbG9hZGluZzoge1xuICAgICAgYWN0aW9uczogZW1pdCh7XG4gICAgICAgIHR5cGU6IFwibG9hZGluZ1wiXG4gICAgICB9KVxuICAgIH0sXG4gICAgcGF0Y2hlczoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBcImRvbmUgbG9hZGluZ1wiOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KHtcbiAgICAgICAgdHlwZTogXCJkb25lIGxvYWRpbmdcIlxuICAgICAgfSlcbiAgICB9LFxuICAgIFwidXBkYXRlIGJlaGF2aW9yc1wiOiB7XG4gICAgICBhY3Rpb25zOiBcImFzc2lnbiBiZWhhdmlvcnNcIlxuICAgIH0sXG4gICAgXCJ1cGRhdGUgc2NoZW1hXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYXNzaWduIHNjaGVtYVwiXG4gICAgfSxcbiAgICBcImJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiaGFuZGxlIGJlaGF2aW9yIGV2ZW50XCJcbiAgICB9LFxuICAgIFwiYmVoYXZpb3IgYWN0aW9uIGludGVuZHNcIjoge1xuICAgICAgYWN0aW9uczogWyh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiB7XG4gICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBhY3Rpb25JbnRlbmQgb2YgZXZlbnQuYWN0aW9uSW50ZW5kcykge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uID0ge1xuICAgICAgICAgICAgICAuLi5hY3Rpb25JbnRlbmQsXG4gICAgICAgICAgICAgIGVkaXRvcjogZXZlbnQuZWRpdG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGVyZm9ybUFjdGlvbih7XG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGFjdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgZXZlbnQuZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XVxuICAgIH1cbiAgfSxcbiAgaW5pdGlhbDogXCJwcmlzdGluZVwiLFxuICBzdGF0ZXM6IHtcbiAgICBwcmlzdGluZToge1xuICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaWRsZToge1xuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBub3JtYWxpemluZzoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZGlydHlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZGlydHlcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybWFsaXppbmc6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJkb25lIG5vcm1hbGl6aW5nXCI6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlydHk6IHtcbiAgICAgIGVudHJ5OiBbXCJlbWl0IHBlbmRpbmcgZXZlbnRzXCIsIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIl0sXG4gICAgICBvbjoge1xuICAgICAgICBwYXRjaDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiZW1pdCBwYXRjaCBldmVudFwiXG4gICAgICAgIH0sXG4gICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJlbWl0IG11dGF0aW9uIGV2ZW50XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpLCB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb24gPSAoKSA9PiB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHVzZUNvbnRleHQoUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uQ29udGV4dCk7XG4gIGlmIChzZWxlY3Rpb24gPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8UG9ydGFibGVUZXh0RWRpdG9yPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn0sIGRlYnVnJDMgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OlBvcnRhYmxlVGV4dEVkaXRvcjpTZWxlY3Rpb25Qcm92aWRlclwiKSwgZGVidWdWZXJib3NlID0gZGVidWckMy5lbmFibGVkICYmICExO1xuZnVuY3Rpb24gUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNiksIFtzZWxlY3Rpb24sIHNldFNlbGVjdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgbGV0IHQwLCB0MTtcbiAgJFswXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgPyAodDAgPSAoKSA9PiB7XG4gICAgZGVidWckMyhcIlN1YnNjcmliaW5nIHRvIHNlbGVjdGlvbiBjaGFuZ2VzXCIpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHByb3BzLmVkaXRvckFjdG9yLm9uKFwic2VsZWN0aW9uXCIsIChldmVudCkgPT4ge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGVidWdWZXJib3NlICYmIGRlYnVnJDMoXCJTZXR0aW5nIHNlbGVjdGlvblwiKSwgc2V0U2VsZWN0aW9uKGV2ZW50LnNlbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVidWckMyhcIlVuc3Vic2NyaWJpbmcgdG8gc2VsZWN0aW9uIGNoYW5nZXNcIiksIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW3Byb3BzLmVkaXRvckFjdG9yXSwgJFswXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzFdID0gdDAsICRbMl0gPSB0MSkgOiAodDAgPSAkWzFdLCB0MSA9ICRbMl0pLCB1c2VFZmZlY3QodDAsIHQxKTtcbiAgbGV0IHQyO1xuICByZXR1cm4gJFszXSAhPT0gc2VsZWN0aW9uIHx8ICRbNF0gIT09IHByb3BzLmNoaWxkcmVuID8gKHQyID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZWxlY3Rpb24sIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFszXSA9IHNlbGVjdGlvbiwgJFs0XSA9IHByb3BzLmNoaWxkcmVuLCAkWzVdID0gdDIpIDogdDIgPSAkWzVdLCB0Mjtcbn1cbmNvbnN0IGRlZmF1bHRLZXlHZW5lcmF0b3IgPSAoKSA9PiByYW5kb21LZXkoMTIpLCBkZWJ1ZyQyID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpQb3J0YWJsZVRleHRFZGl0b3JcIik7XG5jbGFzcyBQb3J0YWJsZVRleHRFZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSBcIlBvcnRhYmxlVGV4dEVkaXRvclwiO1xuICAvKipcbiAgICogQW4gb2JzZXJ2YWJsZSBvZiBhbGwgdGhlIGVkaXRvciBjaGFuZ2VzLlxuICAgKi9cbiAgY2hhbmdlJCA9IG5ldyBTdWJqZWN0KCk7XG4gIC8qKlxuICAgKiBBIGxvb2t1cCB0YWJsZSBmb3IgYWxsIHRoZSByZWxldmFudCBzY2hlbWEgdHlwZXMgZm9yIHRoaXMgcG9ydGFibGUgdGV4dCB0eXBlLlxuICAgKi9cbiAgLyoqXG4gICAqIFRoZSBlZGl0b3IgQVBJIChjdXJyZW50bHkgaW1wbGVtZW50ZWQgd2l0aCBTbGF0ZSkuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGlmIChzdXBlcihwcm9wcyksIHByb3BzLmVkaXRvcilcbiAgICAgIHRoaXMuZWRpdG9yQWN0b3IgPSBwcm9wcy5lZGl0b3IsIHRoaXMuZWRpdG9yQWN0b3Iuc3RhcnQoKSwgdGhpcy5zY2hlbWFUeXBlcyA9IHRoaXMuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYTtcbiAgICBlbHNlIHtcbiAgICAgIGlmICghcHJvcHMuc2NoZW1hVHlwZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0YWJsZVRleHRFZGl0b3I6IG1pc3NpbmcgXCJzY2hlbWFUeXBlXCIgcHJvcGVydHknKTtcbiAgICAgIHByb3BzLmluY29taW5nUGF0Y2hlcyQgJiYgY29uc29sZS53YXJuKFwiVGhlIHByb3AgJ2luY29taW5nUGF0Y2hlcyQnIGlzIGRlcHJlY2F0ZWQgYW5kIHJlbmFtZWQgdG8gJ3BhdGNoZXMkJ1wiKSwgdGhpcy5zY2hlbWFUeXBlcyA9IGdldFBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKHByb3BzLnNjaGVtYVR5cGUuaGFzT3duUHJvcGVydHkoXCJqc29uVHlwZVwiKSA/IHByb3BzLnNjaGVtYVR5cGUgOiBjb21waWxlVHlwZShwcm9wcy5zY2hlbWFUeXBlKSksIHRoaXMuZWRpdG9yQWN0b3IgPSBwcm9wcy5lZGl0b3IgPz8gY3JlYXRlQWN0b3IoZWRpdG9yTWFjaGluZSwge1xuICAgICAgICBpbnB1dDoge1xuICAgICAgICAgIGtleUdlbmVyYXRvcjogcHJvcHMua2V5R2VuZXJhdG9yIHx8IGRlZmF1bHRLZXlHZW5lcmF0b3IsXG4gICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYVR5cGVzXG4gICAgICAgIH1cbiAgICAgIH0pLCB0aGlzLmVkaXRvckFjdG9yLnN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAhdGhpcy5wcm9wcy5lZGl0b3IgJiYgIXByZXZQcm9wcy5lZGl0b3IgJiYgdGhpcy5wcm9wcy5zY2hlbWFUeXBlICE9PSBwcmV2UHJvcHMuc2NoZW1hVHlwZSAmJiAodGhpcy5zY2hlbWFUeXBlcyA9IGdldFBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKHRoaXMucHJvcHMuc2NoZW1hVHlwZS5oYXNPd25Qcm9wZXJ0eShcImpzb25UeXBlXCIpID8gdGhpcy5wcm9wcy5zY2hlbWFUeXBlIDogY29tcGlsZVR5cGUodGhpcy5wcm9wcy5zY2hlbWFUeXBlKSksIHRoaXMuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSBzY2hlbWFcIixcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFUeXBlc1xuICAgIH0pKSwgdGhpcy5wcm9wcy5lZGl0b3JSZWYgIT09IHByZXZQcm9wcy5lZGl0b3JSZWYgJiYgdGhpcy5wcm9wcy5lZGl0b3JSZWYgJiYgKHRoaXMucHJvcHMuZWRpdG9yUmVmLmN1cnJlbnQgPSB0aGlzKTtcbiAgfVxuICBzZXRFZGl0YWJsZSA9IChlZGl0YWJsZSkgPT4ge1xuICAgIHRoaXMuZWRpdGFibGUgPSB7XG4gICAgICAuLi50aGlzLmVkaXRhYmxlLFxuICAgICAgLi4uZWRpdGFibGVcbiAgICB9O1xuICB9O1xuICBnZXRWYWx1ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5lZGl0YWJsZSlcbiAgICAgIHJldHVybiB0aGlzLmVkaXRhYmxlLmdldFZhbHVlKCk7XG4gIH07XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtYXhCbG9ja3MgPSB0aGlzLnByb3BzLmVkaXRvciB8fCB0eXBlb2YgdGhpcy5wcm9wcy5tYXhCbG9ja3MgPiBcInVcIiA/IHZvaWQgMCA6IE51bWJlci5wYXJzZUludCh0aGlzLnByb3BzLm1heEJsb2Nrcy50b1N0cmluZygpLCAxMCkgfHwgdm9pZCAwLCByZWFkT25seSA9ICEhdGhpcy5wcm9wcy5yZWFkT25seSwgbGVnYWN5UGF0Y2hlcyA9IHRoaXMucHJvcHMuZWRpdG9yID8gdm9pZCAwIDogdGhpcy5wcm9wcy5pbmNvbWluZ1BhdGNoZXMkID8/IHRoaXMucHJvcHMucGF0Y2hlcyQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICBsZWdhY3lQYXRjaGVzID8gLyogQF9fUFVSRV9fICovIGpzeChSb3V0ZVBhdGNoZXNPYnNlcnZhYmxlVG9FZGl0b3JBY3RvciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3JBY3RvciwgcGF0Y2hlcyQ6IGxlZ2FjeVBhdGNoZXMgfSkgOiBudWxsLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JBY3RvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFNsYXRlQ29udGFpbmVyLCB7IGVkaXRvckFjdG9yOiB0aGlzLmVkaXRvckFjdG9yLCBtYXhCbG9ja3MsIHBvcnRhYmxlVGV4dEVkaXRvcjogdGhpcywgcmVhZE9ubHksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclJlYWRPbmx5Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcmVhZE9ubHksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Qcm92aWRlciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3JBY3RvciwgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChTeW5jaHJvbml6ZXIsIHsgZWRpdG9yQWN0b3I6IHRoaXMuZWRpdG9yQWN0b3IsIGdldFZhbHVlOiB0aGlzLmdldFZhbHVlLCBvbkNoYW5nZTogKGNoYW5nZSkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvcHMuZWRpdG9yIHx8IHRoaXMucHJvcHMub25DaGFuZ2UoY2hhbmdlKSwgdGhpcy5jaGFuZ2UkLm5leHQoY2hhbmdlKTtcbiAgICAgICAgfSwgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUgfSksXG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgIF0gfSkgfSkgfSkgfSkgfSlcbiAgICBdIH0pO1xuICB9XG4gIC8vIFN0YXRpYyBBUEkgbWV0aG9kc1xuICBzdGF0aWMgYWN0aXZlQW5ub3RhdGlvbnMgPSAoZWRpdG9yKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmFjdGl2ZUFubm90YXRpb25zKCkgOiBbXTtcbiAgc3RhdGljIGlzQW5ub3RhdGlvbkFjdGl2ZSA9IChlZGl0b3IsIGFubm90YXRpb25UeXBlKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmlzQW5ub3RhdGlvbkFjdGl2ZShhbm5vdGF0aW9uVHlwZSkgOiAhMTtcbiAgc3RhdGljIGFkZEFubm90YXRpb24gPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5hZGRBbm5vdGF0aW9uKHR5cGUsIHZhbHVlKTtcbiAgc3RhdGljIGJsdXIgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckMihcIkhvc3QgYmx1cnJlZFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5ibHVyKCk7XG4gIH07XG4gIHN0YXRpYyBkZWxldGUgPSAoZWRpdG9yLCBzZWxlY3Rpb24sIG9wdGlvbnMpID0+IGVkaXRvci5lZGl0YWJsZT8uZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucyk7XG4gIHN0YXRpYyBmaW5kRE9NTm9kZSA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGVkaXRvci5lZGl0YWJsZT8uZmluZERPTU5vZGUoZWxlbWVudCk7XG4gIHN0YXRpYyBmaW5kQnlQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5maW5kQnlQYXRoKHBhdGgpIHx8IFtdO1xuICBzdGF0aWMgZm9jdXMgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckMihcIkhvc3QgcmVxdWVzdGluZyBmb2N1c1wiKSwgZWRpdG9yLmVkaXRhYmxlPy5mb2N1cygpO1xuICB9O1xuICBzdGF0aWMgZm9jdXNCbG9jayA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNCbG9jaygpO1xuICBzdGF0aWMgZm9jdXNDaGlsZCA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNDaGlsZCgpO1xuICBzdGF0aWMgZ2V0U2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmdldFNlbGVjdGlvbigpIDogbnVsbDtcbiAgc3RhdGljIGdldFZhbHVlID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5nZXRWYWx1ZSgpO1xuICBzdGF0aWMgaGFzQmxvY2tTdHlsZSA9IChlZGl0b3IsIGJsb2NrU3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzQmxvY2tTdHlsZShibG9ja1N0eWxlKTtcbiAgc3RhdGljIGhhc0xpc3RTdHlsZSA9IChlZGl0b3IsIGxpc3RTdHlsZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5oYXNMaXN0U3R5bGUobGlzdFN0eWxlKTtcbiAgc3RhdGljIGlzQ29sbGFwc2VkU2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc0NvbGxhcHNlZFNlbGVjdGlvbigpO1xuICBzdGF0aWMgaXNFeHBhbmRlZFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNFeHBhbmRlZFNlbGVjdGlvbigpO1xuICBzdGF0aWMgaXNNYXJrQWN0aXZlID0gKGVkaXRvciwgbWFyaykgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc01hcmtBY3RpdmUobWFyayk7XG4gIHN0YXRpYyBpbnNlcnRDaGlsZCA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiAoZGVidWckMihcIkhvc3QgaW5zZXJ0aW5nIGNoaWxkXCIpLCBlZGl0b3IuZWRpdGFibGU/Lmluc2VydENoaWxkKHR5cGUsIHZhbHVlKSk7XG4gIHN0YXRpYyBpbnNlcnRCbG9jayA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmluc2VydEJsb2NrKHR5cGUsIHZhbHVlKTtcbiAgc3RhdGljIGluc2VydEJyZWFrID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRCcmVhaygpO1xuICBzdGF0aWMgaXNWb2lkID0gKGVkaXRvciwgZWxlbWVudCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc1ZvaWQoZWxlbWVudCk7XG4gIHN0YXRpYyBpc09iamVjdFBhdGggPSAoX2VkaXRvciwgcGF0aCkgPT4ge1xuICAgIGlmICghcGF0aCB8fCAhQXJyYXkuaXNBcnJheShwYXRoKSkgcmV0dXJuICExO1xuICAgIGNvbnN0IGlzQ2hpbGRPYmplY3RFZGl0UGF0aCA9IHBhdGgubGVuZ3RoID4gMyAmJiBwYXRoWzFdID09PSBcImNoaWxkcmVuXCI7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoWzFdICE9PSBcImNoaWxkcmVuXCIgfHwgaXNDaGlsZE9iamVjdEVkaXRQYXRoO1xuICB9O1xuICBzdGF0aWMgbWFya3MgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/Lm1hcmtzKCk7XG4gIHN0YXRpYyBzZWxlY3QgPSAoZWRpdG9yLCBzZWxlY3Rpb24pID0+IHtcbiAgICBkZWJ1ZyQyKFwiSG9zdCBzZXR0aW5nIHNlbGVjdGlvblwiLCBzZWxlY3Rpb24pLCBlZGl0b3IuZWRpdGFibGU/LnNlbGVjdChzZWxlY3Rpb24pO1xuICB9O1xuICBzdGF0aWMgcmVtb3ZlQW5ub3RhdGlvbiA9IChlZGl0b3IsIHR5cGUpID0+IGVkaXRvci5lZGl0YWJsZT8ucmVtb3ZlQW5ub3RhdGlvbih0eXBlKTtcbiAgc3RhdGljIHRvZ2dsZUJsb2NrU3R5bGUgPSAoZWRpdG9yLCBibG9ja1N0eWxlKSA9PiAoZGVidWckMihcIkhvc3QgaXMgdG9nZ2xpbmcgYmxvY2sgc3R5bGVcIiksIGVkaXRvci5lZGl0YWJsZT8udG9nZ2xlQmxvY2tTdHlsZShibG9ja1N0eWxlKSk7XG4gIHN0YXRpYyB0b2dnbGVMaXN0ID0gKGVkaXRvciwgbGlzdFN0eWxlKSA9PiBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZUxpc3QobGlzdFN0eWxlKTtcbiAgc3RhdGljIHRvZ2dsZU1hcmsgPSAoZWRpdG9yLCBtYXJrKSA9PiB7XG4gICAgZGVidWckMihcIkhvc3QgdG9nZ2xpbmcgbWFya1wiLCBtYXJrKSwgZWRpdG9yLmVkaXRhYmxlPy50b2dnbGVNYXJrKG1hcmspO1xuICB9O1xuICBzdGF0aWMgZ2V0RnJhZ21lbnQgPSAoZWRpdG9yKSA9PiAoZGVidWckMihcIkhvc3QgZ2V0dGluZyBmcmFnbWVudFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5nZXRGcmFnbWVudCgpKTtcbiAgc3RhdGljIHVuZG8gPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckMihcIkhvc3QgdW5kb2luZ1wiKSwgZWRpdG9yLmVkaXRhYmxlPy51bmRvKCk7XG4gIH07XG4gIHN0YXRpYyByZWRvID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDIoXCJIb3N0IHJlZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8ucmVkbygpO1xuICB9O1xuICBzdGF0aWMgaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmcgPSAoZWRpdG9yLCBzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzU2VsZWN0aW9uc092ZXJsYXBwaW5nKHNlbGVjdGlvbkEsIHNlbGVjdGlvbkIpO1xufVxuZnVuY3Rpb24gUm91dGVQYXRjaGVzT2JzZXJ2YWJsZVRvRWRpdG9yQWN0b3IocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCk7XG4gIGxldCB0MCwgdDE7XG4gIHJldHVybiAkWzBdICE9PSBwcm9wcy5wYXRjaGVzJCB8fCAkWzFdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBwcm9wcy5wYXRjaGVzJC5zdWJzY3JpYmUoKHBheWxvYWQpID0+IHtcbiAgICAgIHByb3BzLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInBhdGNoZXNcIixcbiAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW3Byb3BzLmVkaXRvckFjdG9yLCBwcm9wcy5wYXRjaGVzJF0sICRbMF0gPSBwcm9wcy5wYXRjaGVzJCwgJFsxXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiAodDAgPSAkWzJdLCB0MSA9ICRbM10pLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmNvbnN0IGRlYnVnJDEgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50czpMZWFmXCIpLCBFTVBUWV9NQVJLUyA9IFtdLCBMZWFmID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGxlYWYsXG4gICAgc2NoZW1hVHlwZXMsXG4gICAgcmVuZGVyQ2hpbGQsXG4gICAgcmVuZGVyRGVjb3JhdG9yLFxuICAgIHJlbmRlckFubm90YXRpb25cbiAgfSA9IHByb3BzLCBzcGFuUmVmID0gdXNlUmVmKG51bGwpLCBwb3J0YWJsZVRleHRFZGl0b3IgPSB1c2VQb3J0YWJsZVRleHRFZGl0b3IoKSwgYmxvY2tTZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCksIFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKCExKSwgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZSghMSksIGJsb2NrID0gY2hpbGRyZW4ucHJvcHMucGFyZW50LCBwYXRoID0gdXNlTWVtbygoKSA9PiBibG9jayA/IFt7XG4gICAgX2tleTogYmxvY2s/Ll9rZXlcbiAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgX2tleTogbGVhZi5fa2V5XG4gIH1dIDogW10sIFtibG9jaywgbGVhZi5fa2V5XSksIGRlY29yYXRvclZhbHVlcyA9IHVzZU1lbW8oKCkgPT4gc2NoZW1hVHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlYykgPT4gZGVjLnZhbHVlKSwgW3NjaGVtYVR5cGVzLmRlY29yYXRvcnNdKSwgbWFya3MgPSB1c2VNZW1vKCgpID0+IHVuaXEoKGxlYWYubWFya3MgfHwgRU1QVFlfTUFSS1MpLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yVmFsdWVzLmluY2x1ZGVzKG1hcmspKSksIFtkZWNvcmF0b3JWYWx1ZXMsIGxlYWYubWFya3NdKSwgYW5ub3RhdGlvbk1hcmtzID0gQXJyYXkuaXNBcnJheShsZWFmLm1hcmtzKSA/IGxlYWYubWFya3MgOiBFTVBUWV9NQVJLUywgYW5ub3RhdGlvbnMgPSB1c2VNZW1vKCgpID0+IGFubm90YXRpb25NYXJrcy5tYXAoKG1hcmtfMCkgPT4gIWRlY29yYXRvclZhbHVlcy5pbmNsdWRlcyhtYXJrXzApICYmIGJsb2NrPy5tYXJrRGVmcz8uZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFya18wKSkuZmlsdGVyKEJvb2xlYW4pLCBbYW5ub3RhdGlvbk1hcmtzLCBibG9jaywgZGVjb3JhdG9yVmFsdWVzXSksIHNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMgPSBhbm5vdGF0aW9ucy5sZW5ndGggPiAwICYmIGJsb2NrU2VsZWN0ZWQ7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzKSB7XG4gICAgICBzZXRGb2N1c2VkKCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgIHNlbCAmJiBpc0VxdWFsKHNlbC5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSAmJiBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgc2V0Rm9jdXNlZCghMCk7XG4gICAgfSk7XG4gIH0sIFtzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzLCBwYXRoLCBwb3J0YWJsZVRleHRFZGl0b3JdKTtcbiAgY29uc3Qgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzKVxuICAgICAgcmV0dXJuO1xuICAgIGRlYnVnJDEoXCJTZXR0aW5nIHNlbGVjdGlvbiBhbmQgZm9jdXMgZnJvbSByYW5nZVwiKTtcbiAgICBjb25zdCB3aW5TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCF3aW5TZWxlY3Rpb24pIHtcbiAgICAgIHNldFNlbGVjdGVkKCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdpblNlbGVjdGlvbiAmJiB3aW5TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gd2luU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICBzcGFuUmVmLmN1cnJlbnQgJiYgcmFuZ2UuaW50ZXJzZWN0c05vZGUoc3BhblJlZi5jdXJyZW50KSA/IHNldFNlbGVjdGVkKCEwKSA6IHNldFNlbGVjdGVkKCExKTtcbiAgICB9IGVsc2VcbiAgICAgIHNldFNlbGVjdGVkKCExKTtcbiAgfSwgW3Nob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb25CbHVyID0gZWRpdG9yQWN0b3Iub24oXCJibHVyXCIsICgpID0+IHtcbiAgICAgIHNldEZvY3VzZWQoITEpLCBzZXRTZWxlY3RlZCghMSk7XG4gICAgfSksIG9uRm9jdXMgPSBlZGl0b3JBY3Rvci5vbihcImZvY3VzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbF8wID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgc2VsXzAgJiYgaXNFcXVhbChzZWxfMC5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSAmJiBzZXRGb2N1c2VkKCEwKSwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKTtcbiAgICB9KSwgb25TZWxlY3Rpb24gPSBlZGl0b3JBY3Rvci5vbihcInNlbGVjdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnNlbGVjdGlvbiAmJiBpc0VxdWFsKGV2ZW50LnNlbGVjdGlvbi5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSA/IHNldEZvY3VzZWQoITApIDogc2V0Rm9jdXNlZCghMSksIHNldFNlbGVjdGVkRnJvbVJhbmdlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uQmx1ci51bnN1YnNjcmliZSgpLCBvbkZvY3VzLnVuc3Vic2NyaWJlKCksIG9uU2VsZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW2VkaXRvckFjdG9yLCBwYXRoLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNldFNlbGVjdGVkRnJvbVJhbmdlLCBzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzXSksIHVzZUVmZmVjdCgoKSA9PiBzZXRTZWxlY3RlZEZyb21SYW5nZSgpLCBbc2V0U2VsZWN0ZWRGcm9tUmFuZ2VdKTtcbiAgY29uc3QgY29udGVudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCByZXR1cm5lZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgaWYgKFRleHQuaXNUZXh0KGxlYWYpICYmIGxlYWYuX3R5cGUgPT09IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSAmJiAobWFya3MuZm9yRWFjaCgobWFya18xKSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hVHlwZXMuZGVjb3JhdG9ycy5maW5kKChkZWNfMCkgPT4gZGVjXzAudmFsdWUgPT09IG1hcmtfMSk7XG4gICAgICBpZiAoc2NoZW1hVHlwZSAmJiByZW5kZXJEZWNvcmF0b3IpIHtcbiAgICAgICAgY29uc3QgX3Byb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbixcbiAgICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBzcGFuUmVmLFxuICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICBzY2hlbWFUeXBlLFxuICAgICAgICAgIHZhbHVlOiBtYXJrXzFcbiAgICAgICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IHJlbmRlckRlY29yYXRvcihfcHJvcHMpO1xuICAgICAgfVxuICAgIH0pLCBibG9jayAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwICYmIGFubm90YXRpb25zLmZvckVhY2goKGFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGVfMCA9IHNjaGVtYVR5cGVzLmFubm90YXRpb25zLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gYW5ub3RhdGlvbi5fdHlwZSk7XG4gICAgICBpZiAoc2NoZW1hVHlwZV8wKVxuICAgICAgICBpZiAocmVuZGVyQW5ub3RhdGlvbikge1xuICAgICAgICAgIGNvbnN0IF9wcm9wc18wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgY2hpbGRyZW46IHJldHVybmVkQ2hpbGRyZW4sXG4gICAgICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBzcGFuUmVmLFxuICAgICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVfMCxcbiAgICAgICAgICAgIHZhbHVlOiBhbm5vdGF0aW9uXG4gICAgICAgICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVfMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiByZW5kZXJBbm5vdGF0aW9uKF9wcm9wc18wKSB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdEFubm90YXRpb24sIHsgYW5ub3RhdGlvbiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbiB9KSB9KTtcbiAgICB9KSwgYmxvY2sgJiYgcmVuZGVyQ2hpbGQpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuLmZpbmQoKF9jaGlsZCkgPT4gX2NoaWxkLl9rZXkgPT09IGxlYWYuX2tleSk7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgY29uc3QgX3Byb3BzXzEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuIH0pLFxuICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVzLnNwYW4sXG4gICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgIH0sIFwidHlwZVwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlcy5zcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybmVkQ2hpbGRyZW4gPSByZW5kZXJDaGlsZChfcHJvcHNfMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5lZENoaWxkcmVuO1xuICB9LCBbYW5ub3RhdGlvbnMsIGJsb2NrLCBjaGlsZHJlbiwgZm9jdXNlZCwgbGVhZiwgbWFya3MsIHBhdGgsIHJlbmRlckFubm90YXRpb24sIHJlbmRlckNoaWxkLCByZW5kZXJEZWNvcmF0b3IsIHNjaGVtYVR5cGVzLmFubm90YXRpb25zLCBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLCBzY2hlbWFUeXBlcy5zcGFuLCBzZWxlY3RlZF0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IC4uLmF0dHJpYnV0ZXMsIHJlZjogc3BhblJlZiwgY2hpbGRyZW46IGNvbnRlbnQgfSwgbGVhZi5fa2V5KSwgW2xlYWYsIGF0dHJpYnV0ZXMsIGNvbnRlbnRdKTtcbn07XG5MZWFmLmRpc3BsYXlOYW1lID0gXCJMZWFmXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6RWRpdGFibGVcIiksIFBMQUNFSE9MREVSX1NUWUxFID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwXG59LCBQb3J0YWJsZVRleHRFZGl0YWJsZSA9IGZvcndhcmRSZWYoZnVuY3Rpb24ocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgaG90a2V5cyxcbiAgICBvbkJsdXIsXG4gICAgb25Gb2N1cyxcbiAgICBvbkJlZm9yZUlucHV0LFxuICAgIG9uUGFzdGUsXG4gICAgb25Db3B5LFxuICAgIG9uQ2xpY2ssXG4gICAgcmFuZ2VEZWNvcmF0aW9ucyxcbiAgICByZW5kZXJBbm5vdGF0aW9uLFxuICAgIHJlbmRlckJsb2NrLFxuICAgIHJlbmRlckNoaWxkLFxuICAgIHJlbmRlckRlY29yYXRvcixcbiAgICByZW5kZXJMaXN0SXRlbSxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJTdHlsZSxcbiAgICBzZWxlY3Rpb246IHByb3BzU2VsZWN0aW9uLFxuICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3LFxuICAgIHNwZWxsQ2hlY2ssXG4gICAgLi4ucmVzdFByb3BzXG4gIH0gPSBwcm9wcywgcG9ydGFibGVUZXh0RWRpdG9yID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yKCksIHJlYWRPbmx5ID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yUmVhZE9ubHlTdGF0dXMoKSwgcmVmID0gdXNlUmVmKG51bGwpLCBbZWRpdGFibGVFbGVtZW50LCBzZXRFZGl0YWJsZUVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCksIFtoYXNJbnZhbGlkVmFsdWUsIHNldEhhc0ludmFsaWRWYWx1ZV0gPSB1c2VTdGF0ZSghMSksIFtyYW5nZURlY29yYXRpb25TdGF0ZSwgc2V0UmFuZ2VEZWNvcmF0aW9uc1N0YXRlXSA9IHVzZVN0YXRlKFtdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IHJlZi5jdXJyZW50KTtcbiAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uc1JlZiA9IHVzZVJlZihyYW5nZURlY29yYXRpb25zKSwgZWRpdG9yQWN0b3IgPSB1c2VDb250ZXh0KEVkaXRvckFjdG9yQ29udGV4dCksIHtcbiAgICBzY2hlbWFUeXBlc1xuICB9ID0gcG9ydGFibGVUZXh0RWRpdG9yLCBzbGF0ZUVkaXRvciA9IHVzZVNsYXRlKCksIGJsb2NrVHlwZU5hbWUgPSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCB3aXRoSW5zZXJ0RGF0YSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlV2l0aEluc2VydERhdGEoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKSwgW2VkaXRvckFjdG9yLCBzY2hlbWFUeXBlc10pLCB3aXRoSG90S2V5cyA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlV2l0aEhvdGtleXMocG9ydGFibGVUZXh0RWRpdG9yLCBob3RrZXlzKSwgW2hvdGtleXMsIHBvcnRhYmxlVGV4dEVkaXRvcl0pO1xuICB1c2VNZW1vKCgpID0+IHJlYWRPbmx5ID8gKGRlYnVnKFwiRWRpdGFibGUgaXMgaW4gcmVhZCBvbmx5IG1vZGVcIiksIHdpdGhJbnNlcnREYXRhKHNsYXRlRWRpdG9yKSkgOiAoZGVidWcoXCJFZGl0YWJsZSBpcyBpbiBlZGl0IG1vZGVcIiksIHdpdGhJbnNlcnREYXRhKHdpdGhIb3RLZXlzKHNsYXRlRWRpdG9yKSkpLCBbcmVhZE9ubHksIHNsYXRlRWRpdG9yLCB3aXRoSG90S2V5cywgd2l0aEluc2VydERhdGFdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudCA9IHVzZUNhbGxiYWNrKChlUHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goRWxlbWVudCwgeyAuLi5lUHJvcHMsIHJlYWRPbmx5LCByZW5kZXJCbG9jaywgcmVuZGVyQ2hpbGQsIHJlbmRlckxpc3RJdGVtLCByZW5kZXJTdHlsZSwgc2NoZW1hVHlwZXMsIHNwZWxsQ2hlY2sgfSksIFtzY2hlbWFUeXBlcywgc3BlbGxDaGVjaywgcmVhZE9ubHksIHJlbmRlckJsb2NrLCByZW5kZXJDaGlsZCwgcmVuZGVyTGlzdEl0ZW0sIHJlbmRlclN0eWxlXSksIHJlbmRlckxlYWYgPSB1c2VDYWxsYmFjaygobFByb3BzKSA9PiB7XG4gICAgaWYgKGxQcm9wcy5sZWFmLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgbGV0IHJlbmRlcmVkID0gLyogQF9fUFVSRV9fICovIGpzeChMZWFmLCB7IC4uLmxQcm9wcywgZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzLCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZWFkT25seSB9KTtcbiAgICAgIGlmIChyZW5kZXJQbGFjZWhvbGRlciAmJiBsUHJvcHMubGVhZi5wbGFjZWhvbGRlciAmJiBsUHJvcHMudGV4dC50ZXh0ID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHN0eWxlOiBQTEFDRUhPTERFUl9TVFlMRSwgY29udGVudEVkaXRhYmxlOiAhMSwgY2hpbGRyZW46IHJlbmRlclBsYWNlaG9sZGVyKCkgfSksXG4gICAgICAgICAgcmVuZGVyZWRcbiAgICAgICAgXSB9KTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb24gPSBsUHJvcHMubGVhZi5yYW5nZURlY29yYXRpb247XG4gICAgICByZXR1cm4gZGVjb3JhdGlvbiAmJiAocmVuZGVyZWQgPSBkZWNvcmF0aW9uLmNvbXBvbmVudCh7XG4gICAgICAgIGNoaWxkcmVuOiByZW5kZXJlZFxuICAgICAgfSkpLCByZW5kZXJlZDtcbiAgICB9XG4gICAgcmV0dXJuIGxQcm9wcy5jaGlsZHJlbjtcbiAgfSwgW2VkaXRvckFjdG9yLCByZWFkT25seSwgcmVuZGVyQW5ub3RhdGlvbiwgcmVuZGVyQ2hpbGQsIHJlbmRlckRlY29yYXRvciwgcmVuZGVyUGxhY2Vob2xkZXIsIHNjaGVtYVR5cGVzXSksIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHByb3BzU2VsZWN0aW9uKSB7XG4gICAgICBkZWJ1ZyhgU2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShwcm9wc1NlbGVjdGlvbil9YCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gbm9ybWFsaXplU2VsZWN0aW9uKHByb3BzU2VsZWN0aW9uLCBmcm9tU2xhdGVWYWx1ZShzbGF0ZUVkaXRvci5jaGlsZHJlbiwgYmxvY2tUeXBlTmFtZSkpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgZGVidWcoYE5vcm1hbGl6ZWQgc2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VsZWN0aW9uKX1gKTtcbiAgICAgICAgY29uc3Qgc2xhdGVSYW5nZSA9IHRvU2xhdGVSYW5nZShub3JtYWxpemVkU2VsZWN0aW9uLCBzbGF0ZUVkaXRvcik7XG4gICAgICAgIHNsYXRlUmFuZ2UgJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBzbGF0ZVJhbmdlKSwgc2xhdGVFZGl0b3Iub3BlcmF0aW9ucy5zb21lKChvKSA9PiBvLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogbm9ybWFsaXplZFNlbGVjdGlvblxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tUeXBlTmFtZSwgZWRpdG9yQWN0b3IsIHByb3BzU2VsZWN0aW9uLCBzbGF0ZUVkaXRvcl0pLCBzeW5jUmFuZ2VEZWNvcmF0aW9ucyA9IHVzZUNhbGxiYWNrKChvcGVyYXRpb24pID0+IHtcbiAgICBpZiAocmFuZ2VEZWNvcmF0aW9ucyAmJiByYW5nZURlY29yYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5ld1NsYXRlUmFuZ2VzID0gW107XG4gICAgICBpZiAocmFuZ2VEZWNvcmF0aW9ucy5mb3JFYWNoKChyYW5nZURlY29yYXRpb25JdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHNsYXRlUmFuZ2VfMCA9IHRvU2xhdGVSYW5nZShyYW5nZURlY29yYXRpb25JdGVtLnNlbGVjdGlvbiwgc2xhdGVFZGl0b3IpO1xuICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2Uoc2xhdGVSYW5nZV8wKSkge1xuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCAmJiByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQoe1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiByYW5nZURlY29yYXRpb25JdGVtLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1JhbmdlO1xuICAgICAgICBpZiAob3BlcmF0aW9uICYmIChuZXdSYW5nZSA9IG1vdmVSYW5nZUJ5T3BlcmF0aW9uKHNsYXRlUmFuZ2VfMCwgb3BlcmF0aW9uKSwgbmV3UmFuZ2UgJiYgbmV3UmFuZ2UgIT09IHNsYXRlUmFuZ2VfMCB8fCBuZXdSYW5nZSA9PT0gbnVsbCAmJiBzbGF0ZVJhbmdlXzApKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0VmFsdWUocG9ydGFibGVUZXh0RWRpdG9yKSwgbmV3UmFuZ2VTZWxlY3Rpb24gPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCBuZXdSYW5nZSwgc2NoZW1hVHlwZXMpO1xuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCAmJiByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQoe1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBuZXdSYW5nZVNlbGVjdGlvbixcbiAgICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbjogcmFuZ2VEZWNvcmF0aW9uSXRlbSxcbiAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UmFuZ2UgIT09IG51bGwgJiYgbmV3U2xhdGVSYW5nZXMucHVzaCh7XG4gICAgICAgICAgLi4ubmV3UmFuZ2UgfHwgc2xhdGVSYW5nZV8wLFxuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbjogcmFuZ2VEZWNvcmF0aW9uSXRlbVxuICAgICAgICB9KTtcbiAgICAgIH0pLCBuZXdTbGF0ZVJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldFJhbmdlRGVjb3JhdGlvbnNTdGF0ZShuZXdTbGF0ZVJhbmdlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VEZWNvcmF0aW9uc1N0YXRlKChyYW5nZURlY29yYXRpb25TdGF0ZV8wKSA9PiByYW5nZURlY29yYXRpb25TdGF0ZV8wLmxlbmd0aCA+IDAgPyBbXSA6IHJhbmdlRGVjb3JhdGlvblN0YXRlXzApO1xuICB9LCBbcG9ydGFibGVUZXh0RWRpdG9yLCByYW5nZURlY29yYXRpb25zLCBzY2hlbWFUeXBlcywgc2xhdGVFZGl0b3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvblJlYWR5ID0gZWRpdG9yQWN0b3Iub24oXCJyZWFkeVwiLCAoKSA9PiB7XG4gICAgICByZXN0b3JlU2VsZWN0aW9uRnJvbVByb3BzKCk7XG4gICAgfSksIG9uSW52YWxpZFZhbHVlID0gZWRpdG9yQWN0b3Iub24oXCJpbnZhbGlkIHZhbHVlXCIsICgpID0+IHtcbiAgICAgIHNldEhhc0ludmFsaWRWYWx1ZSghMCk7XG4gICAgfSksIG9uVmFsdWVDaGFuZ2VkID0gZWRpdG9yQWN0b3Iub24oXCJ2YWx1ZSBjaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgIHNldEhhc0ludmFsaWRWYWx1ZSghMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uUmVhZHkudW5zdWJzY3JpYmUoKSwgb25JbnZhbGlkVmFsdWUudW5zdWJzY3JpYmUoKSwgb25WYWx1ZUNoYW5nZWQudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbZWRpdG9yQWN0b3IsIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wc1NlbGVjdGlvbiAmJiAhaGFzSW52YWxpZFZhbHVlICYmIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgfSwgW2hhc0ludmFsaWRWYWx1ZSwgcHJvcHNTZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKTtcbiAgY29uc3Qgb3JpZ2luYWxBcHBseSA9IHVzZU1lbW8oKCkgPT4gc2xhdGVFZGl0b3IuYXBwbHksIFtzbGF0ZUVkaXRvcl0pLCBbc3luY2VkUmFuZ2VEZWNvcmF0aW9ucywgc2V0U3luY2VkUmFuZ2VEZWNvcmF0aW9uc10gPSB1c2VTdGF0ZSghMSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc3luY2VkUmFuZ2VEZWNvcmF0aW9ucyB8fCAoc2V0U3luY2VkUmFuZ2VEZWNvcmF0aW9ucyghMCksIHN5bmNSYW5nZURlY29yYXRpb25zKCkpO1xuICB9LCBbc3luY1JhbmdlRGVjb3JhdGlvbnMsIHN5bmNlZFJhbmdlRGVjb3JhdGlvbnNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0VxdWFsKHJhbmdlRGVjb3JhdGlvbnMsIHJhbmdlRGVjb3JhdGlvbnNSZWYuY3VycmVudCkgfHwgc3luY1JhbmdlRGVjb3JhdGlvbnMoKSwgcmFuZ2VEZWNvcmF0aW9uc1JlZi5jdXJyZW50ID0gcmFuZ2VEZWNvcmF0aW9ucztcbiAgfSwgW3JhbmdlRGVjb3JhdGlvbnMsIHN5bmNSYW5nZURlY29yYXRpb25zXSksIHVzZUVmZmVjdCgoKSA9PiAoc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICBvcmlnaW5hbEFwcGx5KG9wKSwgb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgc3luY1JhbmdlRGVjb3JhdGlvbnMob3ApO1xuICB9LCAoKSA9PiB7XG4gICAgc2xhdGVFZGl0b3IuYXBwbHkgPSBvcmlnaW5hbEFwcGx5O1xuICB9KSwgW29yaWdpbmFsQXBwbHksIHNsYXRlRWRpdG9yLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pO1xuICBjb25zdCBoYW5kbGVDb3B5ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgb25Db3B5ICYmIG9uQ29weShldmVudCkgIT09IHZvaWQgMCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LCBbb25Db3B5XSksIGhhbmRsZVBhc3RlID0gdXNlQ2FsbGJhY2soKGV2ZW50XzApID0+IHtcbiAgICBpZiAoZXZlbnRfMC5wcmV2ZW50RGVmYXVsdCgpLCAhc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghb25QYXN0ZSkge1xuICAgICAgZGVidWcoXCJQYXN0aW5nIG5vcm1hbGx5XCIpLCBzbGF0ZUVkaXRvci5pbnNlcnREYXRhKGV2ZW50XzAuY2xpcGJvYXJkRGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlXzAgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0VmFsdWUocG9ydGFibGVUZXh0RWRpdG9yKSwgcGF0aCA9IHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWVfMCwgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uLCBzY2hlbWFUeXBlcyk/LmZvY3VzLnBhdGggfHwgW10sIG9uUGFzdGVSZXN1bHQgPSBvblBhc3RlKHtcbiAgICAgIGV2ZW50OiBldmVudF8wLFxuICAgICAgdmFsdWU6IHZhbHVlXzAsXG4gICAgICBwYXRoLFxuICAgICAgc2NoZW1hVHlwZXNcbiAgICB9KTtcbiAgICBvblBhc3RlUmVzdWx0ID09PSB2b2lkIDAgPyAoZGVidWcoXCJObyByZXN1bHQgZnJvbSBjdXN0b20gcGFzdGUgaGFuZGxlciwgcGFzdGluZyBub3JtYWxseVwiKSwgc2xhdGVFZGl0b3IuaW5zZXJ0RGF0YShldmVudF8wLmNsaXBib2FyZERhdGEpKSA6IChlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwibG9hZGluZ1wiXG4gICAgfSksIFByb21pc2UucmVzb2x2ZShvblBhc3RlUmVzdWx0KS50aGVuKChyZXN1bHRfMCkgPT4ge1xuICAgICAgZGVidWcoXCJDdXN0b20gcGFzdGUgZnVuY3Rpb24gZnJvbSBjbGllbnQgcmVzb2x2ZWRcIiwgcmVzdWx0XzApLCAhcmVzdWx0XzAgfHwgIXJlc3VsdF8wLmluc2VydCA/IChkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpLCBzbGF0ZUVkaXRvci5pbnNlcnREYXRhKGV2ZW50XzAuY2xpcGJvYXJkRGF0YSkpIDogcmVzdWx0XzAuaW5zZXJ0ID8gc2xhdGVFZGl0b3IuaW5zZXJ0RnJhZ21lbnQodG9TbGF0ZVZhbHVlKHJlc3VsdF8wLmluc2VydCwge1xuICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgfSkpIDogY29uc29sZS53YXJuKFwiWW91ciBvblBhc3RlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyB1bmV4cGVjdGVkOlwiLCByZXN1bHRfMCk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiAoY29uc29sZS5lcnJvcihlcnJvciksIGVycm9yKSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJkb25lIGxvYWRpbmdcIlxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9LCBbZWRpdG9yQWN0b3IsIG9uUGFzdGUsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2NoZW1hVHlwZXMsIHNsYXRlRWRpdG9yXSksIGhhbmRsZU9uRm9jdXMgPSB1c2VDYWxsYmFjaygoZXZlbnRfMSkgPT4ge1xuICAgIGlmIChvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnRfMSksICFldmVudF8xLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICBzZWxlY3Rpb24gPT09IG51bGwgJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBFZGl0b3Iuc3RhcnQoc2xhdGVFZGl0b3IsIFtdKSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJmb2N1c1wiLFxuICAgICAgICBldmVudDogZXZlbnRfMVxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICBzZWxlY3Rpb24gPT09IG5ld1NlbGVjdGlvbiAmJiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlZGl0b3JBY3Rvciwgb25Gb2N1cywgcG9ydGFibGVUZXh0RWRpdG9yLCBzbGF0ZUVkaXRvcl0pLCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKChldmVudF8yKSA9PiB7XG4gICAgaWYgKG9uQ2xpY2sgJiYgb25DbGljayhldmVudF8yKSwgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uICYmIGV2ZW50XzIudGFyZ2V0ID09PSBldmVudF8yLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIGNvbnN0IFtsYXN0QmxvY2ssIHBhdGhfMF0gPSBOb2RlLmxhc3Qoc2xhdGVFZGl0b3IsIFtdKSwgZm9jdXNQYXRoID0gc2xhdGVFZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksIGxhc3RQYXRoID0gcGF0aF8wLnNsaWNlKDAsIDEpO1xuICAgICAgaWYgKFBhdGguZXF1YWxzKGZvY3VzUGF0aCwgbGFzdFBhdGgpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBOb2RlLmRlc2NlbmRhbnQoc2xhdGVFZGl0b3IsIHBhdGhfMC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGxhc3RCbG9jayAmJiBFZGl0b3IuaXNWb2lkKHNsYXRlRWRpdG9yLCBub2RlKSAmJiAoVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgICBkZWNvcmF0b3JzOiBbXVxuICAgICAgICB9KSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW29uQ2xpY2ssIHNsYXRlRWRpdG9yXSksIGhhbmRsZU9uQmx1ciA9IHVzZUNhbGxiYWNrKChldmVudF8zKSA9PiB7XG4gICAgb25CbHVyICYmIG9uQmx1cihldmVudF8zKSwgZXZlbnRfMy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHx8IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJibHVyXCIsXG4gICAgICBldmVudDogZXZlbnRfM1xuICAgIH0pO1xuICB9LCBbZWRpdG9yQWN0b3IsIG9uQmx1cl0pLCBoYW5kbGVPbkJlZm9yZUlucHV0ID0gdXNlQ2FsbGJhY2soKGV2ZW50XzQpID0+IHtcbiAgICBvbkJlZm9yZUlucHV0ICYmIG9uQmVmb3JlSW5wdXQoZXZlbnRfNCk7XG4gIH0sIFtvbkJlZm9yZUlucHV0XSksIHZhbGlkYXRlU2VsZWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3Qoc2xhdGVFZGl0b3IpLCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IHJvb3Q7XG4gICAgaWYgKHJlZi5jdXJyZW50ICE9PSBhY3RpdmVFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhzbGF0ZUVkaXRvcikuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFkb21TZWxlY3Rpb24gfHwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmdET01SYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdET01SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2Uoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAobmV3RE9NUmFuZ2Uuc3RhcnRPZmZzZXQgIT09IGV4aXN0aW5nRE9NUmFuZ2Uuc3RhcnRPZmZzZXQgfHwgbmV3RE9NUmFuZ2UuZW5kT2Zmc2V0ICE9PSBleGlzdGluZ0RPTVJhbmdlLmVuZE9mZnNldCkgJiYgKGRlYnVnKFwiRE9NIHJhbmdlIG91dCBvZiBzeW5jLCB2YWxpZGF0aW5nIHNlbGVjdGlvblwiKSwgZG9tU2VsZWN0aW9uPy5yZW1vdmVBbGxSYW5nZXMoKSwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKG5ld0RPTVJhbmdlKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBkZWJ1ZyhcIkNvdWxkIG5vdCByZXNvbHZlIHNlbGVjdGlvbiwgc2VsZWN0aW5nIHRvcCBkb2N1bWVudFwiKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvciksIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIFswLCAwXSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9LCBbcmVmLCBzbGF0ZUVkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlZGl0YWJsZUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih2YWxpZGF0ZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGVkaXRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogITEsXG4gICAgICAgIGF0dHJpYnV0ZXM6ICExLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiAhMSxcbiAgICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgICAgc3VidHJlZTogITBcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt2YWxpZGF0ZVNlbGVjdGlvbiwgZWRpdGFibGVFbGVtZW50XSk7XG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjaygoZXZlbnRfNSkgPT4ge1xuICAgIHByb3BzLm9uS2V5RG93biAmJiBwcm9wcy5vbktleURvd24oZXZlbnRfNSksIGV2ZW50XzUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgc2xhdGVFZGl0b3IucHRlV2l0aEhvdEtleXMoZXZlbnRfNSk7XG4gIH0sIFtwcm9wcywgc2xhdGVFZGl0b3JdKSwgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXdUb1NsYXRlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgPT09IG51bGwgPyBub29wIDogKF9lZGl0b3IsIGRvbVJhbmdlKSA9PiB7XG4gICAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3KHBvcnRhYmxlVGV4dEVkaXRvciwgZG9tUmFuZ2UpO1xuICAgICAgfTtcbiAgfSwgW3BvcnRhYmxlVGV4dEVkaXRvciwgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXddKSwgZGVjb3JhdGUgPSB1c2VDYWxsYmFjaygoWywgcGF0aF8xXSkgPT4ge1xuICAgIGlmIChpc0VxdWFsVG9FbXB0eUVkaXRvcihzbGF0ZUVkaXRvci5jaGlsZHJlbiwgc2NoZW1hVHlwZXMpKVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlaG9sZGVyOiAhMFxuICAgICAgfV07XG4gICAgaWYgKHBhdGhfMS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgcmVzdWx0XzEgPSByYW5nZURlY29yYXRpb25TdGF0ZS5maWx0ZXIoKGl0ZW0pID0+IFJhbmdlLmlzQ29sbGFwc2VkKGl0ZW0pID8gcGF0aF8xLmxlbmd0aCAhPT0gMiA/ICExIDogUGF0aC5lcXVhbHMoaXRlbS5mb2N1cy5wYXRoLCBwYXRoXzEpICYmIFBhdGguZXF1YWxzKGl0ZW0uYW5jaG9yLnBhdGgsIHBhdGhfMSkgOiBSYW5nZS5pbnRlcnNlY3Rpb24oaXRlbSwge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IHBhdGhfMSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogcGF0aF8xLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9KSB8fCBSYW5nZS5pbmNsdWRlcyhpdGVtLCBwYXRoXzEpKTtcbiAgICByZXR1cm4gcmVzdWx0XzEubGVuZ3RoID4gMCA/IHJlc3VsdF8xIDogW107XG4gIH0sIFtzbGF0ZUVkaXRvciwgc2NoZW1hVHlwZXMsIHJhbmdlRGVjb3JhdGlvblN0YXRlXSk7XG4gIHJldHVybiB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvciksIHNldEVkaXRhYmxlRWxlbWVudChyZWYuY3VycmVudCk7XG4gIH0sIFtzbGF0ZUVkaXRvciwgcmVmXSksIHBvcnRhYmxlVGV4dEVkaXRvciA/IGhhc0ludmFsaWRWYWx1ZSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIEVkaXRhYmxlLFxuICAgIHtcbiAgICAgIC4uLnJlc3RQcm9wcyxcbiAgICAgIGF1dG9Gb2N1czogITEsXG4gICAgICBjbGFzc05hbWU6IHJlc3RQcm9wcy5jbGFzc05hbWUgfHwgXCJwdC1lZGl0YWJsZVwiLFxuICAgICAgZGVjb3JhdGUsXG4gICAgICBvbkJsdXI6IGhhbmRsZU9uQmx1cixcbiAgICAgIG9uQ29weTogaGFuZGxlQ29weSxcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgICAgb25ET01CZWZvcmVJbnB1dDogaGFuZGxlT25CZWZvcmVJbnB1dCxcbiAgICAgIG9uRm9jdXM6IGhhbmRsZU9uRm9jdXMsXG4gICAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgICBvblBhc3RlOiBoYW5kbGVQYXN0ZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHZvaWQgMCxcbiAgICAgIHJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJMZWFmLFxuICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXc6IHNjcm9sbFNlbGVjdGlvbkludG9WaWV3VG9TbGF0ZVxuICAgIH1cbiAgKSA6IG51bGw7XG59KTtcblBvcnRhYmxlVGV4dEVkaXRhYmxlLmRpc3BsYXlOYW1lID0gXCJGb3J3YXJkUmVmKFBvcnRhYmxlVGV4dEVkaXRhYmxlKVwiO1xudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3QsIHdpdGhTZWxlY3RvciA9IHsgZXhwb3J0czoge30gfSwgd2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluID0ge30sIHNoaW0gPSB7IGV4cG9ydHM6IHt9IH0sIHVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG5mdW5jdGlvbiByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluKCkge1xuICBpZiAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW4pIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG4gIGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluID0gMTtcbiAgdmFyIGUgPSByZXF1aXJlJCQwO1xuICBmdW5jdGlvbiBoKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGIpIHx8IGEgIT09IGEgJiYgYiAhPT0gYjtcbiAgfVxuICB2YXIgayA9IHR5cGVvZiBPYmplY3QuaXMgPT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmlzIDogaCwgbCA9IGUudXNlU3RhdGUsIG0gPSBlLnVzZUVmZmVjdCwgbiA9IGUudXNlTGF5b3V0RWZmZWN0LCBwID0gZS51c2VEZWJ1Z1ZhbHVlO1xuICBmdW5jdGlvbiBxKGEsIGIpIHtcbiAgICB2YXIgZCA9IGIoKSwgZiA9IGwoe1xuICAgICAgaW5zdDoge1xuICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgZ2V0U25hcHNob3Q6IGJcbiAgICAgIH1cbiAgICB9KSwgYzIgPSBmWzBdLmluc3QsIGcgPSBmWzFdO1xuICAgIHJldHVybiBuKGZ1bmN0aW9uKCkge1xuICAgICAgYzIudmFsdWUgPSBkLCBjMi5nZXRTbmFwc2hvdCA9IGIsIHIoYzIpICYmIGcoe1xuICAgICAgICBpbnN0OiBjMlxuICAgICAgfSk7XG4gICAgfSwgW2EsIGQsIGJdKSwgbShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByKGMyKSAmJiBnKHtcbiAgICAgICAgaW5zdDogYzJcbiAgICAgIH0pLCBhKGZ1bmN0aW9uKCkge1xuICAgICAgICByKGMyKSAmJiBnKHtcbiAgICAgICAgICBpbnN0OiBjMlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIFthXSksIHAoZCksIGQ7XG4gIH1cbiAgZnVuY3Rpb24gcihhKSB7XG4gICAgdmFyIGIgPSBhLmdldFNuYXBzaG90O1xuICAgIGEgPSBhLnZhbHVlO1xuICAgIHRyeSB7XG4gICAgICB2YXIgZCA9IGIoKTtcbiAgICAgIHJldHVybiAhayhhLCBkKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdChhLCBiKSB7XG4gICAgcmV0dXJuIGIoKTtcbiAgfVxuICB2YXIgdSA9IHR5cGVvZiB3aW5kb3cgPiBcInVcIiB8fCB0eXBlb2Ygd2luZG93LmRvY3VtZW50ID4gXCJ1XCIgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ID4gXCJ1XCIgPyB0IDogcTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbi51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGUudXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHZvaWQgMCA/IGUudXNlU3luY0V4dGVybmFsU3RvcmUgOiB1LCB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG59XG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBoYXNSZXF1aXJlZFVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9kZXZlbG9wbWVudDtcbmZ1bmN0aW9uIHJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQoKSB7XG4gIHJldHVybiBoYXNSZXF1aXJlZFVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9kZXZlbG9wbWVudCB8fCAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA8IFwidVwiICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09IFwiZnVuY3Rpb25cIiAmJiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlJCQwLCBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKylcbiAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICBwcmludFdhcm5pbmcoXCJlcnJvclwiLCBmb3JtYXQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAgICAge1xuICAgICAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIHN0YWNrICE9PSBcIlwiICYmIChmb3JtYXQgKz0gXCIlc1wiLCBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSkpO1xuICAgICAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIGZvcm1hdCksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgICB2YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5pcyA6IGlzLCB1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZSwgdXNlRWZmZWN0MiA9IFJlYWN0LnVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0MiA9IFJlYWN0LnVzZUxheW91dEVmZmVjdCwgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWUsIGRpZFdhcm5PbGQxOEFscGhhID0gITEsIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITE7XG4gICAgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGRpZFdhcm5PbGQxOEFscGhhIHx8IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiAhPT0gdm9pZCAwICYmIChkaWRXYXJuT2xkMThBbHBoYSA9ICEwLCBlcnJvcihcIllvdSBhcmUgdXNpbmcgYW4gb3V0ZGF0ZWQsIHByZS1yZWxlYXNlIGFscGhhIG9mIFJlYWN0IDE4IHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlIHNoaW0gd2lsbCBub3Qgd29yayBjb3JyZWN0bHkuIFVwZ3JhZGUgdG8gYSBuZXdlciBwcmUtcmVsZWFzZS5cIikpO1xuICAgICAgdmFyIHZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSB8fCAoZXJyb3IoXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiKSwgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCk7XG4gICAgICB9XG4gICAgICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUyKHtcbiAgICAgICAgaW5zdDoge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGdldFNuYXBzaG90XG4gICAgICAgIH1cbiAgICAgIH0pLCBpbnN0ID0gX3VzZVN0YXRlWzBdLmluc3QsIGZvcmNlVXBkYXRlID0gX3VzZVN0YXRlWzFdO1xuICAgICAgcmV0dXJuIHVzZUxheW91dEVmZmVjdDIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGluc3QudmFsdWUgPSB2YWx1ZSwgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90LCBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSksIHVzZUVmZmVjdDIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VVcGRhdGUoe1xuICAgICAgICAgIGluc3RcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBoYW5kbGVTdG9yZUNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VVcGRhdGUoe1xuICAgICAgICAgICAgaW5zdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgICAgIH0sIFtzdWJzY3JpYmVdKSwgdXNlRGVidWdWYWx1ZSh2YWx1ZSksIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgICAgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3QsIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICAgICAgcmV0dXJuICFvYmplY3RJcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICByZXR1cm4gZ2V0U25hcHNob3QoKTtcbiAgICB9XG4gICAgdmFyIGNhblVzZURPTSA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50IDwgXCJ1XCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50IDwgXCJ1XCIsIGlzU2VydmVyRW52aXJvbm1lbnQgPSAhY2FuVXNlRE9NLCBzaGltMiA9IGlzU2VydmVyRW52aXJvbm1lbnQgPyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxIDogdXNlU3luY0V4dGVybmFsU3RvcmUsIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdm9pZCAwID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltMjtcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyLCB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIDwgXCJ1XCIgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PSBcImZ1bmN0aW9uXCIgJiYgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbiAgfSgpKSwgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50O1xufVxudmFyIGhhc1JlcXVpcmVkU2hpbTtcbmZ1bmN0aW9uIHJlcXVpcmVTaGltKCkge1xuICByZXR1cm4gaGFzUmVxdWlyZWRTaGltIHx8IChoYXNSZXF1aXJlZFNoaW0gPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluKCkgOiBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50KCkpLCBzaGltLmV4cG9ydHM7XG59XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuZnVuY3Rpb24gcmVxdWlyZVdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKSByZXR1cm4gd2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuICBoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbiA9IDE7XG4gIHZhciBoID0gcmVxdWlyZSQkMCwgbiA9IHJlcXVpcmVTaGltKCk7XG4gIGZ1bmN0aW9uIHAoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiICYmIChhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYikgfHwgYSAhPT0gYSAmJiBiICE9PSBiO1xuICB9XG4gIHZhciBxID0gdHlwZW9mIE9iamVjdC5pcyA9PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBwLCByID0gbi51c2VTeW5jRXh0ZXJuYWxTdG9yZSwgdCA9IGgudXNlUmVmLCB1ID0gaC51c2VFZmZlY3QsIHYgPSBoLnVzZU1lbW8sIHcgPSBoLnVzZURlYnVnVmFsdWU7XG4gIHJldHVybiB3aXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW4udXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmdW5jdGlvbihhLCBiLCBlLCBsLCBnKSB7XG4gICAgdmFyIGMyID0gdChudWxsKTtcbiAgICBpZiAoYzIuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGYgPSB7XG4gICAgICAgIGhhc1ZhbHVlOiAhMSxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH07XG4gICAgICBjMi5jdXJyZW50ID0gZjtcbiAgICB9IGVsc2UgZiA9IGMyLmN1cnJlbnQ7XG4gICAgYzIgPSB2KGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gYTIoYTMpIHtcbiAgICAgICAgaWYgKCFjMykge1xuICAgICAgICAgIGlmIChjMyA9ICEwLCBkMiA9IGEzLCBhMyA9IGwoYTMpLCBnICE9PSB2b2lkIDAgJiYgZi5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGIyID0gZi52YWx1ZTtcbiAgICAgICAgICAgIGlmIChnKGIyLCBhMykpIHJldHVybiBrID0gYjI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrID0gYTM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIyID0gaywgcShkMiwgYTMpKSByZXR1cm4gYjI7XG4gICAgICAgIHZhciBlMiA9IGwoYTMpO1xuICAgICAgICByZXR1cm4gZyAhPT0gdm9pZCAwICYmIGcoYjIsIGUyKSA/IGIyIDogKGQyID0gYTMsIGsgPSBlMik7XG4gICAgICB9XG4gICAgICB2YXIgYzMgPSAhMSwgZDIsIGssIG0gPSBlID09PSB2b2lkIDAgPyBudWxsIDogZTtcbiAgICAgIHJldHVybiBbZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhMihiKCkpO1xuICAgICAgfSwgbSA9PT0gbnVsbCA/IHZvaWQgMCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYTIobSgpKTtcbiAgICAgIH1dO1xuICAgIH0sIFtiLCBlLCBsLCBnXSk7XG4gICAgdmFyIGQgPSByKGEsIGMyWzBdLCBjMlsxXSk7XG4gICAgcmV0dXJuIHUoZnVuY3Rpb24oKSB7XG4gICAgICBmLmhhc1ZhbHVlID0gITAsIGYudmFsdWUgPSBkO1xuICAgIH0sIFtkXSksIHcoZCksIGQ7XG4gIH0sIHdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbjtcbn1cbnZhciB3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQ7XG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50KCkge1xuICByZXR1cm4gaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQgfHwgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50ID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPCBcInVcIiAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PSBcImZ1bmN0aW9uXCIgJiYgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZSQkMCwgc2hpbTIgPSByZXF1aXJlU2hpbSgpO1xuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgICB2YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5pcyA6IGlzLCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHNoaW0yLnVzZVN5bmNFeHRlcm5hbFN0b3JlLCB1c2VSZWYyID0gUmVhY3QudXNlUmVmLCB1c2VFZmZlY3QyID0gUmVhY3QudXNlRWZmZWN0LCB1c2VNZW1vMiA9IFJlYWN0LnVzZU1lbW8sIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlO1xuICAgIGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbDIpIHtcbiAgICAgIHZhciBpbnN0UmVmID0gdXNlUmVmMihudWxsKSwgaW5zdDtcbiAgICAgIGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCA/IChpbnN0ID0ge1xuICAgICAgICBoYXNWYWx1ZTogITEsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LCBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0KSA6IGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgX3VzZU1lbW8gPSB1c2VNZW1vMihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhc01lbW8gPSAhMSwgbWVtb2l6ZWRTbmFwc2hvdCwgbWVtb2l6ZWRTZWxlY3Rpb24sIG1lbW9pemVkU2VsZWN0b3IgPSBmdW5jdGlvbihuZXh0U25hcHNob3QpIHtcbiAgICAgICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgICAgIGhhc01lbW8gPSAhMCwgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgICAgIHZhciBfbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG4gICAgICAgICAgICBpZiAoaXNFcXVhbDIgIT09IHZvaWQgMCAmJiBpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzRXF1YWwyKGN1cnJlbnRTZWxlY3Rpb24sIF9uZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0aW9uID0gX25leHRTZWxlY3Rpb24sIF9uZXh0U2VsZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdCwgcHJldlNlbGVjdGlvbiA9IG1lbW9pemVkU2VsZWN0aW9uO1xuICAgICAgICAgIGlmIChvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCkpXG4gICAgICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG4gICAgICAgICAgcmV0dXJuIGlzRXF1YWwyICE9PSB2b2lkIDAgJiYgaXNFcXVhbDIocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikgPyBwcmV2U2VsZWN0aW9uIDogKG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3QsIG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbik7XG4gICAgICAgIH0sIG1heWJlR2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdm9pZCAwID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90LCBnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgICAgICB9LCBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB2b2lkIDAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW2dldFNuYXBzaG90V2l0aFNlbGVjdG9yLCBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3Rvcl07XG4gICAgICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbDJdKSwgZ2V0U2VsZWN0aW9uID0gX3VzZU1lbW9bMF0sIGdldFNlcnZlclNlbGVjdGlvbiA9IF91c2VNZW1vWzFdLCB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U2VsZWN0aW9uLCBnZXRTZXJ2ZXJTZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHVzZUVmZmVjdDIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGluc3QuaGFzVmFsdWUgPSAhMCwgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSwgW3ZhbHVlXSksIHVzZURlYnVnVmFsdWUodmFsdWUpLCB2YWx1ZTtcbiAgICB9XG4gICAgd2l0aFNlbGVjdG9yX2RldmVsb3BtZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IsIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPCBcInVcIiAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09IFwiZnVuY3Rpb25cIiAmJiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuICB9KCkpLCB3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQ7XG59XG52YXIgaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3I7XG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yKCkge1xuICByZXR1cm4gaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3IgfHwgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gd2l0aFNlbGVjdG9yLmV4cG9ydHMgPSByZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKCkgOiB3aXRoU2VsZWN0b3IuZXhwb3J0cyA9IHJlcXVpcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQoKSksIHdpdGhTZWxlY3Rvci5leHBvcnRzO1xufVxucmVxdWlyZVdpdGhTZWxlY3RvcigpO1xucmVxdWlyZVNoaW0oKTtcbmNvbnN0IGZvckVhY2hBY3RvciA9IChhY3RvclJlZiwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2soYWN0b3JSZWYpO1xuICBjb25zdCBjaGlsZHJlbiA9IGFjdG9yUmVmLmdldFNuYXBzaG90KCkuY2hpbGRyZW47XG4gIGNoaWxkcmVuICYmIE9iamVjdC52YWx1ZXMoY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgZm9yRWFjaEFjdG9yKGNoaWxkLCBjYWxsYmFjayk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHN0b3BSb290V2l0aFJlaHlkcmF0aW9uKGFjdG9yUmVmKSB7XG4gIGNvbnN0IHBlcnNpc3RlZFNuYXBzaG90cyA9IFtdO1xuICBmb3JFYWNoQWN0b3IoYWN0b3JSZWYsIChyZWYpID0+IHtcbiAgICBwZXJzaXN0ZWRTbmFwc2hvdHMucHVzaChbcmVmLCByZWYuZ2V0U25hcHNob3QoKV0pLCByZWYub2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfSk7XG4gIGNvbnN0IHN5c3RlbVNuYXBzaG90ID0gYWN0b3JSZWYuc3lzdGVtLmdldFNuYXBzaG90Py4oKTtcbiAgYWN0b3JSZWYuc3RvcCgpLCBhY3RvclJlZi5zeXN0ZW0uX3NuYXBzaG90ID0gc3lzdGVtU25hcHNob3QsIHBlcnNpc3RlZFNuYXBzaG90cy5mb3JFYWNoKChbcmVmLCBzbmFwc2hvdF0pID0+IHtcbiAgICByZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPSAwLCByZWYuX3NuYXBzaG90ID0gc25hcHNob3Q7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlSWRsZUFjdG9yUmVmKGxvZ2ljLCAuLi5bb3B0aW9uc10pIHtcbiAgbGV0IFtbY3VycmVudENvbmZpZywgYWN0b3JSZWZdLCBzZXRDdXJyZW50XSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICBjb25zdCBhY3RvclJlZjIgPSBjcmVhdGVBY3Rvcihsb2dpYywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFtsb2dpYy5jb25maWcsIGFjdG9yUmVmMl07XG4gIH0pO1xuICBpZiAobG9naWMuY29uZmlnICE9PSBjdXJyZW50Q29uZmlnKSB7XG4gICAgY29uc3QgbmV3QWN0b3JSZWYgPSBjcmVhdGVBY3Rvcihsb2dpYywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNuYXBzaG90OiBhY3RvclJlZi5nZXRQZXJzaXN0ZWRTbmFwc2hvdCh7XG4gICAgICAgIF9fdW5zYWZlQWxsb3dJbmxpbmVBY3RvcnM6ICEwXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHNldEN1cnJlbnQoW2xvZ2ljLmNvbmZpZywgbmV3QWN0b3JSZWZdKSwgYWN0b3JSZWYgPSBuZXdBY3RvclJlZjtcbiAgfVxuICByZXR1cm4gaW5kZXgoKCkgPT4ge1xuICAgIGFjdG9yUmVmLmxvZ2ljLmltcGxlbWVudGF0aW9ucyA9IGxvZ2ljLmltcGxlbWVudGF0aW9ucztcbiAgfSksIGFjdG9yUmVmO1xufVxuZnVuY3Rpb24gdXNlQWN0b3JSZWYobWFjaGluZSwgLi4uW29wdGlvbnMsIG9ic2VydmVyT3JMaXN0ZW5lcl0pIHtcbiAgY29uc3QgYWN0b3JSZWYgPSB1c2VJZGxlQWN0b3JSZWYobWFjaGluZSwgb3B0aW9ucyk7XG4gIHJldHVybiB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb2JzZXJ2ZXJPckxpc3RlbmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBzdWIgPSBhY3RvclJlZi5zdWJzY3JpYmUodG9PYnNlcnZlcihvYnNlcnZlck9yTGlzdGVuZXIpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW29ic2VydmVyT3JMaXN0ZW5lcl0pLCB1c2VFZmZlY3QoKCkgPT4gKGFjdG9yUmVmLnN0YXJ0KCksICgpID0+IHtcbiAgICBzdG9wUm9vdFdpdGhSZWh5ZHJhdGlvbihhY3RvclJlZik7XG4gIH0pLCBbYWN0b3JSZWZdKSwgYWN0b3JSZWY7XG59XG5mdW5jdGlvbiB1c2VFZGl0b3IoY29uZmlnKSB7XG4gIGNvbnN0ICQgPSBjKDgpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IGNvbmZpZy5zY2hlbWEgPyAodDAgPSBjb25maWcuc2NoZW1hLmhhc093blByb3BlcnR5KFwianNvblR5cGVcIikgPyBjb25maWcuc2NoZW1hIDogY29tcGlsZVR5cGUoY29uZmlnLnNjaGVtYSksICRbMF0gPSBjb25maWcuc2NoZW1hLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBsZXQgdDE7XG4gICRbMl0gIT09IHQwID8gKHQxID0gZ2V0UG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXModDApLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiB0MSA9ICRbM107XG4gIGNvbnN0IHNjaGVtYSA9IHQxLCB0MiA9IGNvbmZpZy5rZXlHZW5lcmF0b3IgPz8gZGVmYXVsdEtleUdlbmVyYXRvcjtcbiAgbGV0IHQzO1xuICByZXR1cm4gJFs0XSAhPT0gY29uZmlnLmJlaGF2aW9ycyB8fCAkWzVdICE9PSB0MiB8fCAkWzZdICE9PSBzY2hlbWEgPyAodDMgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIGJlaGF2aW9yczogY29uZmlnLmJlaGF2aW9ycyxcbiAgICAgIGtleUdlbmVyYXRvcjogdDIsXG4gICAgICBzY2hlbWFcbiAgICB9XG4gIH0sICRbNF0gPSBjb25maWcuYmVoYXZpb3JzLCAkWzVdID0gdDIsICRbNl0gPSBzY2hlbWEsICRbN10gPSB0MykgOiB0MyA9ICRbN10sIHVzZUFjdG9yUmVmKGVkaXRvck1hY2hpbmUsIHQzKTtcbn1cbmV4cG9ydCB7XG4gIFBvcnRhYmxlVGV4dEVkaXRhYmxlLFxuICBQb3J0YWJsZVRleHRFZGl0b3IsXG4gIGNyZWF0ZU1hcmtkb3duQmVoYXZpb3JzLFxuICBkZWZpbmVCZWhhdmlvcixcbiAgZWRpdG9yTWFjaGluZSxcbiAgZGVmYXVsdEtleUdlbmVyYXRvciBhcyBrZXlHZW5lcmF0b3IsXG4gIHVzZUVkaXRvcixcbiAgdXNlUG9ydGFibGVUZXh0RWRpdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/patches/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/patches/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isObject.js */ \"(ssr)/./node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString.js */ \"(ssr)/./node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/./node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/./node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n  if (position !== BEFORE && position !== AFTER)\n    throw new Error(`Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`);\n  const items = flatten(...args);\n  if (array.length === 0)\n    return items;\n  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n  return values.reduce((prev, item) => prev.concat(item), []);\n}\nconst hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction move(arr, from, to) {\n  const nextValue = arr.slice(), val = nextValue[from];\n  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;\n}\nfunction findTargetIndex(array, pathSegment) {\n  if (typeof pathSegment == \"number\")\n    return pathSegment;\n  const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__(array, pathSegment);\n  return index === -1 ? !1 : index;\n}\nfunction apply$3(value, patch) {\n  const nextValue = value.slice();\n  if (patch.path.length === 0) {\n    if (patch.type === \"setIfMissing\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return value === void 0 ? patch.value : value;\n    } else if (patch.type === \"set\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"move\") {\n        if (!patch.value || !hasOwn(patch.value, \"from\") || !hasOwn(patch.value, \"to\"))\n          throw new Error(\n            `Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ${JSON.stringify(\n              patch.value\n            )}`\n          );\n        return move(nextValue, patch.value.from, patch.value.to);\n      }\n    }\n    throw new Error(`Invalid array operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n  if (index === !1)\n    return nextValue;\n  if (tail.length === 0) {\n    if (patch.type === \"insert\") {\n      const { position, items } = patch;\n      return insert$1(value, position, index, items);\n    } else if (patch.type === \"unset\") {\n      if (typeof index != \"number\")\n        throw new Error(`Expected array index to be a number, instead got \"${index}\"`);\n      return nextValue.splice(index, 1), nextValue;\n    }\n  }\n  return nextValue[index] = _apply(nextValue[index], {\n    ...patch,\n    path: tail\n  }), nextValue;\n}\nfunction apply$2(value, patch) {\n  const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__(value);\n  if (patch.path.length === 0) {\n    if (patch.type === \"set\") {\n      if (!lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(patch.value))\n        throw new Error(\"Cannot set value of an object to a non-object\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"setIfMissing\")\n        return value === void 0 ? patch.value : value;\n    }\n    throw new Error(`Invalid object operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path;\n  if (typeof head != \"string\")\n    throw new Error(`Expected field name to be a string, instad got: ${head}`);\n  return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {\n    ...patch,\n    path: tail\n  }), nextValue);\n}\nconst OPERATIONS$1 = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  inc(currentValue, nextValue) {\n    return currentValue + nextValue;\n  },\n  dec(currentValue, nextValue) {\n    return currentValue - nextValue;\n  }\n}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);\nfunction apply$1(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for primitives. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  return OPERATIONS$1[patch.type](value, patch.value);\n}\nconst OPERATIONS = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  diffMatchPatch(currentValue, nextValue) {\n    const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.parsePatch)(nextValue), currentValue, {\n      allowExceedingIndices: !0\n    });\n    return result;\n  }\n}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);\nfunction apply(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for string. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  const func = OPERATIONS[patch.type];\n  if (func)\n    return func(value, patch.value);\n  throw new Error(\"Unknown patch type\");\n}\nfunction applyAll(value, patches) {\n  return patches.reduce(_apply, value);\n}\nfunction applyPatch(value, patch) {\n  return Array.isArray(value) ? apply$3(value, patch) : lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__(value) ? apply(value, patch) : lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(value) ? apply$2(value, patch) : apply$1(value, patch);\n}\nfunction _apply(value, patch) {\n  return applyPatch(value, patch);\n}\nfunction setIfMissing(value, path = []) {\n  return {\n    type: \"setIfMissing\",\n    path,\n    value\n  };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n  const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.stringifyPatches)(patches);\n  return { type: \"diffMatchPatch\", path, value: patch };\n}\nfunction insert(items, position, path = []) {\n  return {\n    type: \"insert\",\n    path,\n    position,\n    items\n  };\n}\nfunction set(value, path = []) {\n  return { type: \"set\", path, value };\n}\nfunction unset(path = []) {\n  return { type: \"unset\", path };\n}\nfunction prefixPath(patch, segment) {\n  return {\n    ...patch,\n    path: [segment, ...patch.path]\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0U7QUFDUjtBQUNGO0FBQ2lFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLG9CQUFvQixRQUFRLEtBQUssTUFBTTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUUsdURBQXVELDJDQUFJO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVyxjQUFjLDBEQUEwRCwyQkFBMkIsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsc0VBQVksQ0FBQyxvRUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVyxjQUFjLHNCQUFzQiwyQkFBMkIsc0JBQXNCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFRLGdDQUFnQywrQ0FBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVcsbUNBQW1DLDBFQUFnQjtBQUNoRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLXByby8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3BhdGNoZXMvZGlzdC9pbmRleC5qcz9kYmY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc09iamVjdCBmcm9tIFwibG9kYXNoL2lzT2JqZWN0LmpzXCI7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSBcImxvZGFzaC9pc1N0cmluZy5qc1wiO1xuaW1wb3J0IGZpbmRJbmRleCBmcm9tIFwibG9kYXNoL2ZpbmRJbmRleC5qc1wiO1xuaW1wb3J0IGNsb25lIGZyb20gXCJsb2Rhc2gvY2xvbmUuanNcIjtcbmltcG9ydCBvbWl0IGZyb20gXCJsb2Rhc2gvb21pdC5qc1wiO1xuaW1wb3J0IHsgYXBwbHlQYXRjaGVzLCBwYXJzZVBhdGNoLCBtYWtlUGF0Y2hlcywgc3RyaW5naWZ5UGF0Y2hlcyB9IGZyb20gXCJAc2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2hcIjtcbmNvbnN0IEJFRk9SRSA9IFwiYmVmb3JlXCIsIEFGVEVSID0gXCJhZnRlclwiO1xuZnVuY3Rpb24gaW5zZXJ0JDEoYXJyYXksIHBvc2l0aW9uLCBpbmRleCwgLi4uYXJncykge1xuICBpZiAocG9zaXRpb24gIT09IEJFRk9SRSAmJiBwb3NpdGlvbiAhPT0gQUZURVIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBvc2l0aW9uIFwiJHtwb3NpdGlvbn1cIiwgbXVzdCBiZSBlaXRoZXIgJHtCRUZPUkV9IG9yICR7QUZURVJ9YCk7XG4gIGNvbnN0IGl0ZW1zID0gZmxhdHRlbiguLi5hcmdzKTtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gaXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aCwgaWR4ID0gTWF0aC5hYnMoKGxlbiArIGluZGV4KSAlIGxlbikgJSBsZW4sIG5vcm1hbGl6ZWRJZHggPSBwb3NpdGlvbiA9PT0gXCJhZnRlclwiID8gaWR4ICsgMSA6IGlkeCwgY29weSA9IGFycmF5LnNsaWNlKCk7XG4gIHJldHVybiBjb3B5LnNwbGljZShub3JtYWxpemVkSWR4LCAwLCAuLi5mbGF0dGVuKGl0ZW1zKSksIGNvcHk7XG59XG5mdW5jdGlvbiBmbGF0dGVuKC4uLnZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzLnJlZHVjZSgocHJldiwgaXRlbSkgPT4gcHJldi5jb25jYXQoaXRlbSksIFtdKTtcbn1cbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuZnVuY3Rpb24gbW92ZShhcnIsIGZyb20sIHRvKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IGFyci5zbGljZSgpLCB2YWwgPSBuZXh0VmFsdWVbZnJvbV07XG4gIHJldHVybiBuZXh0VmFsdWUuc3BsaWNlKGZyb20sIDEpLCBuZXh0VmFsdWUuc3BsaWNlKHRvLCAwLCB2YWwpLCBuZXh0VmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kVGFyZ2V0SW5kZXgoYXJyYXksIHBhdGhTZWdtZW50KSB7XG4gIGlmICh0eXBlb2YgcGF0aFNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gcGF0aFNlZ21lbnQ7XG4gIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KGFycmF5LCBwYXRoU2VnbWVudCk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAhMSA6IGluZGV4O1xufVxuZnVuY3Rpb24gYXBwbHkkMyh2YWx1ZSwgcGF0Y2gpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0SWZNaXNzaW5nXCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gYXJyYXkgdG8gYSBub24tYXJyYXlcIik7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHBhdGNoLnZhbHVlIDogdmFsdWU7XG4gICAgfSBlbHNlIGlmIChwYXRjaC50eXBlID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIGFycmF5IHRvIGEgbm9uLWFycmF5XCIpO1xuICAgICAgcmV0dXJuIHBhdGNoLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgaWYgKCFwYXRjaC52YWx1ZSB8fCAhaGFzT3duKHBhdGNoLnZhbHVlLCBcImZyb21cIikgfHwgIWhhc093bihwYXRjaC52YWx1ZSwgXCJ0b1wiKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBvZiAnbW92ZScgcGF0Y2guIEV4cGVjdGVkIGEgdmFsdWUgd2l0aCBcImZyb21cIiBhbmQgXCJ0b1wiIGluZGV4ZXMsIGluc3RlYWQgZ290OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBwYXRjaC52YWx1ZVxuICAgICAgICAgICAgKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1vdmUobmV4dFZhbHVlLCBwYXRjaC52YWx1ZS5mcm9tLCBwYXRjaC52YWx1ZS50byk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSBvcGVyYXRpb246ICR7cGF0Y2gudHlwZX1gKTtcbiAgfVxuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBwYXRjaC5wYXRoLCBpbmRleCA9IGZpbmRUYXJnZXRJbmRleCh2YWx1ZSwgaGVhZCk7XG4gIGlmIChpbmRleCA9PT0gITEpXG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgaWYgKHRhaWwubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwiaW5zZXJ0XCIpIHtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb24sIGl0ZW1zIH0gPSBwYXRjaDtcbiAgICAgIHJldHVybiBpbnNlcnQkMSh2YWx1ZSwgcG9zaXRpb24sIGluZGV4LCBpdGVtcyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhcnJheSBpbmRleCB0byBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgXCIke2luZGV4fVwiYCk7XG4gICAgICByZXR1cm4gbmV4dFZhbHVlLnNwbGljZShpbmRleCwgMSksIG5leHRWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRWYWx1ZVtpbmRleF0gPSBfYXBwbHkobmV4dFZhbHVlW2luZGV4XSwge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IHRhaWxcbiAgfSksIG5leHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGFwcGx5JDIodmFsdWUsIHBhdGNoKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IGNsb25lKHZhbHVlKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmICghaXNPYmplY3QocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIG9iamVjdCB0byBhIG5vbi1vYmplY3RcIik7XG4gICAgICByZXR1cm4gcGF0Y2gudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldElmTWlzc2luZ1wiKVxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHBhdGNoLnZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvYmplY3Qgb3BlcmF0aW9uOiAke3BhdGNoLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgW2hlYWQsIC4uLnRhaWxdID0gcGF0Y2gucGF0aDtcbiAgaWYgKHR5cGVvZiBoZWFkICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBmaWVsZCBuYW1lIHRvIGJlIGEgc3RyaW5nLCBpbnN0YWQgZ290OiAke2hlYWR9YCk7XG4gIHJldHVybiB0YWlsLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC50eXBlID09PSBcInVuc2V0XCIgPyBvbWl0KG5leHRWYWx1ZSwgaGVhZCkgOiAobmV4dFZhbHVlW2hlYWRdID0gX2FwcGx5KG5leHRWYWx1ZVtoZWFkXSwge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IHRhaWxcbiAgfSksIG5leHRWYWx1ZSk7XG59XG5jb25zdCBPUEVSQVRJT05TJDEgPSB7XG4gIHJlcGxhY2UoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0KF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldElmTWlzc2luZyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHZvaWQgMCA/IG5leHRWYWx1ZSA6IGN1cnJlbnRWYWx1ZTtcbiAgfSxcbiAgdW5zZXQoX2N1cnJlbnRWYWx1ZSwgX25leHRWYWx1ZSkge1xuICB9LFxuICBpbmMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlICsgbmV4dFZhbHVlO1xuICB9LFxuICBkZWMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlIC0gbmV4dFZhbHVlO1xuICB9XG59LCBTVVBQT1JURURfUEFUQ0hfVFlQRVMkMSA9IE9iamVjdC5rZXlzKE9QRVJBVElPTlMkMSk7XG5mdW5jdGlvbiBhcHBseSQxKHZhbHVlLCBwYXRjaCkge1xuICBpZiAoIVNVUFBPUlRFRF9QQVRDSF9UWVBFUyQxLmluY2x1ZGVzKHBhdGNoLnR5cGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBwYXRjaCBvZiB1bnN1cHBvcnRlZCB0eXBlOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHBhdGNoLnR5cGVcbiAgICAgICl9XCIgZm9yIHByaW1pdGl2ZXMuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBhcHBseSBkZWVwIG9wZXJhdGlvbnMgb24gcHJpbWl0aXZlIHZhbHVlcy4gUmVjZWl2ZWQgcGF0Y2ggd2l0aCB0eXBlIFwiJHtwYXRjaC50eXBlfVwiIGFuZCBwYXRoIFwiJHtwYXRjaC5wYXRoLm1hcCgocGF0aCkgPT4gSlNPTi5zdHJpbmdpZnkocGF0aCkpLmpvaW4oXCIuXCIpfSB0aGF0IHRhcmdldGVkIHRoZSB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVwiYFxuICAgICk7XG4gIHJldHVybiBPUEVSQVRJT05TJDFbcGF0Y2gudHlwZV0odmFsdWUsIHBhdGNoLnZhbHVlKTtcbn1cbmNvbnN0IE9QRVJBVElPTlMgPSB7XG4gIHJlcGxhY2UoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0KF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldElmTWlzc2luZyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHZvaWQgMCA/IG5leHRWYWx1ZSA6IGN1cnJlbnRWYWx1ZTtcbiAgfSxcbiAgdW5zZXQoX2N1cnJlbnRWYWx1ZSwgX25leHRWYWx1ZSkge1xuICB9LFxuICBkaWZmTWF0Y2hQYXRjaChjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIGNvbnN0IFtyZXN1bHRdID0gYXBwbHlQYXRjaGVzKHBhcnNlUGF0Y2gobmV4dFZhbHVlKSwgY3VycmVudFZhbHVlLCB7XG4gICAgICBhbGxvd0V4Y2VlZGluZ0luZGljZXM6ICEwXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSwgU1VQUE9SVEVEX1BBVENIX1RZUEVTID0gT2JqZWN0LmtleXMoT1BFUkFUSU9OUyk7XG5mdW5jdGlvbiBhcHBseSh2YWx1ZSwgcGF0Y2gpIHtcbiAgaWYgKCFTVVBQT1JURURfUEFUQ0hfVFlQRVMuaW5jbHVkZXMocGF0Y2gudHlwZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJlY2VpdmVkIHBhdGNoIG9mIHVuc3VwcG9ydGVkIHR5cGU6IFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgcGF0Y2gudHlwZVxuICAgICAgKX1cIiBmb3Igc3RyaW5nLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgYXBwbHkgZGVlcCBvcGVyYXRpb25zIG9uIHN0cmluZyB2YWx1ZXMuIFJlY2VpdmVkIHBhdGNoIHdpdGggdHlwZSBcIiR7cGF0Y2gudHlwZX1cIiBhbmQgcGF0aCBcIiR7cGF0Y2gucGF0aC5qb2luKFwiLlwiKX0gdGhhdCB0YXJnZXRlZCB0aGUgdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cImBcbiAgICApO1xuICBjb25zdCBmdW5jID0gT1BFUkFUSU9OU1twYXRjaC50eXBlXTtcbiAgaWYgKGZ1bmMpXG4gICAgcmV0dXJuIGZ1bmModmFsdWUsIHBhdGNoLnZhbHVlKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwYXRjaCB0eXBlXCIpO1xufVxuZnVuY3Rpb24gYXBwbHlBbGwodmFsdWUsIHBhdGNoZXMpIHtcbiAgcmV0dXJuIHBhdGNoZXMucmVkdWNlKF9hcHBseSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYXBwbHlQYXRjaCh2YWx1ZSwgcGF0Y2gpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYXBwbHkkMyh2YWx1ZSwgcGF0Y2gpIDogaXNTdHJpbmcodmFsdWUpID8gYXBwbHkodmFsdWUsIHBhdGNoKSA6IGlzT2JqZWN0KHZhbHVlKSA/IGFwcGx5JDIodmFsdWUsIHBhdGNoKSA6IGFwcGx5JDEodmFsdWUsIHBhdGNoKTtcbn1cbmZ1bmN0aW9uIF9hcHBseSh2YWx1ZSwgcGF0Y2gpIHtcbiAgcmV0dXJuIGFwcGx5UGF0Y2godmFsdWUsIHBhdGNoKTtcbn1cbmZ1bmN0aW9uIHNldElmTWlzc2luZyh2YWx1ZSwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRJZk1pc3NpbmdcIixcbiAgICBwYXRoLFxuICAgIHZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmTWF0Y2hQYXRjaChjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSwgcGF0aCA9IFtdKSB7XG4gIGNvbnN0IHBhdGNoZXMgPSBtYWtlUGF0Y2hlcyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSksIHBhdGNoID0gc3RyaW5naWZ5UGF0Y2hlcyhwYXRjaGVzKTtcbiAgcmV0dXJuIHsgdHlwZTogXCJkaWZmTWF0Y2hQYXRjaFwiLCBwYXRoLCB2YWx1ZTogcGF0Y2ggfTtcbn1cbmZ1bmN0aW9uIGluc2VydChpdGVtcywgcG9zaXRpb24sIHBhdGggPSBbXSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgcGF0aCxcbiAgICBwb3NpdGlvbixcbiAgICBpdGVtc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0KHZhbHVlLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJzZXRcIiwgcGF0aCwgdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIHVuc2V0KHBhdGggPSBbXSkge1xuICByZXR1cm4geyB0eXBlOiBcInVuc2V0XCIsIHBhdGggfTtcbn1cbmZ1bmN0aW9uIHByZWZpeFBhdGgocGF0Y2gsIHNlZ21lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiBbc2VnbWVudCwgLi4ucGF0Y2gucGF0aF1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGFwcGx5QWxsLFxuICBkaWZmTWF0Y2hQYXRjaCxcbiAgaW5zZXJ0LFxuICBwcmVmaXhQYXRoLFxuICBzZXQsXG4gIHNldElmTWlzc2luZyxcbiAgdW5zZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value == null ? void 0 : value.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsc0NBQXNDLHFEQUFxRDtBQUN6VCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4QixpQ0FBaUMsZUFBZTtBQUN4STtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtcHJvLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcmVhY3QvZGlzdC9pbmRleC5qcz83NmYxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF9leGNsdWRlZCA9IFtcImJsb2NrXCIsIFwibGlzdFwiLCBcImxpc3RJdGVtXCIsIFwibWFya3NcIiwgXCJ0eXBlc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImxpc3RJdGVtXCJdLFxuICBfZXhjbHVkZWQzID0gW1wiX2tleVwiXTtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHsgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9OyB2YXIgbywgciwgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgdC5pbmRleE9mKG8pID49IDAgfHwge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pOyB9IHJldHVybiBpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7IGlmIChudWxsID09IHIpIHJldHVybiB7fTsgdmFyIHQgPSB7fTsgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkgeyBpZiAoZS5pbmRleE9mKG4pID49IDApIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuaW1wb3J0IHsganN4LCBGcmFnbWVudCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgbmVzdExpc3RzLCBMSVNUX05FU1RfTU9ERV9IVE1MLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBzcGFuVG9QbGFpblRleHQsIGJ1aWxkTWFya3NUcmVlIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvdG9vbGtpdFwiO1xuaW1wb3J0IHsgdG9QbGFpblRleHQgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBkZWZhdWx0TGlzdHMgPSB7XG4gICAgbnVtYmVyOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJvbFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGJ1bGxldDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9LFxuICBEZWZhdWx0TGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgbGluayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgdmFsdWVcbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiYVwiLCB7XG4gICAgaHJlZjogdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLmhyZWYsXG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIHVuZGVybGluZVN0eWxlID0ge1xuICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gIH0sXG4gIGRlZmF1bHRNYXJrcyA9IHtcbiAgICBlbTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiZW1cIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBzdHJvbmc6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInN0cm9uZ1wiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGNvZGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImNvZGVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICB1bmRlcmxpbmU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IHVuZGVybGluZVN0eWxlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBcInN0cmlrZS10aHJvdWdoXCI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImRlbFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGxpbmtcbiAgfSxcbiAgZ2V0VGVtcGxhdGUgPSAodHlwZSwgcHJvcCkgPT4gYFtAcG9ydGFibGV0ZXh0L3JlYWN0XSBVbmtub3duICR7dHlwZX0sIHNwZWNpZnkgYSBjb21wb25lbnQgZm9yIGl0IGluIHRoZSBcXGBjb21wb25lbnRzLiR7cHJvcH1cXGAgcHJvcGAsXG4gIHVua25vd25UeXBlV2FybmluZyA9IHR5cGVOYW1lID0+IGdldFRlbXBsYXRlKGBibG9jayB0eXBlIFwiJHt0eXBlTmFtZX1cImAsIFwidHlwZXNcIiksXG4gIHVua25vd25NYXJrV2FybmluZyA9IG1hcmtUeXBlID0+IGdldFRlbXBsYXRlKGBtYXJrIHR5cGUgXCIke21hcmtUeXBlfVwiYCwgXCJtYXJrc1wiKSxcbiAgdW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nID0gYmxvY2tTdHlsZSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgc3R5bGUgXCIke2Jsb2NrU3R5bGV9XCJgLCBcImJsb2NrXCIpLFxuICB1bmtub3duTGlzdFN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0XCIpLFxuICB1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGxpc3QgaXRlbSBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0SXRlbVwiKTtcbmZ1bmN0aW9uIHByaW50V2FybmluZyhtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn1cbmNvbnN0IGhpZGRlbiA9IHtcbiAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICB9LFxuICBEZWZhdWx0VW5rbm93blR5cGUgPSAoe1xuICAgIHZhbHVlLFxuICAgIGlzSW5saW5lXG4gIH0pID0+IHtcbiAgICBjb25zdCB3YXJuaW5nID0gdW5rbm93blR5cGVXYXJuaW5nKHZhbHVlLl90eXBlKTtcbiAgICByZXR1cm4gaXNJbmxpbmUgPyAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiBoaWRkZW4sXG4gICAgICBjaGlsZHJlbjogd2FybmluZ1xuICAgIH0pIDogLyogQF9fUFVSRV9fICovanN4KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiBoaWRkZW4sXG4gICAgICBjaGlsZHJlbjogd2FybmluZ1xuICAgIH0pO1xuICB9LFxuICBEZWZhdWx0VW5rbm93bk1hcmsgPSAoe1xuICAgIG1hcmtUeXBlLFxuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogYHVua25vd25fX3B0X19tYXJrX18ke21hcmtUeXBlfWAsXG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duQmxvY2tTdHlsZSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwicFwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duTGlzdCA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0VW5rbm93bkxpc3RJdGVtID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJsaVwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRIYXJkQnJlYWsgPSAoKSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJiclwiLCB7fSksXG4gIGRlZmF1bHRCbG9ja1N0eWxlcyA9IHtcbiAgICBub3JtYWw6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInBcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBibG9ja3F1b3RlOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJibG9ja3F1b3RlXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDE6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgxXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgyXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDM6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgzXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDQ6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg0XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg1XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDY6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg2XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSxcbiAgZGVmYXVsdENvbXBvbmVudHMgPSB7XG4gICAgdHlwZXM6IHt9LFxuICAgIGJsb2NrOiBkZWZhdWx0QmxvY2tTdHlsZXMsXG4gICAgbWFya3M6IGRlZmF1bHRNYXJrcyxcbiAgICBsaXN0OiBkZWZhdWx0TGlzdHMsXG4gICAgbGlzdEl0ZW06IERlZmF1bHRMaXN0SXRlbSxcbiAgICBoYXJkQnJlYWs6IERlZmF1bHRIYXJkQnJlYWssXG4gICAgdW5rbm93blR5cGU6IERlZmF1bHRVbmtub3duVHlwZSxcbiAgICB1bmtub3duTWFyazogRGVmYXVsdFVua25vd25NYXJrLFxuICAgIHVua25vd25MaXN0OiBEZWZhdWx0VW5rbm93bkxpc3QsXG4gICAgdW5rbm93bkxpc3RJdGVtOiBEZWZhdWx0VW5rbm93bkxpc3RJdGVtLFxuICAgIHVua25vd25CbG9ja1N0eWxlOiBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGVcbiAgfTtcbmZ1bmN0aW9uIG1lcmdlQ29tcG9uZW50cyhwYXJlbnQsIG92ZXJyaWRlcykge1xuICBjb25zdCB7XG4gICAgICBibG9jayxcbiAgICAgIGxpc3QsXG4gICAgICBsaXN0SXRlbSxcbiAgICAgIG1hcmtzLFxuICAgICAgdHlwZXNcbiAgICB9ID0gb3ZlcnJpZGVzLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3ZlcnJpZGVzLCBfZXhjbHVkZWQpO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnQpLCB7fSwge1xuICAgIGJsb2NrOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJibG9ja1wiKSxcbiAgICBsaXN0OiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0XCIpLFxuICAgIGxpc3RJdGVtOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0SXRlbVwiKSxcbiAgICBtYXJrczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibWFya3NcIiksXG4gICAgdHlwZXM6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcInR5cGVzXCIpXG4gIH0sIHJlc3QpO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIGtleSkge1xuICBjb25zdCBvdmVycmlkZSA9IG92ZXJyaWRlc1trZXldLFxuICAgIHBhcmVudFZhbCA9IHBhcmVudFtrZXldO1xuICByZXR1cm4gdHlwZW9mIG92ZXJyaWRlID09IFwiZnVuY3Rpb25cIiB8fCBvdmVycmlkZSAmJiB0eXBlb2YgcGFyZW50VmFsID09IFwiZnVuY3Rpb25cIiA/IG92ZXJyaWRlIDogb3ZlcnJpZGUgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFZhbCksIG92ZXJyaWRlKSA6IHBhcmVudFZhbDtcbn1cbmZ1bmN0aW9uIFBvcnRhYmxlVGV4dCh7XG4gIHZhbHVlOiBpbnB1dCxcbiAgY29tcG9uZW50czogY29tcG9uZW50T3ZlcnJpZGVzLFxuICBsaXN0TmVzdGluZ01vZGUsXG4gIG9uTWlzc2luZ0NvbXBvbmVudDogbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgPSBwcmludFdhcm5pbmdcbn0pIHtcbiAgY29uc3QgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCA9IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyIHx8IG5vb3AsXG4gICAgYmxvY2tzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF0sXG4gICAgbmVzdGVkID0gbmVzdExpc3RzKGJsb2NrcywgbGlzdE5lc3RpbmdNb2RlIHx8IExJU1RfTkVTVF9NT0RFX0hUTUwpLFxuICAgIGNvbXBvbmVudHMgPSB1c2VNZW1vKCgpID0+IGNvbXBvbmVudE92ZXJyaWRlcyA/IG1lcmdlQ29tcG9uZW50cyhkZWZhdWx0Q29tcG9uZW50cywgY29tcG9uZW50T3ZlcnJpZGVzKSA6IGRlZmF1bHRDb21wb25lbnRzLCBbY29tcG9uZW50T3ZlcnJpZGVzXSksXG4gICAgcmVuZGVyTm9kZSA9IHVzZU1lbW8oKCkgPT4gZ2V0Tm9kZVJlbmRlcmVyKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpLCBbY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudF0pLFxuICAgIHJlbmRlcmVkID0gbmVzdGVkLm1hcCgobm9kZSwgaW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiByZW5kZXJlZFxuICB9KTtcbn1cbmNvbnN0IGdldE5vZGVSZW5kZXJlciA9IChjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KSA9PiB7XG4gIGZ1bmN0aW9uIHJlbmRlck5vZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lXG4gICAgICB9ID0gb3B0aW9ucyxcbiAgICAgIGtleSA9IG5vZGUuX2tleSB8fCBgbm9kZS0ke2luZGV4fWA7XG4gICAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qobm9kZSkgPyByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIDogaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKG5vZGUpID8gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKG5vZGUpID8gcmVuZGVyU3Bhbihub2RlLCBpbmRleCwga2V5KSA6IGhhc0N1c3RvbUNvbXBvbmVudEZvck5vZGUobm9kZSkgPyByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpID8gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkgPyByZW5kZXJUZXh0KG5vZGUsIGtleSkgOiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuX3R5cGUgaW4gY29tcG9uZW50cy50eXBlcztcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSB7XG4gICAgY29uc3QgdHJlZSA9IHNlcmlhbGl6ZUJsb2NrKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSksXG4gICAgICByZW5kZXJlciA9IGNvbXBvbmVudHMubGlzdEl0ZW0sXG4gICAgICBMaSA9ICh0eXBlb2YgcmVuZGVyZXIgPT0gXCJmdW5jdGlvblwiID8gcmVuZGVyZXIgOiByZW5kZXJlcltub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW07XG4gICAgaWYgKExpID09PSBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgdHlwZTogc3R5bGUsXG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RJdGVtU3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gICAgaWYgKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICAgIGxpc3RJdGVtXG4gICAgICAgIH0gPSBub2RlLFxuICAgICAgICBibG9ja05vZGUgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG4gICAgICBjaGlsZHJlbiA9IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBibG9ja05vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KExpLCB7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGNoaWxkLl9rZXkgPyBjaGlsZCA6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQpLCB7fSwge1xuICAgICAgICAgIF9rZXk6IGBsaS0ke2luZGV4fS0ke2NoaWxkSW5kZXh9YFxuICAgICAgICB9KSxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSkpLFxuICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50cy5saXN0LFxuICAgICAgTGlzdCA9ICh0eXBlb2YgY29tcG9uZW50ID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudCA6IGNvbXBvbmVudFtub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdDtcbiAgICBpZiAoTGlzdCA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdCkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0U3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICBub2RlVHlwZTogXCJsaXN0U3R5bGVcIixcbiAgICAgICAgdHlwZTogc3R5bGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KExpc3QsIHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclNwYW4obm9kZSwgX2luZGV4LCBrZXkpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIG1hcmtEZWYsXG4gICAgICAgIG1hcmtUeXBlLFxuICAgICAgICBtYXJrS2V5XG4gICAgICB9ID0gbm9kZSxcbiAgICAgIFNwYW4gPSBjb21wb25lbnRzLm1hcmtzW21hcmtUeXBlXSB8fCBjb21wb25lbnRzLnVua25vd25NYXJrLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSkpO1xuICAgIHJldHVybiBTcGFuID09PSBjb21wb25lbnRzLnVua25vd25NYXJrICYmIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bk1hcmtXYXJuaW5nKG1hcmtUeXBlKSwge1xuICAgICAgbm9kZVR5cGU6IFwibWFya1wiLFxuICAgICAgdHlwZTogbWFya1R5cGVcbiAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KFNwYW4sIHtcbiAgICAgIHRleHQ6IHNwYW5Ub1BsYWluVGV4dChub2RlKSxcbiAgICAgIHZhbHVlOiBtYXJrRGVmLFxuICAgICAgbWFya1R5cGUsXG4gICAgICBtYXJrS2V5LFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJCbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IF9zZXJpYWxpemVCbG9jayA9IHNlcmlhbGl6ZUJsb2NrKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgX2tleVxuICAgICAgfSA9IF9zZXJpYWxpemVCbG9jayxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9zZXJpYWxpemVCbG9jaywgX2V4Y2x1ZGVkMyksXG4gICAgICBzdHlsZSA9IHByb3BzLm5vZGUuc3R5bGUgfHwgXCJub3JtYWxcIixcbiAgICAgIEJsb2NrID0gKHR5cGVvZiBjb21wb25lbnRzLmJsb2NrID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudHMuYmxvY2sgOiBjb21wb25lbnRzLmJsb2NrW3N0eWxlXSkgfHwgY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZTtcbiAgICByZXR1cm4gQmxvY2sgPT09IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGUgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1N0eWxlXCIsXG4gICAgICB0eXBlOiBzdHlsZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goQmxvY2ssIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgdmFsdWU6IHByb3BzLm5vZGUsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSksIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyVGV4dChub2RlLCBrZXkpIHtcbiAgICBpZiAobm9kZS50ZXh0ID09PSBgXG5gKSB7XG4gICAgICBjb25zdCBIYXJkQnJlYWsgPSBjb21wb25lbnRzLmhhcmRCcmVhaztcbiAgICAgIHJldHVybiBIYXJkQnJlYWsgPyAvKiBAX19QVVJFX18gKi9qc3goSGFyZEJyZWFrLCB7fSwga2V5KSA6IGBcbmA7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnRleHQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyVW5rbm93blR5cGUobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaXNJbmxpbmUsXG4gICAgICBpbmRleCxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9O1xuICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93blR5cGVXYXJuaW5nKG5vZGUuX3R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1wiLFxuICAgICAgdHlwZTogbm9kZS5fdHlwZVxuICAgIH0pO1xuICAgIGNvbnN0IFVua25vd25UeXBlID0gY29tcG9uZW50cy51bmtub3duVHlwZTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFVua25vd25UeXBlLCBfb2JqZWN0U3ByZWFkKHt9LCBub2RlT3B0aW9ucyksIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICAgIGlzSW5saW5lLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSxcbiAgICAgIE5vZGUgPSBjb21wb25lbnRzLnR5cGVzW25vZGUuX3R5cGVdO1xuICAgIHJldHVybiBOb2RlID8gLyogQF9fUFVSRV9fICovanN4KE5vZGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlbmRlck5vZGU7XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplQmxvY2sob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9ID0gb3B0aW9ucyxcbiAgICBjaGlsZHJlbiA9IGJ1aWxkTWFya3NUcmVlKG5vZGUpLm1hcCgoY2hpbGQsIGkpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBpc0lubGluZTogITAsXG4gICAgICBpbmRleDogaSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSk7XG4gIHJldHVybiB7XG4gICAgX2tleTogbm9kZS5fa2V5IHx8IGBibG9jay0ke2luZGV4fWAsXG4gICAgY2hpbGRyZW4sXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5leHBvcnQgeyBQb3J0YWJsZVRleHQsIGRlZmF1bHRDb21wb25lbnRzLCBtZXJnZUNvbXBvbmVudHMsIHRvUGxhaW5UZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const {\n    children,\n    markDefs = []\n  } = block;\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /^\\s/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0EsMklBQTJJO0FBQzNJO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG1CQUFtQjtBQUM1RTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQixNQUFNLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ2lTO0FBQ2pTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1wcm8vLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanM/YTJkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwic3BhblwiICYmIFwidGV4dFwiIGluIG5vZGUgJiYgdHlwZW9mIG5vZGUudGV4dCA9PSBcInN0cmluZ1wiICYmICh0eXBlb2Ygbm9kZS5tYXJrcyA+IFwidVwiIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5ldmVyeShtYXJrID0+IHR5cGVvZiBtYXJrID09IFwic3RyaW5nXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgYmxvY2sgZG9lc24ndCBfaGF2ZV8gdG8gYmUgbmFtZWQgJ2Jsb2NrJyAtIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlblxuICAgIC8vIGFsbG93ZWQgY2hpbGQgdHlwZXMgYW5kIG1hcmtzLCBvbmUgbWlnaHQgbmFtZSB0aGVtIGRpZmZlcmVudGx5XG4gICAgdHlwZW9mIG5vZGUuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFRvb2xraXQtdHlwZXMgbGlrZSBuZXN0ZWQgc3BhbnMgYXJlIEAtcHJlZml4ZWRcbiAgICBub2RlLl90eXBlWzBdICE9PSBcIkBcIiAmJiAoXG4gICAgLy8gYG1hcmtEZWZzYCBpc24ndCBfcmVxdWlyZWRfIHBlciBzYXksIGJ1dCBpZiBpdCdzIHRoZXJlLCBpdCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgICEoXCJtYXJrRGVmc1wiIGluIG5vZGUpIHx8ICFub2RlLm1hcmtEZWZzIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykgJiZcbiAgICAvLyBFdmVyeSBtYXJrIGRlZmluaXRpb24gbmVlZHMgdG8gaGF2ZSBhbiBgX2tleWAgdG8gYmUgbWFwcGFibGUgaW4gY2hpbGQgc3BhbnNcbiAgICBub2RlLm1hcmtEZWZzLmV2ZXJ5KGRlZiA9PiB0eXBlb2YgZGVmLl9rZXkgPT0gXCJzdHJpbmdcIikpICYmXG4gICAgLy8gYGNoaWxkcmVuYCBpcyByZXF1aXJlZCBhbmQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICBcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pICYmXG4gICAgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gdHlwZW9mIGNoaWxkID09IFwib2JqZWN0XCIgJiYgXCJfdHlwZVwiIGluIGNoaWxkKVxuICApO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKGJsb2NrKSB7XG4gIHJldHVybiBpc1BvcnRhYmxlVGV4dEJsb2NrKGJsb2NrKSAmJiBcImxpc3RJdGVtXCIgaW4gYmxvY2sgJiYgdHlwZW9mIGJsb2NrLmxpc3RJdGVtID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBibG9jay5sZXZlbCA+IFwidVwiIHx8IHR5cGVvZiBibG9jay5sZXZlbCA9PSBcIm51bWJlclwiKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QoYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLl90eXBlID09PSBcIkBsaXN0XCI7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKHNwYW4pIHtcbiAgcmV0dXJuIHNwYW4uX3R5cGUgPT09IFwiQHNwYW5cIjtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiQHRleHRcIjtcbn1cbmNvbnN0IGtub3duRGVjb3JhdG9ycyA9IFtcInN0cm9uZ1wiLCBcImVtXCIsIFwiY29kZVwiLCBcInVuZGVybGluZVwiLCBcInN0cmlrZS10aHJvdWdoXCJdO1xuZnVuY3Rpb24gc29ydE1hcmtzQnlPY2N1cmVuY2VzKHNwYW4sIGluZGV4LCBibG9ja0NoaWxkcmVuKSB7XG4gIGlmICghaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pIHx8ICFzcGFuLm1hcmtzKSByZXR1cm4gW107XG4gIGlmICghc3Bhbi5tYXJrcy5sZW5ndGgpIHJldHVybiBbXTtcbiAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzLnNsaWNlKCksXG4gICAgb2NjdXJlbmNlcyA9IHt9O1xuICByZXR1cm4gbWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICBvY2N1cmVuY2VzW21hcmtdID0gMTtcbiAgICBmb3IgKGxldCBzaWJsaW5nSW5kZXggPSBpbmRleCArIDE7IHNpYmxpbmdJbmRleCA8IGJsb2NrQ2hpbGRyZW4ubGVuZ3RoOyBzaWJsaW5nSW5kZXgrKykge1xuICAgICAgY29uc3Qgc2libGluZyA9IGJsb2NrQ2hpbGRyZW5bc2libGluZ0luZGV4XTtcbiAgICAgIGlmIChzaWJsaW5nICYmIGlzUG9ydGFibGVUZXh0U3BhbihzaWJsaW5nKSAmJiBBcnJheS5pc0FycmF5KHNpYmxpbmcubWFya3MpICYmIHNpYmxpbmcubWFya3MuaW5kZXhPZihtYXJrKSAhPT0gLTEpIG9jY3VyZW5jZXNbbWFya10rKztlbHNlIGJyZWFrO1xuICAgIH1cbiAgfSksIG1hcmtzLnNvcnQoKG1hcmtBLCBtYXJrQikgPT4gc29ydE1hcmtzKG9jY3VyZW5jZXMsIG1hcmtBLCBtYXJrQikpO1xufVxuZnVuY3Rpb24gc29ydE1hcmtzKG9jY3VyZW5jZXMsIG1hcmtBLCBtYXJrQikge1xuICBjb25zdCBhT2NjdXJlbmNlcyA9IG9jY3VyZW5jZXNbbWFya0FdLFxuICAgIGJPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQl07XG4gIGlmIChhT2NjdXJlbmNlcyAhPT0gYk9jY3VyZW5jZXMpIHJldHVybiBiT2NjdXJlbmNlcyAtIGFPY2N1cmVuY2VzO1xuICBjb25zdCBhS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQSksXG4gICAgYktub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0IpO1xuICByZXR1cm4gYUtub3duUG9zICE9PSBiS25vd25Qb3MgPyBhS25vd25Qb3MgLSBiS25vd25Qb3MgOiBtYXJrQS5sb2NhbGVDb21wYXJlKG1hcmtCKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTWFya3NUcmVlKGJsb2NrKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIG1hcmtEZWZzID0gW11cbiAgfSA9IGJsb2NrO1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHJldHVybiBbXTtcbiAgY29uc3Qgc29ydGVkTWFya3MgPSBjaGlsZHJlbi5tYXAoc29ydE1hcmtzQnlPY2N1cmVuY2VzKSxcbiAgICByb290Tm9kZSA9IHtcbiAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBtYXJrVHlwZTogXCI8dW5rbm93bj5cIlxuICAgIH07XG4gIGxldCBub2RlU3RhY2sgPSBbcm9vdE5vZGVdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3BhbiA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICghc3BhbikgY29udGludWU7XG4gICAgY29uc3QgbWFya3NOZWVkZWQgPSBzb3J0ZWRNYXJrc1tpXSB8fCBbXTtcbiAgICBsZXQgcG9zID0gMTtcbiAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCA+IDEpIGZvciAocG9zOyBwb3MgPCBub2RlU3RhY2subGVuZ3RoOyBwb3MrKykge1xuICAgICAgY29uc3QgbWFyayA9ICgoX2EgPSBub2RlU3RhY2tbcG9zXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcmtLZXkpIHx8IFwiXCIsXG4gICAgICAgIGluZGV4ID0gbWFya3NOZWVkZWQuaW5kZXhPZihtYXJrKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIGJyZWFrO1xuICAgICAgbWFya3NOZWVkZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgbm9kZVN0YWNrID0gbm9kZVN0YWNrLnNsaWNlKDAsIHBvcyk7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZVN0YWNrW25vZGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgbWFya0tleSBvZiBtYXJrc05lZWRlZCkge1xuICAgICAgICBjb25zdCBtYXJrRGVmID0gbWFya0RlZnMuZmluZChkZWYgPT4gZGVmLl9rZXkgPT09IG1hcmtLZXkpLFxuICAgICAgICAgIG1hcmtUeXBlID0gbWFya0RlZiA/IG1hcmtEZWYuX3R5cGUgOiBtYXJrS2V5LFxuICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBfdHlwZTogXCJAc3BhblwiLFxuICAgICAgICAgICAgX2tleTogc3Bhbi5fa2V5LFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgbWFya0RlZixcbiAgICAgICAgICAgIG1hcmtUeXBlLFxuICAgICAgICAgICAgbWFya0tleVxuICAgICAgICAgIH07XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuLnB1c2gobm9kZSksIG5vZGVTdGFjay5wdXNoKG5vZGUpLCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gc3Bhbi50ZXh0LnNwbGl0KGBcbmApO1xuICAgICAgICBmb3IgKGxldCBsaW5lID0gbGluZXMubGVuZ3RoOyBsaW5lLS0gPiAxOykgbGluZXMuc3BsaWNlKGxpbmUsIDAsIGBcbmApO1xuICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmNvbmNhdChsaW5lcy5tYXAodGV4dCA9PiAoe1xuICAgICAgICAgIF90eXBlOiBcIkB0ZXh0XCIsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9KSkpO1xuICAgICAgfSBlbHNlIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4uY29uY2F0KHNwYW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdE5vZGUuY2hpbGRyZW47XG59XG5mdW5jdGlvbiBuZXN0TGlzdHMoYmxvY2tzLCBtb2RlKSB7XG4gIGNvbnN0IHRyZWUgPSBbXTtcbiAgbGV0IGN1cnJlbnRMaXN0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJsb2NrID0gYmxvY2tzW2ldO1xuICAgIGlmIChibG9jaykge1xuICAgICAgaWYgKCFpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2soYmxvY2spKSB7XG4gICAgICAgIHRyZWUucHVzaChibG9jayksIGN1cnJlbnRMaXN0ID0gdm9pZCAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudExpc3QpIHtcbiAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2tNYXRjaGVzTGlzdChibG9jaywgY3VycmVudExpc3QpKSB7XG4gICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPiBjdXJyZW50TGlzdC5sZXZlbCkge1xuICAgICAgICBjb25zdCBuZXdMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSk7XG4gICAgICAgIGlmIChtb2RlID09PSBcImh0bWxcIikge1xuICAgICAgICAgIGNvbnN0IGxhc3RMaXN0SXRlbSA9IGN1cnJlbnRMaXN0LmNoaWxkcmVuW2N1cnJlbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgbmV3TGFzdENoaWxkID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsYXN0TGlzdEl0ZW0pLCB7fSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogWy4uLmxhc3RMaXN0SXRlbS5jaGlsZHJlbiwgbmV3TGlzdF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuW2N1cnJlbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbmV3TGFzdENoaWxkO1xuICAgICAgICB9IGVsc2UgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChuZXdMaXN0KTtcbiAgICAgICAgY3VycmVudExpc3QgPSBuZXdMaXN0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPCBjdXJyZW50TGlzdC5sZXZlbCkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXSxcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoaW5nQnJhbmNoICYmIGZpbmRMaXN0TWF0Y2hpbmcobWF0Y2hpbmdCcmFuY2gsIGJsb2NrKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2subGlzdEl0ZW0gIT09IGN1cnJlbnRMaXN0Lmxpc3RJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIG1hdGNoID0gbWF0Y2hpbmdCcmFuY2ggJiYgZmluZExpc3RNYXRjaGluZyhtYXRjaGluZ0JyYW5jaCwge1xuICAgICAgICAgICAgbGV2ZWw6IGJsb2NrLmxldmVsIHx8IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxpc3RJdGVtID09PSBibG9jay5saXN0SXRlbSkge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2gsIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gc3RhdGUgZW5jb3VudGVyZWQgZm9yIGJsb2NrXCIsIGJsb2NrKSwgdHJlZS5wdXNoKGJsb2NrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyZWU7XG59XG5mdW5jdGlvbiBibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBsaXN0KSB7XG4gIHJldHVybiAoYmxvY2subGV2ZWwgfHwgMSkgPT09IGxpc3QubGV2ZWwgJiYgYmxvY2subGlzdEl0ZW0gPT09IGxpc3QubGlzdEl0ZW07XG59XG5mdW5jdGlvbiBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpbmRleCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIF90eXBlOiBcIkBsaXN0XCIsXG4gICAgX2tleTogYCR7YmxvY2suX2tleSB8fCBgJHtpbmRleH1gfS1wYXJlbnRgLFxuICAgIG1vZGUsXG4gICAgbGV2ZWw6IGJsb2NrLmxldmVsIHx8IDEsXG4gICAgbGlzdEl0ZW06IGJsb2NrLmxpc3RJdGVtLFxuICAgIGNoaWxkcmVuOiBbYmxvY2tdXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kTGlzdE1hdGNoaW5nKHJvb3ROb2RlLCBtYXRjaGluZykge1xuICBjb25zdCBsZXZlbCA9IG1hdGNoaW5nLmxldmVsIHx8IDEsXG4gICAgc3R5bGUgPSBtYXRjaGluZy5saXN0SXRlbSB8fCBcIm5vcm1hbFwiLFxuICAgIGZpbHRlck9uVHlwZSA9IHR5cGVvZiBtYXRjaGluZy5saXN0SXRlbSA9PSBcInN0cmluZ1wiO1xuICBpZiAoaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChyb290Tm9kZSkgJiYgKHJvb3ROb2RlLmxldmVsIHx8IDEpID09PSBsZXZlbCAmJiBmaWx0ZXJPblR5cGUgJiYgKHJvb3ROb2RlLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIpID09PSBzdHlsZSkgcmV0dXJuIHJvb3ROb2RlO1xuICBpZiAoIShcImNoaWxkcmVuXCIgaW4gcm9vdE5vZGUpKSByZXR1cm47XG4gIGNvbnN0IG5vZGUgPSByb290Tm9kZS5jaGlsZHJlbltyb290Tm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5vZGUgJiYgIWlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSA/IGZpbmRMaXN0TWF0Y2hpbmcobm9kZSwgbWF0Y2hpbmcpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gc3BhblRvUGxhaW5UZXh0KHNwYW4pIHtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICByZXR1cm4gc3Bhbi5jaGlsZHJlbi5mb3JFYWNoKGN1cnJlbnQgPT4ge1xuICAgIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKGN1cnJlbnQpID8gdGV4dCArPSBjdXJyZW50LnRleHQgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKGN1cnJlbnQpICYmICh0ZXh0ICs9IHNwYW5Ub1BsYWluVGV4dChjdXJyZW50KSk7XG4gIH0pLCB0ZXh0O1xufVxuY29uc3QgbGVhZGluZ1NwYWNlID0gL15cXHMvLFxuICB0cmFpbGluZ1NwYWNlID0gL15cXHMvO1xuZnVuY3Rpb24gdG9QbGFpblRleHQoYmxvY2spIHtcbiAgY29uc3QgYmxvY2tzID0gQXJyYXkuaXNBcnJheShibG9jaykgPyBibG9jayA6IFtibG9ja107XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgcmV0dXJuIGJsb2Nrcy5mb3JFYWNoKChjdXJyZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNQb3J0YWJsZVRleHRCbG9jayhjdXJyZW50KSkgcmV0dXJuO1xuICAgIGxldCBwYWQgPSAhMTtcbiAgICBjdXJyZW50LmNoaWxkcmVuLmZvckVhY2goc3BhbiA9PiB7XG4gICAgICBpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgPyAodGV4dCArPSBwYWQgJiYgdGV4dCAmJiAhdHJhaWxpbmdTcGFjZS50ZXN0KHRleHQpICYmICFsZWFkaW5nU3BhY2UudGVzdChzcGFuLnRleHQpID8gXCIgXCIgOiBcIlwiLCB0ZXh0ICs9IHNwYW4udGV4dCwgcGFkID0gITEpIDogcGFkID0gITA7XG4gICAgfSksIGluZGV4ICE9PSBibG9ja3MubGVuZ3RoIC0gMSAmJiAodGV4dCArPSBgXG5cbmApO1xuICB9KSwgdGV4dDtcbn1cbmNvbnN0IExJU1RfTkVTVF9NT0RFX0hUTUwgPSBcImh0bWxcIixcbiAgTElTVF9ORVNUX01PREVfRElSRUNUID0gXCJkaXJlY3RcIjtcbmV4cG9ydCB7IExJU1RfTkVTVF9NT0RFX0RJUkVDVCwgTElTVF9ORVNUX01PREVfSFRNTCwgYnVpbGRNYXJrc1RyZWUsIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSwgbmVzdExpc3RzLCBzb3J0TWFya3NCeU9jY3VyZW5jZXMsIHNwYW5Ub1BsYWluVGV4dCwgdG9QbGFpblRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(rsc)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value == null ? void 0 : value.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsc0NBQXNDLHFEQUFxRDtBQUN6VCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4QixpQ0FBaUMsZUFBZTtBQUN4STtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtcHJvLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcmVhY3QvZGlzdC9pbmRleC5qcz8yYTE5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF9leGNsdWRlZCA9IFtcImJsb2NrXCIsIFwibGlzdFwiLCBcImxpc3RJdGVtXCIsIFwibWFya3NcIiwgXCJ0eXBlc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImxpc3RJdGVtXCJdLFxuICBfZXhjbHVkZWQzID0gW1wiX2tleVwiXTtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHsgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9OyB2YXIgbywgciwgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgdC5pbmRleE9mKG8pID49IDAgfHwge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pOyB9IHJldHVybiBpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7IGlmIChudWxsID09IHIpIHJldHVybiB7fTsgdmFyIHQgPSB7fTsgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkgeyBpZiAoZS5pbmRleE9mKG4pID49IDApIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuaW1wb3J0IHsganN4LCBGcmFnbWVudCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgbmVzdExpc3RzLCBMSVNUX05FU1RfTU9ERV9IVE1MLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBzcGFuVG9QbGFpblRleHQsIGJ1aWxkTWFya3NUcmVlIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvdG9vbGtpdFwiO1xuaW1wb3J0IHsgdG9QbGFpblRleHQgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBkZWZhdWx0TGlzdHMgPSB7XG4gICAgbnVtYmVyOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJvbFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGJ1bGxldDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9LFxuICBEZWZhdWx0TGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgbGluayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgdmFsdWVcbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiYVwiLCB7XG4gICAgaHJlZjogdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLmhyZWYsXG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIHVuZGVybGluZVN0eWxlID0ge1xuICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gIH0sXG4gIGRlZmF1bHRNYXJrcyA9IHtcbiAgICBlbTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiZW1cIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBzdHJvbmc6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInN0cm9uZ1wiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGNvZGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImNvZGVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICB1bmRlcmxpbmU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IHVuZGVybGluZVN0eWxlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBcInN0cmlrZS10aHJvdWdoXCI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImRlbFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGxpbmtcbiAgfSxcbiAgZ2V0VGVtcGxhdGUgPSAodHlwZSwgcHJvcCkgPT4gYFtAcG9ydGFibGV0ZXh0L3JlYWN0XSBVbmtub3duICR7dHlwZX0sIHNwZWNpZnkgYSBjb21wb25lbnQgZm9yIGl0IGluIHRoZSBcXGBjb21wb25lbnRzLiR7cHJvcH1cXGAgcHJvcGAsXG4gIHVua25vd25UeXBlV2FybmluZyA9IHR5cGVOYW1lID0+IGdldFRlbXBsYXRlKGBibG9jayB0eXBlIFwiJHt0eXBlTmFtZX1cImAsIFwidHlwZXNcIiksXG4gIHVua25vd25NYXJrV2FybmluZyA9IG1hcmtUeXBlID0+IGdldFRlbXBsYXRlKGBtYXJrIHR5cGUgXCIke21hcmtUeXBlfVwiYCwgXCJtYXJrc1wiKSxcbiAgdW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nID0gYmxvY2tTdHlsZSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgc3R5bGUgXCIke2Jsb2NrU3R5bGV9XCJgLCBcImJsb2NrXCIpLFxuICB1bmtub3duTGlzdFN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0XCIpLFxuICB1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGxpc3QgaXRlbSBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0SXRlbVwiKTtcbmZ1bmN0aW9uIHByaW50V2FybmluZyhtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn1cbmNvbnN0IGhpZGRlbiA9IHtcbiAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICB9LFxuICBEZWZhdWx0VW5rbm93blR5cGUgPSAoe1xuICAgIHZhbHVlLFxuICAgIGlzSW5saW5lXG4gIH0pID0+IHtcbiAgICBjb25zdCB3YXJuaW5nID0gdW5rbm93blR5cGVXYXJuaW5nKHZhbHVlLl90eXBlKTtcbiAgICByZXR1cm4gaXNJbmxpbmUgPyAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiBoaWRkZW4sXG4gICAgICBjaGlsZHJlbjogd2FybmluZ1xuICAgIH0pIDogLyogQF9fUFVSRV9fICovanN4KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiBoaWRkZW4sXG4gICAgICBjaGlsZHJlbjogd2FybmluZ1xuICAgIH0pO1xuICB9LFxuICBEZWZhdWx0VW5rbm93bk1hcmsgPSAoe1xuICAgIG1hcmtUeXBlLFxuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogYHVua25vd25fX3B0X19tYXJrX18ke21hcmtUeXBlfWAsXG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duQmxvY2tTdHlsZSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwicFwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duTGlzdCA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0VW5rbm93bkxpc3RJdGVtID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJsaVwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRIYXJkQnJlYWsgPSAoKSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJiclwiLCB7fSksXG4gIGRlZmF1bHRCbG9ja1N0eWxlcyA9IHtcbiAgICBub3JtYWw6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInBcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBibG9ja3F1b3RlOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJibG9ja3F1b3RlXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDE6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgxXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgyXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDM6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgzXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDQ6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg0XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg1XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDY6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg2XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSxcbiAgZGVmYXVsdENvbXBvbmVudHMgPSB7XG4gICAgdHlwZXM6IHt9LFxuICAgIGJsb2NrOiBkZWZhdWx0QmxvY2tTdHlsZXMsXG4gICAgbWFya3M6IGRlZmF1bHRNYXJrcyxcbiAgICBsaXN0OiBkZWZhdWx0TGlzdHMsXG4gICAgbGlzdEl0ZW06IERlZmF1bHRMaXN0SXRlbSxcbiAgICBoYXJkQnJlYWs6IERlZmF1bHRIYXJkQnJlYWssXG4gICAgdW5rbm93blR5cGU6IERlZmF1bHRVbmtub3duVHlwZSxcbiAgICB1bmtub3duTWFyazogRGVmYXVsdFVua25vd25NYXJrLFxuICAgIHVua25vd25MaXN0OiBEZWZhdWx0VW5rbm93bkxpc3QsXG4gICAgdW5rbm93bkxpc3RJdGVtOiBEZWZhdWx0VW5rbm93bkxpc3RJdGVtLFxuICAgIHVua25vd25CbG9ja1N0eWxlOiBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGVcbiAgfTtcbmZ1bmN0aW9uIG1lcmdlQ29tcG9uZW50cyhwYXJlbnQsIG92ZXJyaWRlcykge1xuICBjb25zdCB7XG4gICAgICBibG9jayxcbiAgICAgIGxpc3QsXG4gICAgICBsaXN0SXRlbSxcbiAgICAgIG1hcmtzLFxuICAgICAgdHlwZXNcbiAgICB9ID0gb3ZlcnJpZGVzLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3ZlcnJpZGVzLCBfZXhjbHVkZWQpO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnQpLCB7fSwge1xuICAgIGJsb2NrOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJibG9ja1wiKSxcbiAgICBsaXN0OiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0XCIpLFxuICAgIGxpc3RJdGVtOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0SXRlbVwiKSxcbiAgICBtYXJrczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibWFya3NcIiksXG4gICAgdHlwZXM6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcInR5cGVzXCIpXG4gIH0sIHJlc3QpO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIGtleSkge1xuICBjb25zdCBvdmVycmlkZSA9IG92ZXJyaWRlc1trZXldLFxuICAgIHBhcmVudFZhbCA9IHBhcmVudFtrZXldO1xuICByZXR1cm4gdHlwZW9mIG92ZXJyaWRlID09IFwiZnVuY3Rpb25cIiB8fCBvdmVycmlkZSAmJiB0eXBlb2YgcGFyZW50VmFsID09IFwiZnVuY3Rpb25cIiA/IG92ZXJyaWRlIDogb3ZlcnJpZGUgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFZhbCksIG92ZXJyaWRlKSA6IHBhcmVudFZhbDtcbn1cbmZ1bmN0aW9uIFBvcnRhYmxlVGV4dCh7XG4gIHZhbHVlOiBpbnB1dCxcbiAgY29tcG9uZW50czogY29tcG9uZW50T3ZlcnJpZGVzLFxuICBsaXN0TmVzdGluZ01vZGUsXG4gIG9uTWlzc2luZ0NvbXBvbmVudDogbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgPSBwcmludFdhcm5pbmdcbn0pIHtcbiAgY29uc3QgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCA9IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyIHx8IG5vb3AsXG4gICAgYmxvY2tzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF0sXG4gICAgbmVzdGVkID0gbmVzdExpc3RzKGJsb2NrcywgbGlzdE5lc3RpbmdNb2RlIHx8IExJU1RfTkVTVF9NT0RFX0hUTUwpLFxuICAgIGNvbXBvbmVudHMgPSB1c2VNZW1vKCgpID0+IGNvbXBvbmVudE92ZXJyaWRlcyA/IG1lcmdlQ29tcG9uZW50cyhkZWZhdWx0Q29tcG9uZW50cywgY29tcG9uZW50T3ZlcnJpZGVzKSA6IGRlZmF1bHRDb21wb25lbnRzLCBbY29tcG9uZW50T3ZlcnJpZGVzXSksXG4gICAgcmVuZGVyTm9kZSA9IHVzZU1lbW8oKCkgPT4gZ2V0Tm9kZVJlbmRlcmVyKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpLCBbY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudF0pLFxuICAgIHJlbmRlcmVkID0gbmVzdGVkLm1hcCgobm9kZSwgaW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiByZW5kZXJlZFxuICB9KTtcbn1cbmNvbnN0IGdldE5vZGVSZW5kZXJlciA9IChjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KSA9PiB7XG4gIGZ1bmN0aW9uIHJlbmRlck5vZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lXG4gICAgICB9ID0gb3B0aW9ucyxcbiAgICAgIGtleSA9IG5vZGUuX2tleSB8fCBgbm9kZS0ke2luZGV4fWA7XG4gICAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qobm9kZSkgPyByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIDogaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKG5vZGUpID8gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKG5vZGUpID8gcmVuZGVyU3Bhbihub2RlLCBpbmRleCwga2V5KSA6IGhhc0N1c3RvbUNvbXBvbmVudEZvck5vZGUobm9kZSkgPyByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpID8gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkgPyByZW5kZXJUZXh0KG5vZGUsIGtleSkgOiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuX3R5cGUgaW4gY29tcG9uZW50cy50eXBlcztcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSB7XG4gICAgY29uc3QgdHJlZSA9IHNlcmlhbGl6ZUJsb2NrKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSksXG4gICAgICByZW5kZXJlciA9IGNvbXBvbmVudHMubGlzdEl0ZW0sXG4gICAgICBMaSA9ICh0eXBlb2YgcmVuZGVyZXIgPT0gXCJmdW5jdGlvblwiID8gcmVuZGVyZXIgOiByZW5kZXJlcltub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW07XG4gICAgaWYgKExpID09PSBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgdHlwZTogc3R5bGUsXG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RJdGVtU3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gICAgaWYgKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICAgIGxpc3RJdGVtXG4gICAgICAgIH0gPSBub2RlLFxuICAgICAgICBibG9ja05vZGUgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG4gICAgICBjaGlsZHJlbiA9IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBibG9ja05vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KExpLCB7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGNoaWxkLl9rZXkgPyBjaGlsZCA6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQpLCB7fSwge1xuICAgICAgICAgIF9rZXk6IGBsaS0ke2luZGV4fS0ke2NoaWxkSW5kZXh9YFxuICAgICAgICB9KSxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSkpLFxuICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50cy5saXN0LFxuICAgICAgTGlzdCA9ICh0eXBlb2YgY29tcG9uZW50ID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudCA6IGNvbXBvbmVudFtub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdDtcbiAgICBpZiAoTGlzdCA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdCkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0U3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICBub2RlVHlwZTogXCJsaXN0U3R5bGVcIixcbiAgICAgICAgdHlwZTogc3R5bGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KExpc3QsIHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclNwYW4obm9kZSwgX2luZGV4LCBrZXkpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIG1hcmtEZWYsXG4gICAgICAgIG1hcmtUeXBlLFxuICAgICAgICBtYXJrS2V5XG4gICAgICB9ID0gbm9kZSxcbiAgICAgIFNwYW4gPSBjb21wb25lbnRzLm1hcmtzW21hcmtUeXBlXSB8fCBjb21wb25lbnRzLnVua25vd25NYXJrLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSkpO1xuICAgIHJldHVybiBTcGFuID09PSBjb21wb25lbnRzLnVua25vd25NYXJrICYmIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bk1hcmtXYXJuaW5nKG1hcmtUeXBlKSwge1xuICAgICAgbm9kZVR5cGU6IFwibWFya1wiLFxuICAgICAgdHlwZTogbWFya1R5cGVcbiAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KFNwYW4sIHtcbiAgICAgIHRleHQ6IHNwYW5Ub1BsYWluVGV4dChub2RlKSxcbiAgICAgIHZhbHVlOiBtYXJrRGVmLFxuICAgICAgbWFya1R5cGUsXG4gICAgICBtYXJrS2V5LFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJCbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IF9zZXJpYWxpemVCbG9jayA9IHNlcmlhbGl6ZUJsb2NrKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgX2tleVxuICAgICAgfSA9IF9zZXJpYWxpemVCbG9jayxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9zZXJpYWxpemVCbG9jaywgX2V4Y2x1ZGVkMyksXG4gICAgICBzdHlsZSA9IHByb3BzLm5vZGUuc3R5bGUgfHwgXCJub3JtYWxcIixcbiAgICAgIEJsb2NrID0gKHR5cGVvZiBjb21wb25lbnRzLmJsb2NrID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudHMuYmxvY2sgOiBjb21wb25lbnRzLmJsb2NrW3N0eWxlXSkgfHwgY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZTtcbiAgICByZXR1cm4gQmxvY2sgPT09IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGUgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1N0eWxlXCIsXG4gICAgICB0eXBlOiBzdHlsZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goQmxvY2ssIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgdmFsdWU6IHByb3BzLm5vZGUsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSksIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyVGV4dChub2RlLCBrZXkpIHtcbiAgICBpZiAobm9kZS50ZXh0ID09PSBgXG5gKSB7XG4gICAgICBjb25zdCBIYXJkQnJlYWsgPSBjb21wb25lbnRzLmhhcmRCcmVhaztcbiAgICAgIHJldHVybiBIYXJkQnJlYWsgPyAvKiBAX19QVVJFX18gKi9qc3goSGFyZEJyZWFrLCB7fSwga2V5KSA6IGBcbmA7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnRleHQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyVW5rbm93blR5cGUobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaXNJbmxpbmUsXG4gICAgICBpbmRleCxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9O1xuICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93blR5cGVXYXJuaW5nKG5vZGUuX3R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1wiLFxuICAgICAgdHlwZTogbm9kZS5fdHlwZVxuICAgIH0pO1xuICAgIGNvbnN0IFVua25vd25UeXBlID0gY29tcG9uZW50cy51bmtub3duVHlwZTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFVua25vd25UeXBlLCBfb2JqZWN0U3ByZWFkKHt9LCBub2RlT3B0aW9ucyksIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICAgIGlzSW5saW5lLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSxcbiAgICAgIE5vZGUgPSBjb21wb25lbnRzLnR5cGVzW25vZGUuX3R5cGVdO1xuICAgIHJldHVybiBOb2RlID8gLyogQF9fUFVSRV9fICovanN4KE5vZGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlbmRlck5vZGU7XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplQmxvY2sob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9ID0gb3B0aW9ucyxcbiAgICBjaGlsZHJlbiA9IGJ1aWxkTWFya3NUcmVlKG5vZGUpLm1hcCgoY2hpbGQsIGkpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBpc0lubGluZTogITAsXG4gICAgICBpbmRleDogaSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSk7XG4gIHJldHVybiB7XG4gICAgX2tleTogbm9kZS5fa2V5IHx8IGBibG9jay0ke2luZGV4fWAsXG4gICAgY2hpbGRyZW4sXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5leHBvcnQgeyBQb3J0YWJsZVRleHQsIGRlZmF1bHRDb21wb25lbnRzLCBtZXJnZUNvbXBvbmVudHMsIHRvUGxhaW5UZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const {\n    children,\n    markDefs = []\n  } = block;\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /^\\s/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0EsMklBQTJJO0FBQzNJO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG1CQUFtQjtBQUM1RTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQixNQUFNLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ2lTO0FBQ2pTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1wcm8vLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanM/MmUzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwic3BhblwiICYmIFwidGV4dFwiIGluIG5vZGUgJiYgdHlwZW9mIG5vZGUudGV4dCA9PSBcInN0cmluZ1wiICYmICh0eXBlb2Ygbm9kZS5tYXJrcyA+IFwidVwiIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5ldmVyeShtYXJrID0+IHR5cGVvZiBtYXJrID09IFwic3RyaW5nXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgYmxvY2sgZG9lc24ndCBfaGF2ZV8gdG8gYmUgbmFtZWQgJ2Jsb2NrJyAtIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlblxuICAgIC8vIGFsbG93ZWQgY2hpbGQgdHlwZXMgYW5kIG1hcmtzLCBvbmUgbWlnaHQgbmFtZSB0aGVtIGRpZmZlcmVudGx5XG4gICAgdHlwZW9mIG5vZGUuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFRvb2xraXQtdHlwZXMgbGlrZSBuZXN0ZWQgc3BhbnMgYXJlIEAtcHJlZml4ZWRcbiAgICBub2RlLl90eXBlWzBdICE9PSBcIkBcIiAmJiAoXG4gICAgLy8gYG1hcmtEZWZzYCBpc24ndCBfcmVxdWlyZWRfIHBlciBzYXksIGJ1dCBpZiBpdCdzIHRoZXJlLCBpdCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgICEoXCJtYXJrRGVmc1wiIGluIG5vZGUpIHx8ICFub2RlLm1hcmtEZWZzIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykgJiZcbiAgICAvLyBFdmVyeSBtYXJrIGRlZmluaXRpb24gbmVlZHMgdG8gaGF2ZSBhbiBgX2tleWAgdG8gYmUgbWFwcGFibGUgaW4gY2hpbGQgc3BhbnNcbiAgICBub2RlLm1hcmtEZWZzLmV2ZXJ5KGRlZiA9PiB0eXBlb2YgZGVmLl9rZXkgPT0gXCJzdHJpbmdcIikpICYmXG4gICAgLy8gYGNoaWxkcmVuYCBpcyByZXF1aXJlZCBhbmQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICBcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pICYmXG4gICAgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gdHlwZW9mIGNoaWxkID09IFwib2JqZWN0XCIgJiYgXCJfdHlwZVwiIGluIGNoaWxkKVxuICApO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKGJsb2NrKSB7XG4gIHJldHVybiBpc1BvcnRhYmxlVGV4dEJsb2NrKGJsb2NrKSAmJiBcImxpc3RJdGVtXCIgaW4gYmxvY2sgJiYgdHlwZW9mIGJsb2NrLmxpc3RJdGVtID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBibG9jay5sZXZlbCA+IFwidVwiIHx8IHR5cGVvZiBibG9jay5sZXZlbCA9PSBcIm51bWJlclwiKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QoYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLl90eXBlID09PSBcIkBsaXN0XCI7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKHNwYW4pIHtcbiAgcmV0dXJuIHNwYW4uX3R5cGUgPT09IFwiQHNwYW5cIjtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiQHRleHRcIjtcbn1cbmNvbnN0IGtub3duRGVjb3JhdG9ycyA9IFtcInN0cm9uZ1wiLCBcImVtXCIsIFwiY29kZVwiLCBcInVuZGVybGluZVwiLCBcInN0cmlrZS10aHJvdWdoXCJdO1xuZnVuY3Rpb24gc29ydE1hcmtzQnlPY2N1cmVuY2VzKHNwYW4sIGluZGV4LCBibG9ja0NoaWxkcmVuKSB7XG4gIGlmICghaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pIHx8ICFzcGFuLm1hcmtzKSByZXR1cm4gW107XG4gIGlmICghc3Bhbi5tYXJrcy5sZW5ndGgpIHJldHVybiBbXTtcbiAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzLnNsaWNlKCksXG4gICAgb2NjdXJlbmNlcyA9IHt9O1xuICByZXR1cm4gbWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICBvY2N1cmVuY2VzW21hcmtdID0gMTtcbiAgICBmb3IgKGxldCBzaWJsaW5nSW5kZXggPSBpbmRleCArIDE7IHNpYmxpbmdJbmRleCA8IGJsb2NrQ2hpbGRyZW4ubGVuZ3RoOyBzaWJsaW5nSW5kZXgrKykge1xuICAgICAgY29uc3Qgc2libGluZyA9IGJsb2NrQ2hpbGRyZW5bc2libGluZ0luZGV4XTtcbiAgICAgIGlmIChzaWJsaW5nICYmIGlzUG9ydGFibGVUZXh0U3BhbihzaWJsaW5nKSAmJiBBcnJheS5pc0FycmF5KHNpYmxpbmcubWFya3MpICYmIHNpYmxpbmcubWFya3MuaW5kZXhPZihtYXJrKSAhPT0gLTEpIG9jY3VyZW5jZXNbbWFya10rKztlbHNlIGJyZWFrO1xuICAgIH1cbiAgfSksIG1hcmtzLnNvcnQoKG1hcmtBLCBtYXJrQikgPT4gc29ydE1hcmtzKG9jY3VyZW5jZXMsIG1hcmtBLCBtYXJrQikpO1xufVxuZnVuY3Rpb24gc29ydE1hcmtzKG9jY3VyZW5jZXMsIG1hcmtBLCBtYXJrQikge1xuICBjb25zdCBhT2NjdXJlbmNlcyA9IG9jY3VyZW5jZXNbbWFya0FdLFxuICAgIGJPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQl07XG4gIGlmIChhT2NjdXJlbmNlcyAhPT0gYk9jY3VyZW5jZXMpIHJldHVybiBiT2NjdXJlbmNlcyAtIGFPY2N1cmVuY2VzO1xuICBjb25zdCBhS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQSksXG4gICAgYktub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0IpO1xuICByZXR1cm4gYUtub3duUG9zICE9PSBiS25vd25Qb3MgPyBhS25vd25Qb3MgLSBiS25vd25Qb3MgOiBtYXJrQS5sb2NhbGVDb21wYXJlKG1hcmtCKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTWFya3NUcmVlKGJsb2NrKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIG1hcmtEZWZzID0gW11cbiAgfSA9IGJsb2NrO1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHJldHVybiBbXTtcbiAgY29uc3Qgc29ydGVkTWFya3MgPSBjaGlsZHJlbi5tYXAoc29ydE1hcmtzQnlPY2N1cmVuY2VzKSxcbiAgICByb290Tm9kZSA9IHtcbiAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBtYXJrVHlwZTogXCI8dW5rbm93bj5cIlxuICAgIH07XG4gIGxldCBub2RlU3RhY2sgPSBbcm9vdE5vZGVdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3BhbiA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICghc3BhbikgY29udGludWU7XG4gICAgY29uc3QgbWFya3NOZWVkZWQgPSBzb3J0ZWRNYXJrc1tpXSB8fCBbXTtcbiAgICBsZXQgcG9zID0gMTtcbiAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCA+IDEpIGZvciAocG9zOyBwb3MgPCBub2RlU3RhY2subGVuZ3RoOyBwb3MrKykge1xuICAgICAgY29uc3QgbWFyayA9ICgoX2EgPSBub2RlU3RhY2tbcG9zXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcmtLZXkpIHx8IFwiXCIsXG4gICAgICAgIGluZGV4ID0gbWFya3NOZWVkZWQuaW5kZXhPZihtYXJrKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIGJyZWFrO1xuICAgICAgbWFya3NOZWVkZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgbm9kZVN0YWNrID0gbm9kZVN0YWNrLnNsaWNlKDAsIHBvcyk7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZVN0YWNrW25vZGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgbWFya0tleSBvZiBtYXJrc05lZWRlZCkge1xuICAgICAgICBjb25zdCBtYXJrRGVmID0gbWFya0RlZnMuZmluZChkZWYgPT4gZGVmLl9rZXkgPT09IG1hcmtLZXkpLFxuICAgICAgICAgIG1hcmtUeXBlID0gbWFya0RlZiA/IG1hcmtEZWYuX3R5cGUgOiBtYXJrS2V5LFxuICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBfdHlwZTogXCJAc3BhblwiLFxuICAgICAgICAgICAgX2tleTogc3Bhbi5fa2V5LFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgbWFya0RlZixcbiAgICAgICAgICAgIG1hcmtUeXBlLFxuICAgICAgICAgICAgbWFya0tleVxuICAgICAgICAgIH07XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuLnB1c2gobm9kZSksIG5vZGVTdGFjay5wdXNoKG5vZGUpLCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gc3Bhbi50ZXh0LnNwbGl0KGBcbmApO1xuICAgICAgICBmb3IgKGxldCBsaW5lID0gbGluZXMubGVuZ3RoOyBsaW5lLS0gPiAxOykgbGluZXMuc3BsaWNlKGxpbmUsIDAsIGBcbmApO1xuICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmNvbmNhdChsaW5lcy5tYXAodGV4dCA9PiAoe1xuICAgICAgICAgIF90eXBlOiBcIkB0ZXh0XCIsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9KSkpO1xuICAgICAgfSBlbHNlIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4uY29uY2F0KHNwYW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdE5vZGUuY2hpbGRyZW47XG59XG5mdW5jdGlvbiBuZXN0TGlzdHMoYmxvY2tzLCBtb2RlKSB7XG4gIGNvbnN0IHRyZWUgPSBbXTtcbiAgbGV0IGN1cnJlbnRMaXN0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJsb2NrID0gYmxvY2tzW2ldO1xuICAgIGlmIChibG9jaykge1xuICAgICAgaWYgKCFpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2soYmxvY2spKSB7XG4gICAgICAgIHRyZWUucHVzaChibG9jayksIGN1cnJlbnRMaXN0ID0gdm9pZCAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudExpc3QpIHtcbiAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2tNYXRjaGVzTGlzdChibG9jaywgY3VycmVudExpc3QpKSB7XG4gICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPiBjdXJyZW50TGlzdC5sZXZlbCkge1xuICAgICAgICBjb25zdCBuZXdMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSk7XG4gICAgICAgIGlmIChtb2RlID09PSBcImh0bWxcIikge1xuICAgICAgICAgIGNvbnN0IGxhc3RMaXN0SXRlbSA9IGN1cnJlbnRMaXN0LmNoaWxkcmVuW2N1cnJlbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgbmV3TGFzdENoaWxkID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsYXN0TGlzdEl0ZW0pLCB7fSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogWy4uLmxhc3RMaXN0SXRlbS5jaGlsZHJlbiwgbmV3TGlzdF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuW2N1cnJlbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbmV3TGFzdENoaWxkO1xuICAgICAgICB9IGVsc2UgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChuZXdMaXN0KTtcbiAgICAgICAgY3VycmVudExpc3QgPSBuZXdMaXN0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPCBjdXJyZW50TGlzdC5sZXZlbCkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXSxcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoaW5nQnJhbmNoICYmIGZpbmRMaXN0TWF0Y2hpbmcobWF0Y2hpbmdCcmFuY2gsIGJsb2NrKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2subGlzdEl0ZW0gIT09IGN1cnJlbnRMaXN0Lmxpc3RJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIG1hdGNoID0gbWF0Y2hpbmdCcmFuY2ggJiYgZmluZExpc3RNYXRjaGluZyhtYXRjaGluZ0JyYW5jaCwge1xuICAgICAgICAgICAgbGV2ZWw6IGJsb2NrLmxldmVsIHx8IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxpc3RJdGVtID09PSBibG9jay5saXN0SXRlbSkge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2gsIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gc3RhdGUgZW5jb3VudGVyZWQgZm9yIGJsb2NrXCIsIGJsb2NrKSwgdHJlZS5wdXNoKGJsb2NrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyZWU7XG59XG5mdW5jdGlvbiBibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBsaXN0KSB7XG4gIHJldHVybiAoYmxvY2subGV2ZWwgfHwgMSkgPT09IGxpc3QubGV2ZWwgJiYgYmxvY2subGlzdEl0ZW0gPT09IGxpc3QubGlzdEl0ZW07XG59XG5mdW5jdGlvbiBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpbmRleCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIF90eXBlOiBcIkBsaXN0XCIsXG4gICAgX2tleTogYCR7YmxvY2suX2tleSB8fCBgJHtpbmRleH1gfS1wYXJlbnRgLFxuICAgIG1vZGUsXG4gICAgbGV2ZWw6IGJsb2NrLmxldmVsIHx8IDEsXG4gICAgbGlzdEl0ZW06IGJsb2NrLmxpc3RJdGVtLFxuICAgIGNoaWxkcmVuOiBbYmxvY2tdXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kTGlzdE1hdGNoaW5nKHJvb3ROb2RlLCBtYXRjaGluZykge1xuICBjb25zdCBsZXZlbCA9IG1hdGNoaW5nLmxldmVsIHx8IDEsXG4gICAgc3R5bGUgPSBtYXRjaGluZy5saXN0SXRlbSB8fCBcIm5vcm1hbFwiLFxuICAgIGZpbHRlck9uVHlwZSA9IHR5cGVvZiBtYXRjaGluZy5saXN0SXRlbSA9PSBcInN0cmluZ1wiO1xuICBpZiAoaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChyb290Tm9kZSkgJiYgKHJvb3ROb2RlLmxldmVsIHx8IDEpID09PSBsZXZlbCAmJiBmaWx0ZXJPblR5cGUgJiYgKHJvb3ROb2RlLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIpID09PSBzdHlsZSkgcmV0dXJuIHJvb3ROb2RlO1xuICBpZiAoIShcImNoaWxkcmVuXCIgaW4gcm9vdE5vZGUpKSByZXR1cm47XG4gIGNvbnN0IG5vZGUgPSByb290Tm9kZS5jaGlsZHJlbltyb290Tm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5vZGUgJiYgIWlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSA/IGZpbmRMaXN0TWF0Y2hpbmcobm9kZSwgbWF0Y2hpbmcpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gc3BhblRvUGxhaW5UZXh0KHNwYW4pIHtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICByZXR1cm4gc3Bhbi5jaGlsZHJlbi5mb3JFYWNoKGN1cnJlbnQgPT4ge1xuICAgIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKGN1cnJlbnQpID8gdGV4dCArPSBjdXJyZW50LnRleHQgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKGN1cnJlbnQpICYmICh0ZXh0ICs9IHNwYW5Ub1BsYWluVGV4dChjdXJyZW50KSk7XG4gIH0pLCB0ZXh0O1xufVxuY29uc3QgbGVhZGluZ1NwYWNlID0gL15cXHMvLFxuICB0cmFpbGluZ1NwYWNlID0gL15cXHMvO1xuZnVuY3Rpb24gdG9QbGFpblRleHQoYmxvY2spIHtcbiAgY29uc3QgYmxvY2tzID0gQXJyYXkuaXNBcnJheShibG9jaykgPyBibG9jayA6IFtibG9ja107XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgcmV0dXJuIGJsb2Nrcy5mb3JFYWNoKChjdXJyZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNQb3J0YWJsZVRleHRCbG9jayhjdXJyZW50KSkgcmV0dXJuO1xuICAgIGxldCBwYWQgPSAhMTtcbiAgICBjdXJyZW50LmNoaWxkcmVuLmZvckVhY2goc3BhbiA9PiB7XG4gICAgICBpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgPyAodGV4dCArPSBwYWQgJiYgdGV4dCAmJiAhdHJhaWxpbmdTcGFjZS50ZXN0KHRleHQpICYmICFsZWFkaW5nU3BhY2UudGVzdChzcGFuLnRleHQpID8gXCIgXCIgOiBcIlwiLCB0ZXh0ICs9IHNwYW4udGV4dCwgcGFkID0gITEpIDogcGFkID0gITA7XG4gICAgfSksIGluZGV4ICE9PSBibG9ja3MubGVuZ3RoIC0gMSAmJiAodGV4dCArPSBgXG5cbmApO1xuICB9KSwgdGV4dDtcbn1cbmNvbnN0IExJU1RfTkVTVF9NT0RFX0hUTUwgPSBcImh0bWxcIixcbiAgTElTVF9ORVNUX01PREVfRElSRUNUID0gXCJkaXJlY3RcIjtcbmV4cG9ydCB7IExJU1RfTkVTVF9NT0RFX0RJUkVDVCwgTElTVF9ORVNUX01PREVfSFRNTCwgYnVpbGRNYXJrc1RyZWUsIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSwgbmVzdExpc3RzLCBzb3J0TWFya3NCeU9jY3VyZW5jZXMsIHNwYW5Ub1BsYWluVGV4dCwgdG9QbGFpblRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;