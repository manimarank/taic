"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   createReferenceTypeNode: () => (/* binding */ createReferenceTypeNode),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   typeEvaluate: () => (/* binding */ typeEvaluate)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n\nvar __defProp$6 = Object.defineProperty, __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\"))\n    part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n  return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n  constructor(pattern) {\n    __publicField$6(this, \"pattern\"), __publicField$6(this, \"patternRe\"), this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nvar __defProp$5 = Object.defineProperty, __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nclass StreamValue {\n  constructor(generator) {\n    __publicField$5(this, \"type\", \"stream\"), __publicField$5(this, \"generator\"), __publicField$5(this, \"ticker\"), __publicField$5(this, \"isDone\"), __publicField$5(this, \"data\"), this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return !0;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this)\n      result.push(await value.get());\n    return result;\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for (; ; ) {\n      for (; i < this.data.length; i++)\n        yield this.data[i];\n      if (this.isDone)\n        return;\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker)\n      return this.ticker;\n    let currentResolver;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve;\n      });\n    }, tick = () => {\n      currentResolver(), setupTicker();\n    }, fetch = async () => {\n      for await (const value of this.generator())\n        this.data.push(value), tick();\n      this.isDone = !0, tick();\n    };\n    return setupTicker(), fetch(), this.ticker;\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  for (; str.length < targetLength; )\n    str = `0${str}`;\n  return str;\n}\nvar __defProp$4 = Object.defineProperty, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nclass StaticValue {\n  constructor(data, type) {\n    __publicField$4(this, \"data\"), __publicField$4(this, \"type\"), this.data = data, this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data))\n      return function* (data) {\n        for (const element of data)\n          yield fromJS(element);\n      }(this.data);\n    throw new Error(`Cannot iterate over: ${this.type}`);\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n  constructor(date) {\n    __publicField$4(this, \"date\"), this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next == \"function\";\n}\nfunction fromJS(val) {\n  return isIterator(val) ? new StreamValue(async function* () {\n    for await (const value of val)\n      yield fromJS(value);\n  }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n  return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nfunction isEqual(a, b) {\n  return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nfunction matchText(tokens, patterns) {\n  return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text) {\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n  return matchPatternRegex(text).map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text) {\n  return (text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map(\n    (term) => new RegExp(`^${term.slice(0, 1024).replace(/\\*/g, \".*\")}$`, \"i\")\n  );\n}\nasync function gatherText(value, cb) {\n  if (value.type === \"string\")\n    return cb(value.data), !0;\n  if (value.isArray()) {\n    let success = !0;\n    for await (const part of value)\n      part.type === \"string\" ? cb(part.data) : success = !1;\n    return success;\n  }\n  return !1;\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a), bType = getType(b);\n  if (aType !== bType)\n    return null;\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      return a < b ? -1 : a > b ? 1 : 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder)\n    return aTypeOrder - bTypeOrder;\n  let result = partialCompare(a, b);\n  return result === null && (result = 0), result;\n}\nconst operators = {\n  \"==\": function(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: async function(left, right) {\n    if (right.type === \"path\")\n      return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    if (right.isArray()) {\n      for await (const b of right)\n        if (isEqual(left, b))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    }\n    return NULL_VALUE;\n  },\n  match: async function(left, right) {\n    let tokens = [], patterns = [];\n    return await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part));\n    }), await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part));\n    }) && matchText(tokens, patterns) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"+\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({ ...left.data, ...right.data }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function* () {\n      for await (const val of left)\n        yield val;\n      for await (const val of right)\n        yield val;\n    }) : NULL_VALUE;\n  },\n  \"-\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nvar __defProp$3 = Object.defineProperty, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nlet Scope$1 = class Scope {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    __publicField$3(this, \"params\"), __publicField$3(this, \"source\"), __publicField$3(this, \"value\"), __publicField$3(this, \"parent\"), __publicField$3(this, \"context\"), __publicField$3(this, \"isHidden\", !1), this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n};\nfunction evaluate(node, scope, execute = evaluate) {\n  const func = EXECUTORS[node.type];\n  return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n  return \"then\" in value ? value.then(cb) : cb(value);\n}\nconst EXECUTORS = {\n  This(_, scope) {\n    return scope.value;\n  },\n  Selector() {\n    throw new Error(\"Selectors can not be evaluated\");\n  },\n  Everything(_, scope) {\n    return scope.source;\n  },\n  Parameter({ name }, scope) {\n    return fromJS(scope.params[name]);\n  },\n  Context({ key }, scope) {\n    if (key === \"before\" || key === \"after\")\n      return scope.context[key] || NULL_VALUE;\n    throw new Error(`unknown context key: ${key}`);\n  },\n  Parent({ n }, scope) {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent)\n        return NULL_VALUE;\n      current = current.parent;\n    }\n    return current.value;\n  },\n  OpCall({ op, left, right }, scope, execute) {\n    const func = operators[op];\n    if (!func)\n      throw new Error(`Unknown operator: ${op}`);\n    const leftValue = execute(left, scope), rightValue = execute(right, scope);\n    return \"then\" in leftValue || \"then\" in rightValue ? (async () => func(await leftValue, await rightValue))() : func(leftValue, rightValue);\n  },\n  async Select({ alternatives, fallback }, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope);\n      if (altCond.type === \"boolean\" && altCond.data === !0)\n        return execute(alt.value, scope);\n    }\n    return fallback ? execute(fallback, scope) : NULL_VALUE;\n  },\n  async InRange({ base, left, right, isInclusive }, scope, execute) {\n    const value = await execute(base, scope), leftValue = await execute(left, scope), rightValue = await execute(right, scope), leftCmp = partialCompare(await value.get(), await leftValue.get());\n    if (leftCmp === null)\n      return NULL_VALUE;\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\n    return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  async Filter({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    return baseValue.isArray() ? new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem), exprValue = await execute(expr, newScope);\n        exprValue.type === \"boolean\" && exprValue.data === !0 && (yield elem);\n      }\n    }) : NULL_VALUE;\n  },\n  async Projection({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (baseValue.type !== \"object\")\n      return NULL_VALUE;\n    const newScope = scope.createNested(baseValue);\n    return execute(expr, newScope);\n  },\n  FuncCall({ func, args }, scope, execute) {\n    return func(args, scope, execute);\n  },\n  async PipeFuncCall({ func, base, args }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    return func(baseValue, args, scope, execute);\n  },\n  async AccessAttribute({ base, name }, scope, execute) {\n    let value = scope.value;\n    return base && (value = await execute(base, scope)), value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE;\n  },\n  async AccessElement({ base, index }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray())\n      return NULL_VALUE;\n    const data = await baseValue.get(), finalIndex = index < 0 ? index + data.length : index;\n    return fromJS(data[finalIndex]);\n  },\n  async Slice({ base, left, right, isInclusive }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray())\n      return NULL_VALUE;\n    const array2 = await baseValue.get();\n    let leftIdx = left, rightIdx = right;\n    return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromJS(array2.slice(leftIdx, rightIdx));\n  },\n  async Deref({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!scope.source.isArray() || value.type !== \"object\")\n      return NULL_VALUE;\n    const id = value.data._ref;\n    if (typeof id != \"string\")\n      return NULL_VALUE;\n    if (scope.context.dereference)\n      return fromJS(await scope.context.dereference({ _ref: id }));\n    for await (const doc of scope.source)\n      if (doc.type === \"object\" && id === doc.data._id)\n        return doc;\n    return NULL_VALUE;\n  },\n  Value({ value }) {\n    return fromJS(value);\n  },\n  Group({ base }, scope, execute) {\n    return execute(base, scope);\n  },\n  async Object({ attributes }, scope, execute) {\n    const result = {};\n    for (const attr of attributes) {\n      const attrType = attr.type;\n      switch (attr.type) {\n        case \"ObjectAttributeValue\": {\n          const value = await execute(attr.value, scope);\n          result[attr.name] = await value.get();\n          break;\n        }\n        case \"ObjectConditionalSplat\": {\n          const cond = await execute(attr.condition, scope);\n          if (cond.type !== \"boolean\" || cond.data === !1)\n            continue;\n          const value = await execute(attr.value, scope);\n          value.type === \"object\" && Object.assign(result, value.data);\n          break;\n        }\n        case \"ObjectSplat\": {\n          const value = await execute(attr.value, scope);\n          value.type === \"object\" && Object.assign(result, value.data);\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${attrType}`);\n      }\n    }\n    return fromJS(result);\n  },\n  Array({ elements }, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope);\n        if (element.isSplat) {\n          if (value.isArray())\n            for await (const v of value)\n              yield v;\n        } else\n          yield value;\n      }\n    });\n  },\n  Tuple() {\n    throw new Error(\"tuples can not be evaluated\");\n  },\n  async Or({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n    return leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE;\n  },\n  async And({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n    return leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE;\n  },\n  async Not({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE;\n  },\n  Neg({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data));\n  },\n  Pos({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data));\n  },\n  Asc() {\n    return NULL_VALUE;\n  },\n  Desc() {\n    return NULL_VALUE;\n  },\n  async ArrayCoerce({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? value : NULL_VALUE;\n  },\n  async Map({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        yield await execute(expr, newScope);\n      }\n    }) : NULL_VALUE;\n  },\n  async FlatMap({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem), innerValue = await execute(expr, newScope);\n        if (innerValue.isArray())\n          for await (const inner of innerValue)\n            yield inner;\n        else\n          yield innerValue;\n      }\n    }) : NULL_VALUE;\n  }\n};\nfunction evaluateQuery(tree, options = {}) {\n  const root = fromJS(options.root), dataset = fromJS(options.dataset), params = { ...options.params }, scope = new Scope$1(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n      identity: options.identity === void 0 ? \"me\" : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference\n    },\n    null\n  );\n  return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return !0;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return !1;\n      }\n    default:\n      return !1;\n  }\n}\nconst DUMMY_SCOPE = new Scope$1(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  { timestamp: /* @__PURE__ */ new Date(0), identity: \"me\", before: null, after: null },\n  null\n);\nfunction tryConstantEvaluate(node) {\n  return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n  if (\"then\" in value)\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\n  return value;\n}\nasync function portableTextContent(value) {\n  if (value.type === \"object\")\n    return blockText(value.data);\n  if (value.isArray()) {\n    const texts = await arrayText(value);\n    if (texts.length > 0)\n      return texts.join(`\n\n`);\n  }\n  return null;\n}\nasync function arrayText(value, result = []) {\n  for await (const block of value)\n    if (block.type === \"object\") {\n      const text = blockText(block.data);\n      text !== null && result.push(text);\n    } else block.isArray() && await arrayText(block, result);\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type != \"string\") return null;\n  const children = obj.children;\n  if (!Array.isArray(children)) return null;\n  let result = \"\";\n  for (const child of children)\n    child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n  return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScore(node.left, node.right, scope, execute);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScore(node.args[0], scope, execute), boost = await execute(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = await execute(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n  const text = await execute(left, scope), pattern = await execute(right, scope);\n  let tokens = [], terms = [];\n  if (await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part));\n  }), !await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part));\n  }) || tokens.length === 0 || terms.length === 0)\n    return 0;\n  let score = 0;\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n    score += freq * (BM25k + 1) / (freq + BM25k);\n  }\n  return score;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value)\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n    case \"object\":\n      if (value._ref)\n        return pathSet.has(value._ref);\n      for (const v of Object.values(value))\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n  }\n  return !1;\n}\nfunction countUTF8(str) {\n  let count2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    code >= 55296 && code <= 56319 || count2++;\n  }\n  return count2;\n}\nconst _global = {};\n_global.anywhere = async function() {\n  throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope);\n    if (value.type !== \"null\")\n      return value;\n  }\n  return NULL_VALUE;\n};\n_global.count = async function(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (!inner.isArray())\n    return NULL_VALUE;\n  let num = 0;\n  for await (const _ of inner)\n    num++;\n  return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function(args, scope, execute) {\n  const val = await execute(args[0], scope);\n  return val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function(args, scope, execute) {\n  return (await execute(args[0], scope)).type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function(_args, scope) {\n  return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type === \"string\")\n    return fromNumber(countUTF8(inner.data));\n  if (inner.isArray()) {\n    let num = 0;\n    for await (const _ of inner)\n      num++;\n    return fromNumber(num);\n  }\n  return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  return inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  switch (value.type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"datetime\":\n      return fromString(`${value.data}`);\n    default:\n      return NULL_VALUE;\n  }\n};\n_global.string.arity = 1;\n_global.references = async function(args, scope, execute) {\n  const pathSet = /* @__PURE__ */ new Set();\n  for (const arg of args) {\n    const path2 = await execute(arg, scope);\n    if (path2.type === \"string\")\n      pathSet.add(path2.data);\n    else if (path2.isArray())\n      for await (const elem of path2)\n        elem.type === \"string\" && pathSet.add(elem.data);\n  }\n  if (pathSet.size === 0)\n    return FALSE_VALUE;\n  const scopeValue = await scope.value.get();\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c) => c >= 1;\n_global.round = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"number\")\n    return NULL_VALUE;\n  const num = value.data;\n  let prec = 0;\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope);\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data))\n      return NULL_VALUE;\n    prec = precValue.data;\n  }\n  return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2) => count2 >= 1 && count2 <= 2;\n_global.now = async function(_args, scope) {\n  return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function() {\n  throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\")\n    return NULL_VALUE;\n  const sep = await execute(args[1], scope);\n  return sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromJS([]) : sep.data.length === 0 ? fromJS(Array.from(str.data)) : fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\")\n    return NULL_VALUE;\n  const prefix = await execute(args[1], scope);\n  return prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\")\n    return NULL_VALUE;\n  let buf = \"\", needSep = !1;\n  for await (const elem of arr) {\n    switch (needSep && (buf += sep.data), elem.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        buf += `${elem.data}`;\n        break;\n      default:\n        return NULL_VALUE;\n    }\n    needSep = !0;\n  }\n  return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  return arr.isArray() ? new StreamValue(async function* () {\n    for await (const elem of arr)\n      elem.type !== \"null\" && (yield elem);\n  }) : NULL_VALUE;\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  return value.isArray() ? new StreamValue(async function* () {\n    const added = /* @__PURE__ */ new Set();\n    for await (const iter of value)\n      switch (iter.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          added.has(iter.data) || (added.add(iter.data), yield iter);\n          break;\n        default:\n          yield iter;\n      }\n  }) : NULL_VALUE;\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n  const value = await execute(args[0], scope), text = await portableTextContent(value);\n  return text === null ? NULL_VALUE : fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(_args, scope) {\n  return scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE;\n};\nsanity.dataset = async function(_args, scope) {\n  return scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE;\n};\nsanity.versionOf = async function(args, scope, execute) {\n  if (!scope.source.isArray()) return NULL_VALUE;\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") return NULL_VALUE;\n  const baseId = value.data, versionIds = [];\n  for await (const value2 of scope.source)\n    if (getType(value2) === \"object\") {\n      const val = await value2.get();\n      val && \"_id\" in val && val._id.split(\".\").length === 2 && val._id.endsWith(`.${baseId}`) && \"_version\" in val && typeof val._version == \"object\" && versionIds.push(val._id);\n    }\n  return fromJS(versionIds);\n};\nsanity.versionOf.arity = 1;\nsanity.documentsOf = async function(args, scope, execute) {\n  if (!scope.source.isArray()) return NULL_VALUE;\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") return NULL_VALUE;\n  const baseId = value.data, documentIdsInBundle = [];\n  for await (const value2 of scope.source)\n    if (getType(value2) === \"object\") {\n      const val = await value2.get();\n      val && \"_id\" in val && val._id.split(\".\").length === 2 && val._id.startsWith(`${baseId}.`) && \"_version\" in val && typeof val._version == \"object\" && documentIdsInBundle.push(val._id);\n    }\n  return fromJS(documentIdsInBundle);\n};\nsanity.documentsOf.arity = 1;\nconst pipeFunctions = {};\npipeFunctions.order = async function(base, args, scope, execute) {\n  if (await !0, !base.isArray())\n    return NULL_VALUE;\n  const mappers = [], directions = [];\n  let n = 0;\n  for (let mapper of args) {\n    let direction = \"asc\";\n    mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction), n++;\n  }\n  const aux = [];\n  let idx = 0;\n  for await (const value of base) {\n    const newScope = scope.createNested(value), tuple = [await value.get(), idx];\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope);\n      tuple.push(await result.get());\n    }\n    aux.push(tuple), idx++;\n  }\n  return aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\" && (c = -c), c !== 0)\n        return c;\n    }\n    return aTuple[1] - bTuple[1];\n  }), fromJS(aux.map((v) => v[0]));\n};\npipeFunctions.order.arity = (count2) => count2 >= 1;\npipeFunctions.score = async function(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE;\n  const unknown = [], scored = [];\n  for await (const value of base) {\n    if (value.type !== \"object\") {\n      unknown.push(await value.get());\n      continue;\n    }\n    const newScope = scope.createNested(value);\n    let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n    for (const arg of args)\n      valueScore += await evaluateScore(arg, newScope, execute);\n    const newObject = Object.assign({}, value.data, { _score: valueScore });\n    scored.push(newObject);\n  }\n  return scored.sort((a, b) => b._score - a._score), fromJS(scored);\n};\npipeFunctions.score.arity = (count2) => count2 >= 1;\nconst delta = {};\ndelta.operation = async function(_args, scope) {\n  const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n  return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n};\ndelta.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      (n === void 0 || elem.data < n) && (n = elem.data);\n    }\n  return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      (n === void 0 || elem.data > n) && (n = elem.data);\n    }\n  return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n = 0;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      n += elem.data;\n    }\n  return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n = 0, c = 0;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      n += elem.data, c++;\n    }\n  return c === 0 ? NULL_VALUE : fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function(_args, scope) {\n  return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n  global: _global,\n  string: string2,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime: dateTime2\n};\nvar __defProp$2 = Object.defineProperty, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nclass MarkProcessor {\n  constructor(string, marks, parseOptions) {\n    __publicField$2(this, \"string\"), __publicField$2(this, \"marks\"), __publicField$2(this, \"index\"), __publicField$2(this, \"parseOptions\"), __publicField$2(this, \"allowBoost\", !1), this.string = string, this.marks = marks, this.index = 0, this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func)\n      throw new Error(`Unknown handler: ${mark.name}`);\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    return this.shift(), this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n    return this.shift(), this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), { type: \"error\", position: pos }) : (delete result.position, delete result.failPosition, result));\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos, token = str[pos], marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === \"error\") return rhs;\n      switch (pos = skipWS(str, rhs.position), str[pos]) {\n        case \",\": {\n          for (marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks), pos = skipWS(str, pos + 1); ; ) {\n            if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\") return rhs;\n            if (pos = skipWS(str, rhs.position), str[pos] !== \",\") break;\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== \")\") return { type: \"error\", position: pos };\n          pos++, marks.push({ name: \"tuple_end\", position: pos });\n          break;\n        }\n        case \")\": {\n          pos++, marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n          break;\n        }\n        default:\n          return { type: \"error\", position: pos };\n      }\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"[\":\n      if (marks = [{ name: \"array\", position: pos }], pos = skipWS(str, pos + 1), str[pos] !== \"]\")\n        for (; ; ) {\n          str.slice(pos, pos + 3) === \"...\" && (marks.push({ name: \"array_splat\", position: pos }), pos = skipWS(str, pos + 3));\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\") return res;\n          if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\")) break;\n        }\n      if (str[pos] === \"]\")\n        pos++, marks.push({ name: \"array_end\", position: pos });\n      else\n        return { type: \"error\", position: pos };\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"^\": {\n      for (pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\"; )\n        marks.push({ name: \"dblparent\", position: startPos }), pos += 2;\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }], pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }], pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      identLen && (pos += 1 + identLen, marks = [\n        { name: \"param\", position: startPos },\n        { name: \"ident\", position: startPos + 1 },\n        { name: \"ident_end\", position: pos }\n      ]);\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          fracLen && (name = \"float\", pos += 1 + fracLen);\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return { type: \"error\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        switch (pos += identLen, str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\") return result;\n            marks = result.marks, pos = result.position;\n            break;\n          }\n          default:\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n        }\n        break;\n      }\n    }\n  }\n  if (!marks)\n    return { type: \"error\", position: pos };\n  let lhsLevel = 12, trav;\n  loop: for (; ; ) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break;\n    }\n    if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n      for (marks.unshift({ name: \"traverse\", position: startPos }); trav.type === \"success\"; )\n        marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n      marks.push({ name: \"traversal_end\", position: pos });\n      continue;\n    }\n    switch (str[innerPos]) {\n      case \"=\": {\n        switch (str[innerPos + 1]) {\n          case \">\": {\n            if (level > 1 || lhsLevel <= 1) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n            if (rhs.type === \"error\") return rhs;\n            marks = marks.concat(rhs.marks), marks.unshift({ name: \"pair\", position: startPos }), pos = rhs.position, lhsLevel = 1;\n            break;\n          }\n          case \"=\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n        break;\n      }\n      case \"+\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"add\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"-\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"sub\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"*\": {\n        if (str[innerPos + 1] === \"*\") {\n          if (level > 8 || lhsLevel <= 8) break loop;\n          let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n          if (rhs2.type === \"error\") return rhs2;\n          marks = marks.concat(rhs2.marks), marks.unshift({ name: \"pow\", position: startPos }), pos = rhs2.position, lhsLevel = 8;\n          break;\n        }\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mul\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"/\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"div\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"%\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mod\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"<\":\n      case \">\": {\n        if (level > 4 || lhsLevel <= 4) break loop;\n        let nextPos = innerPos + 1;\n        str[nextPos] === \"=\" && nextPos++;\n        let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"|\": {\n        if (str[innerPos + 1] === \"|\") {\n          if (level > 2 || lhsLevel < 2) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"or\", position: startPos }), pos = rhs.position, lhsLevel = 2;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop;\n          let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return { type: \"error\", position: identPos };\n          if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === \"error\") return result;\n            marks = marks.concat(result.marks), marks.unshift({ name: \"pipecall\", position: startPos }), pos = result.position, lhsLevel = 11;\n          }\n        }\n        break;\n      }\n      case \"&\": {\n        if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"and\", position: startPos }), pos = rhs.position, lhsLevel = 3;\n        break;\n      }\n      case \"!\": {\n        if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"d\": {\n        if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"desc\", position: startPos }), pos = innerPos + 4, lhsLevel = 4;\n        break;\n      }\n      case \"a\": {\n        if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"asc\", position: startPos }), pos = innerPos + 3, lhsLevel = 4;\n        break;\n      }\n      default:\n        switch (parseRegexStr(str, innerPos, IDENT)) {\n          case \"in\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            pos = skipWS(str, innerPos + 2);\n            let isGroup = !1;\n            str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n            let rangePos = pos, result = parseExpr(str, pos, 5);\n            if (result.type === \"error\") return result;\n            if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n              let type = \"inc_range\";\n              str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n              let rhs = parseExpr(str, pos, 5);\n              if (rhs.type === \"error\") return rhs;\n              marks.unshift({ name: \"in_range\", position: startPos }), marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks), pos = rhs.position;\n            } else\n              marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(result.marks);\n            if (isGroup) {\n              if (pos = skipWS(str, pos), str[pos] !== \")\") return { type: \"error\", position: pos };\n              pos++;\n            }\n            lhsLevel = 4;\n            break;\n          }\n          case \"match\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n    }\n  }\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n      return identLen2 ? (pos += identLen2, {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      }) : { type: \"error\", position: pos };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\") return { type: \"error\", position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n      return identLen && (pos = identPos + identLen, marks.push(\n        { name: \"deref_attr\", position: identPos },\n        { name: \"ident\", position: identPos },\n        { name: \"ident_end\", position: pos }\n      )), {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"]\")\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      let rangePos = pos, result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? { type: \"error\", position: pos } : {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        });\n      }\n      return str[pos] !== \"]\" ? { type: \"error\", position: pos } : {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n    }\n  }\n  return { type: \"error\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  if (marks.push({ name: \"func_call\", position: startPos }), str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos }), marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return { type: \"error\", position: pos };\n    if (marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\") return { type: \"error\", position: pos };\n    pos++, pos = skipWS(str, pos);\n  } else\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 1);\n  let lastPos = pos;\n  if (str[pos] !== \")\")\n    for (; ; ) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\")) break;\n    }\n  return str[pos] !== \")\" ? { type: \"error\", position: pos } : (marks.push({ name: \"func_args_end\", position: lastPos }), {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  });\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  for (pos = skipWS(str, pos + 1); str[pos] !== \"}\"; ) {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\")\n      if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\") return expr;\n        marks.push({ name: \"object_splat\", position: pairPos }), marks = marks.concat(expr.marks), pos = expr.position;\n      } else\n        marks.push({ name: \"object_splat_this\", position: pairPos });\n    else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\") return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\") return value;\n        marks.push({ name: \"object_pair\", position: pairPos }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n      } else\n        marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks), pos = expr.position;\n    }\n    if (pos = skipWS(str, pos), str[pos] !== \",\") break;\n    pos = skipWS(str, pos + 1);\n  }\n  return str[pos] !== \"}\" ? { type: \"error\", position: pos } : (pos++, marks.push({ name: \"object_end\", position: pos }), { type: \"success\", marks, position: pos });\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str: for (; ; pos++) {\n    if (pos > str.length) return { type: \"error\", position: pos };\n    switch (str[pos]) {\n      case token: {\n        marks.push({ name: \"str_end\", position: pos }), pos++;\n        break str;\n      }\n      case \"\\\\\":\n        marks.push({ name: \"str_pause\", position: pos }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({ name: \"unicode_hex\", position: pos + 3 }), pos = str.indexOf(\"}\", pos + 3), marks.push({ name: \"unicode_hex_end\", position: pos })) : (marks.push({ name: \"unicode_hex\", position: pos + 2 }), marks.push({ name: \"unicode_hex_end\", position: pos + 6 }), pos += 5) : (marks.push({ name: \"single_escape\", position: pos + 1 }), pos += 1), marks.push({ name: \"str_start\", position: pos + 1 });\n    }\n  }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right)\n    return {\n      type: \"a-a\",\n      build\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right)\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nvar __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: `\n`,\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  constructor() {\n    super(...arguments), __publicField$1(this, \"name\", \"GroqQueryError\");\n  }\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    return {\n      type: \"Group\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  everything() {\n    return { type: \"Everything\" };\n  },\n  this() {\n    return { type: \"This\" };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    return {\n      type: \"Parent\",\n      n: p.process(EXPR_BUILDER).n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER), traversalList = [];\n    for (; p.getMark().name !== \"traversal_end\"; )\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--)\n      traversal = traversalList[i](traversal);\n    if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val) => val, traversal)), traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    return name === \"null\" ? { type: \"Value\", value: null } : name === \"true\" ? { type: \"Value\", value: !0 } : name === \"false\" ? { type: \"Value\", value: !1 } : {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    return {\n      type: \"Neg\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  pos(p) {\n    return {\n      type: \"Pos\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER), op = p.processString(), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER), isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop: for (; p.hasMark(); ) {\n      const mark = p.getMark();\n      switch (mark.name) {\n        case \"str_end\":\n          value += p.processStringEnd();\n          break loop;\n        case \"str_pause\":\n          value += p.processStringEnd();\n          break;\n        case \"str_start\":\n          p.shift();\n          break;\n        case \"single_escape\": {\n          const char = p.slice(1);\n          p.shift(), value += ESCAPE_SEQUENCE[char];\n          break;\n        }\n        case \"unicode_hex\":\n          p.shift(), value += expandHex(p.processStringEnd());\n          break;\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`);\n      }\n    }\n    return { type: \"Value\", value };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    for (; p.getMark().name !== \"object_end\"; )\n      attributes.push(p.process(OBJECT_BUILDER));\n    return p.shift(), {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    for (; p.getMark().name !== \"array_end\"; ) {\n      let isSplat = !1;\n      p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    return p.shift(), {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    for (; p.getMark().name !== \"tuple_end\"; )\n      members.push(p.process(EXPR_BUILDER));\n    return p.shift(), {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      for (; p.getMark().name !== \"func_args_end\"; )\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          p.shift();\n          const condition = p.process(EXPR_BUILDER), value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      return p.shift(), result;\n    }\n    const args = [];\n    for (; p.getMark().name !== \"func_args_end\"; )\n      argumentShouldBeSelector(namespace, name, args.length) ? (p.process(SELECTOR_BUILDER), args.push({ type: \"Selector\" })) : args.push(p.process(EXPR_BUILDER));\n    if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\")\n      return {\n        type: \"Context\",\n        key: name\n      };\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n      throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs)\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const func = funcs[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    return {\n      type: \"FuncCall\",\n      func,\n      namespace,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\")\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n    for (name === \"score\" && (p.allowBoost = !0); ; ) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\")\n        break;\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift(), args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift(), args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift(), p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined pipe function: ${name}`);\n    return func.arity && validateArity(name, func.arity, args.length), {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair() {\n    throw new GroqQueryError(\"unexpected =>\");\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    return {\n      type: \"Not\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  asc() {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc() {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n      type: \"Value\",\n      value: p.parseOptions.params[name]\n    } : {\n      type: \"Parameter\",\n      name\n    };\n  }\n}, OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER), value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\") throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    return {\n      type: \"ObjectSplat\",\n      value: p.process(EXPR_BUILDER)\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: { type: \"This\" }\n    };\n  }\n}, TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n    return value && value.type === \"number\" ? (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right) : value && value.type === \"string\" ? (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right) : (right) => traverseArray(\n      (base) => ({\n        type: \"Filter\",\n        base,\n        expr\n      }),\n      right\n    );\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\")\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    return (rhs) => traverseArray(\n      (base) => ({\n        type: \"Slice\",\n        base,\n        left: leftValue.data,\n        right: rightValue.data,\n        isInclusive\n      }),\n      rhs\n    );\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n  },\n  deref(p) {\n    let attr = null;\n    p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n    return (right) => traversePlain(\n      (base) => wrap({\n        type: \"Deref\",\n        base\n      }),\n      right\n    );\n  },\n  array_postfix() {\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n  }\n}, SELECTOR_BUILDER = {\n  group(p) {\n    return p.process(SELECTOR_BUILDER), null;\n  },\n  everything() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  this() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  parent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  dblparent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  traverse(p) {\n    for (p.process(SELECTOR_BUILDER); p.getMark().name !== \"traversal_end\"; )\n      p.process(TRAVERSE_BUILDER);\n    return p.shift(), null;\n  },\n  this_attr(p) {\n    return p.processString(), null;\n  },\n  neg() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pos() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  add() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sub() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mul() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  div() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mod() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pow() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  comp() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  in_range() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  str() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  integer() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  float() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sci() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  object() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  array() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  tuple() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark);\n    if (func.name === \"anywhere\" && func.args.length === 1) return null;\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pipecall() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pair() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  and() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  or() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  not() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  asc() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  desc() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  param() {\n    throw new Error(\"Invalid selector syntax\");\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base)\n    return node.name;\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\")\n    return extractPropertyKey(node.base);\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity == \"number\") {\n    if (count !== arity)\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      );\n  } else if (arity && !arity(count))\n    throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  constructor(position) {\n    super(`Syntax error in GROQ query at position ${position}`), __publicField$1(this, \"position\"), __publicField$1(this, \"name\", \"GroqSyntaxError\"), this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\")\n    throw new GroqSyntaxError(result.position);\n  return new MarkProcessor(input, result.marks, options).process(EXPR_BUILDER);\n}\nconst { compare } = new Intl.Collator(\"en\");\nfunction typeNodesSorter(a, b) {\n  return a.type === \"null\" ? 1 : compare(hashField(a), hashField(b));\n}\nfunction hashField(field) {\n  switch (field.type) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return field.value !== void 0 ? `${field.type}(${field.value})` : `${field.type}`;\n    case \"null\":\n    case \"unknown\":\n      return field.type;\n    case \"array\":\n      return `${field.type}(${hashField(field.of)})`;\n    case \"object\": {\n      const attributes = Object.entries(field.attributes);\n      return attributes.sort(([a], [b]) => compare(a, b)), `${field.type}:(${attributes.map(\n        ([key, value]) => `${key}:${hashField(value.value)}(${value.optional ? \"optional\" : \"non-optional\"})`\n      ).join(\",\")}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : \"no-rest\"}`;\n    }\n    case \"union\": {\n      const sorted = [...field.of];\n      return sorted.sort(typeNodesSorter), `${field.type}(${sorted.map(hashField).join(\",\")})`;\n    }\n    case \"inline\":\n      return `${field.type}(${field.name})`;\n    default:\n      return field.type;\n  }\n}\nfunction removeDuplicateTypeNodes(typeNodes) {\n  const seenTypes = /* @__PURE__ */ new Set(), newTypeNodes = [], sortedTypeNodes = [...typeNodes];\n  sortedTypeNodes.sort(typeNodesSorter);\n  for (const typeNode of sortedTypeNodes) {\n    const hash = hashField(typeNode);\n    if (hash === null) {\n      newTypeNodes.push(typeNode);\n      continue;\n    }\n    seenTypes.has(hash) || (seenTypes.add(hash), newTypeNodes.push(typeNode));\n  }\n  return newTypeNodes;\n}\nfunction optimizeUnions(field) {\n  if (field.type === \"union\") {\n    if (field.of.length === 0)\n      return field;\n    if (field.of = removeDuplicateTypeNodes(field.of), field.of.length === 1)\n      return optimizeUnions(field.of[0]);\n    for (let idx = 0; field.of.length > idx; idx++) {\n      const subField = field.of[idx];\n      if (subField.type === \"union\") {\n        field.of.splice(idx, 1, ...subField.of), idx--;\n        continue;\n      }\n      field.of[idx] = optimizeUnions(subField);\n    }\n    return field.of.sort((a, b) => a.type === \"null\" ? 1 : compare(hashField(a), hashField(b))), field;\n  }\n  if (field.type === \"array\")\n    return field.of = optimizeUnions(field.of), field;\n  if (field.type === \"object\") {\n    for (const idx in field.attributes)\n      Object.hasOwn(field.attributes, idx) && (field.attributes[idx].value = optimizeUnions(field.attributes[idx].value));\n    return field;\n  }\n  return field;\n}\nfunction createReferenceTypeNode(name, inArray = !1) {\n  const attributes = {\n    _ref: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\"\n      }\n    },\n    _type: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\",\n        value: \"reference\"\n      }\n    },\n    _weak: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"boolean\"\n      },\n      optional: !0\n    }\n  };\n  return inArray && (attributes._key = {\n    type: \"objectAttribute\",\n    value: {\n      type: \"string\"\n    }\n  }), {\n    type: \"object\",\n    attributes,\n    dereferencesTo: name\n  };\n}\nfunction nullUnion(node) {\n  return node.type === \"union\" ? unionOf(...node.of, { type: \"null\" }) : unionOf(node, { type: \"null\" });\n}\nfunction unionOf(...nodes) {\n  return {\n    type: \"union\",\n    of: nodes\n  };\n}\nfunction resolveInline(node, scope) {\n  if (node.type === \"inline\") {\n    const resolvedInline = scope.context.lookupTypeDeclaration(node);\n    return resolveInline(resolvedInline, scope);\n  }\n  return node;\n}\nfunction mapNode(node, scope, mapper, mergeUnions = (nodes) => optimizeUnions({ type: \"union\", of: nodes })) {\n  switch (node.type) {\n    case \"boolean\":\n    case \"array\":\n    case \"null\":\n    case \"object\":\n    case \"string\":\n    case \"number\":\n    case \"unknown\":\n      return mapper(node);\n    case \"union\":\n      return mergeUnions(node.of.map((inner) => mapNode(inner, scope, mapper), mergeUnions));\n    case \"inline\": {\n      const resolvedInline = resolveInline(node, scope);\n      return mapNode(resolvedInline, scope, mapper, mergeUnions);\n    }\n    default:\n      throw new Error(`Unknown type: ${node.type}`);\n  }\n}\nfunction isFuncCall(node, name) {\n  return node.type === \"Group\" ? isFuncCall(node.base, name) : node.type === \"FuncCall\" && `${node.namespace}::${node.name}` === name;\n}\nfunction booleanValue(node, scope) {\n  switch (node.type) {\n    case \"unknown\":\n      return { canBeTrue: !0, canBeFalse: !0, canBeNull: !0 };\n    case \"boolean\":\n      return node.value === !0 ? { canBeTrue: !0, canBeFalse: !1, canBeNull: !1 } : node.value === !1 ? { canBeTrue: !1, canBeFalse: !0, canBeNull: !1 } : { canBeTrue: !0, canBeFalse: !0, canBeNull: !1 };\n    case \"union\": {\n      const value = { canBeTrue: !1, canBeFalse: !1, canBeNull: !1 };\n      for (const sub of node.of) {\n        const match2 = booleanValue(sub, scope);\n        match2.canBeNull && (value.canBeNull = !0), match2.canBeTrue && (value.canBeTrue = !0), match2.canBeFalse && (value.canBeFalse = !0);\n      }\n      return value;\n    }\n    case \"inline\": {\n      const resolved = resolveInline(node, scope);\n      return booleanValue(resolved, scope);\n    }\n    case \"null\":\n    case \"string\":\n    case \"number\":\n    case \"object\":\n    case \"array\":\n      return { canBeTrue: !1, canBeFalse: !1, canBeNull: !0 };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction booleanOr(left, right) {\n  return left.canBeTrue && !left.canBeFalse && !left.canBeNull ? left : right.canBeTrue && !right.canBeFalse && !right.canBeNull ? right : {\n    // Either side can be true for the expression to be true\n    canBeTrue: left.canBeTrue || right.canBeTrue,\n    // Both sides must be false for the expression to be false\n    canBeFalse: left.canBeFalse && right.canBeFalse,\n    // if either side can be null, the expression can be null if the other side can't only be true\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanAnd(left, right) {\n  return left.canBeFalse && !left.canBeTrue && !left.canBeNull ? left : right.canBeFalse && !right.canBeTrue && !right.canBeNull ? right : {\n    // Both sides must be true for the expression to be true\n    canBeTrue: left.canBeTrue && right.canBeTrue,\n    // if either side can be false, the expression can be false\n    canBeFalse: left.canBeFalse || right.canBeFalse,\n    // if either side can be null, the expression can be null\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanInterpretationToTypeNode(bool) {\n  return bool.canBeTrue ? bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\" }) : { type: \"boolean\" } : bool.canBeNull ? nullUnion({ type: \"boolean\", value: !0 }) : { type: \"boolean\", value: !0 } : bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\", value: !1 }) : { type: \"boolean\", value: !1 } : { type: \"null\" };\n}\nvar __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nconst $trace$1 = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:scope:trace\");\n$trace$1.log = console.log.bind(console);\nclass Context {\n  constructor(schema) {\n    __publicField(this, \"schema\"), this.schema = schema;\n  }\n  lookupRef(refTo) {\n    for (const val of this.schema)\n      if (val.type === \"document\" && val.name === refTo)\n        return {\n          type: \"object\",\n          attributes: val.attributes\n        };\n    return { type: \"null\" };\n  }\n  lookupTypeDeclaration(alias) {\n    for (const val of this.schema)\n      if (val.type === \"type\" && val.name === alias.name)\n        return val.value;\n    return { type: \"null\" };\n  }\n}\nclass Scope2 {\n  constructor(value, parent, context) {\n    __publicField(this, \"value\"), __publicField(this, \"parent\"), __publicField(this, \"context\"), __publicField(this, \"isHidden\"), this.value = { type: \"union\", of: value }, this.parent = parent, this.context = context || (parent == null ? void 0 : parent.context) || new Context([]), this.isHidden = !1;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope2(value, this.parent, this.context) : new Scope2(value, this, this.context);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n}\nfunction unionWithoutNull(unionTypeNode) {\n  return unionTypeNode.type === \"union\" ? {\n    type: \"union\",\n    of: unionTypeNode.of.filter((type) => type.type !== \"null\")\n  } : unionTypeNode;\n}\nfunction handleFuncCallNode(node, scope) {\n  switch (`${node.namespace}.${node.name}`) {\n    case \"array.compact\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => {\n        if (arg2.type === \"unknown\")\n          return nullUnion({ type: \"array\", of: { type: \"unknown\" } });\n        if (arg2.type !== \"array\")\n          return { type: \"null\" };\n        const of = mapNode(arg2.of, scope, (of2) => of2);\n        return {\n          type: \"array\",\n          of: unionWithoutNull(of)\n        };\n      });\n    }\n    case \"array.join\": {\n      const arrayArg = walk({ node: node.args[0], scope }), sepArg = walk({ node: node.args[1], scope });\n      return mapNode(\n        arrayArg,\n        scope,\n        (arrayArg2) => mapNode(sepArg, scope, (sepArg2) => arrayArg2.type === \"unknown\" || sepArg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arrayArg2.type !== \"array\" || sepArg2.type !== \"string\" ? { type: \"null\" } : mapNode(arrayArg2.of, scope, (of) => of.type === \"unknown\" ? nullUnion({ type: \"string\" }) : of.type !== \"string\" && of.type !== \"number\" && of.type !== \"boolean\" ? { type: \"null\" } : { type: \"string\" }))\n      );\n    }\n    case \"array.unique\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"unknown\" } }) : arg2.type !== \"array\" ? { type: \"null\" } : arg2);\n    }\n    case \"global.lower\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toLowerCase()\n      } : { type: \"string\" });\n    }\n    case \"global.upper\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toUpperCase()\n      } : { type: \"string\" });\n    }\n    case \"dateTime.now\":\n      return { type: \"string\" };\n    case \"global.now\":\n      return { type: \"string\" };\n    case \"global.defined\":\n      return { type: \"boolean\" };\n    case \"global.path\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"string\" ? { type: \"string\" } : { type: \"null\" });\n    }\n    case \"global.coalesce\": {\n      if (node.args.length === 0)\n        return { type: \"null\" };\n      const typeNodes = [];\n      let canBeNull = !0;\n      for (const arg of node.args) {\n        const type = walk({ node: arg, scope });\n        typeNodes.push(unionWithoutNull(type)), canBeNull = type.type === \"null\" || type.type === \"union\" && type.of.some((t) => t.type === \"null\");\n      }\n      return canBeNull && typeNodes.push({ type: \"null\" }), {\n        type: \"union\",\n        of: typeNodes\n      };\n    }\n    case \"global.count\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"array\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.dateTime\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"string\" ? nullUnion({ type: \"string\" }) : { type: \"null\" });\n    }\n    case \"global.length\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : arg2.type === \"array\" || arg2.type === \"string\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.references\":\n      return { type: \"boolean\" };\n    case \"global.round\": {\n      const numNode = walk({ node: node.args[0], scope });\n      return mapNode(numNode, scope, (num) => {\n        if (num.type === \"unknown\")\n          return nullUnion({ type: \"number\" });\n        if (num.type !== \"number\")\n          return { type: \"null\" };\n        if (node.args.length === 2) {\n          const precisionNode = walk({ node: node.args[1], scope });\n          return mapNode(precisionNode, scope, (precision) => precision.type === \"unknown\" ? nullUnion({ type: \"number\" }) : precision.type !== \"number\" ? { type: \"null\" } : { type: \"number\" });\n        }\n        return { type: \"number\" };\n      });\n    }\n    case \"global.string\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : node2.type === \"string\" || node2.type === \"number\" || node2.type === \"boolean\" ? node2.value ? {\n        type: \"string\",\n        value: node2.value.toString()\n      } : {\n        type: \"string\"\n      } : { type: \"null\" });\n    }\n    case \"math.sum\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" || node3.type === \"null\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.avg\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.max\":\n    case \"math.min\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? node3 : { type: \"null\" }));\n    }\n    case \"pt.text\":\n      return node.args.length === 0 ? { type: \"null\" } : {\n        type: \"string\"\n      };\n    case \"string.startsWith\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), prefixTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(prefixTypeNode, scope, (prefixNode) => strNode.type === \"unknown\" || prefixNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : strNode.type !== \"string\" || prefixNode.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" }));\n    }\n    case \"string.split\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), sepTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(sepTypeNode, scope, (sepNode) => strNode.type === \"unknown\" || sepNode.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"string\" } }) : strNode.type !== \"string\" || sepNode.type !== \"string\" ? { type: \"null\" } : { type: \"array\", of: { type: \"string\" } }));\n    }\n    case \"sanity.versionOf\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"string\" } }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"array\", of: { type: \"string\" } });\n    }\n    case \"sanity.documentsOf\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"string\" } }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"array\", of: { type: \"string\" } });\n    }\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction match(left, right) {\n  let tokens = [], patterns = [];\n  if (left.type === \"string\") {\n    if (left.value === void 0)\n      return;\n    tokens = tokens.concat(matchTokenize(left.value));\n  }\n  if (left.type === \"array\") {\n    if (left.of.type === \"unknown\")\n      return;\n    if (left.of.type === \"string\") {\n      if (left.of.value === void 0)\n        return;\n      tokens = tokens.concat(matchTokenize(left.of.value));\n    }\n    if (left.of.type === \"union\")\n      for (const node of left.of.of)\n        node.type === \"string\" && node.value !== void 0 && (tokens = tokens.concat(matchTokenize(node.value)));\n  }\n  if (right.type === \"string\") {\n    if (right.value === void 0)\n      return;\n    patterns = patterns.concat(matchAnalyzePattern(right.value));\n  }\n  if (right.type === \"array\") {\n    if (right.of.type === \"unknown\")\n      return;\n    if (right.of.type === \"string\") {\n      if (right.of.value === void 0)\n        return;\n      patterns = patterns.concat(matchAnalyzePattern(right.of.value));\n    }\n    if (right.of.type === \"union\")\n      for (const node of right.of.of) {\n        if (node.type === \"string\") {\n          if (node.value === void 0)\n            return;\n          patterns = patterns.concat(matchAnalyzePattern(node.value));\n        }\n        if (node.type !== \"string\")\n          return !1;\n      }\n  }\n  return matchText(tokens, patterns);\n}\nconst $trace = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:trace\");\n$trace.log = console.log.bind(console);\nconst $debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:debug\");\n$debug.log = console.log.bind(console);\nconst $warn = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:warn\");\nfunction typeEvaluate(ast, schema) {\n  $debug(\"evaluateQueryType.ast %O\", ast), $debug(\"evaluateQueryType.schema %O\", schema);\n  const parsed = walk({\n    node: ast,\n    scope: new Scope2([], void 0, new Context(schema))\n  });\n  $trace(\"evaluateQueryType.parsed %O\", parsed);\n  const optimized = optimizeUnions(parsed);\n  return $debug(\"evaluateQueryType.optimized %O\", optimized), optimized;\n}\nfunction mapDeref(base, scope) {\n  return base.type === \"union\" ? {\n    type: \"union\",\n    of: base.of.map((node) => mapDeref(node, scope))\n  } : base.type === \"array\" ? {\n    type: \"array\",\n    of: mapDeref(base.of, scope)\n  } : base.type === \"object\" && base.dereferencesTo !== void 0 ? scope.context.lookupRef(base.dereferencesTo) : { type: \"null\" };\n}\nfunction handleDerefNode(node, scope) {\n  $trace(\"deref.node %O\", node);\n  const base = walk({ node: node.base, scope });\n  if ($trace(\"deref.base %O\", base), base.type === \"null\" || base.type === \"unknown\")\n    return { type: \"null\" };\n  const derefedNode = mapDeref(base, scope);\n  return $trace(\"deref.derefedNode %O\", derefedNode), derefedNode;\n}\nfunction handleObjectSplatNode(attr, scope) {\n  const value = walk({ node: attr.value, scope });\n  return $trace(\"object.splat.value %O\", value), mapNode(value, scope, (node) => {\n    if (node.type === \"unknown\")\n      return { type: \"unknown\" };\n    if (node.type !== \"object\")\n      return { type: \"object\", attributes: {} };\n    const attributes = {};\n    for (const name in node.attributes)\n      node.attributes.hasOwnProperty(name) && (attributes[name] = node.attributes[name]);\n    if (node.rest !== void 0) {\n      const resolvedRest = resolveInline(node.rest, scope);\n      if (resolvedRest.type === \"unknown\")\n        return { type: \"unknown\" };\n      if (resolvedRest.type !== \"object\")\n        return { type: \"null\" };\n      for (const name in resolvedRest.attributes)\n        resolvedRest.attributes.hasOwnProperty(name) && (attributes[name] = resolvedRest.attributes[name]);\n    }\n    return { type: \"object\", attributes };\n  });\n}\nfunction handleObjectNode(node, scope) {\n  if ($trace(\"object.node %O\", node), node.attributes.length === 0)\n    return {\n      type: \"object\",\n      attributes: {}\n    };\n  const objectAttributes = [], splatVariants = [], conditionalVariants = [];\n  for (const [idx, attr] of node.attributes.entries()) {\n    if (attr.type === \"ObjectAttributeValue\") {\n      const attributeNode = walk({ node: attr.value, scope });\n      objectAttributes.push([\n        idx,\n        attr.name,\n        {\n          type: \"objectAttribute\",\n          value: attributeNode\n        }\n      ]);\n      continue;\n    }\n    if (attr.type === \"ObjectSplat\") {\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      switch ($trace(\"object.splat.result %O\", attributeNode), attributeNode.type) {\n        case \"object\": {\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        case \"union\": {\n          for (const node2 of attributeNode.of)\n            if (node2.type === \"unknown\")\n              return node2;\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        default:\n          return { type: \"unknown\" };\n      }\n    }\n    if (attr.type === \"ObjectConditionalSplat\") {\n      const condition = booleanValue(walk({ node: attr.condition, scope }), scope);\n      if ($trace(\"object.conditional.splat.condition %O\", condition), condition.canBeTrue === !1)\n        continue;\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      if ($trace(\"object.conditional.splat.result %O\", attributeNode), condition.canBeFalse === !1 && condition.canBeNull === !1)\n        switch (attributeNode.type) {\n          case \"object\": {\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          case \"union\": {\n            for (const node2 of attributeNode.of)\n              if (node2.type !== \"object\")\n                return { type: \"unknown\" };\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          default:\n            return { type: \"unknown\" };\n        }\n      const variant = mapNode(attributeNode, scope, (attributeNode2) => ($trace(\"object.conditional.splat.result.concrete %O\", attributeNode2), attributeNode2.type !== \"object\" ? { type: \"unknown\" } : {\n        type: \"object\",\n        attributes: attributeNode2.attributes\n      }));\n      if (variant.type === \"union\") {\n        for (const node2 of variant.of)\n          if (node2.type !== \"object\")\n            return { type: \"unknown\" };\n        variant.of.push({ type: \"object\", attributes: {} }), conditionalVariants.push([idx, variant]);\n        continue;\n      }\n      if (variant.type !== \"object\")\n        return { type: \"unknown\" };\n      conditionalVariants.push([\n        idx,\n        {\n          type: \"union\",\n          of: [{ type: \"object\", attributes: {} }, variant]\n        }\n      ]);\n      continue;\n    }\n    throw new Error(`Unknown object attribute type: ${attr.type}`);\n  }\n  const guaranteedAttributes = [];\n  guaranteedAttributes.push(...objectAttributes);\n  for (const [idx, splatNode] of splatVariants) {\n    if (splatNode.type === \"object\") {\n      for (const name in splatNode.attributes) {\n        if (!splatNode.attributes.hasOwnProperty(name))\n          continue;\n        const attribute = splatNode.attributes[name];\n        guaranteedAttributes.push([idx, name, attribute]);\n      }\n      continue;\n    }\n    conditionalVariants.push([idx, splatNode]);\n  }\n  if (guaranteedAttributes.sort(([a], [b]) => a - b), conditionalVariants.length === 0)\n    return {\n      type: \"object\",\n      attributes: Object.fromEntries(\n        guaranteedAttributes.map(([, name, attribute]) => [name, attribute])\n      )\n    };\n  const matrix = [];\n  for (const [unionIdx, union] of conditionalVariants) {\n    const unionGuaranteedBefore = [], unionGuaranteedAfter = [];\n    for (const [guaranteedIndex, name, attribute] of guaranteedAttributes)\n      guaranteedIndex < unionIdx && unionGuaranteedBefore.push([guaranteedIndex, name, attribute]), guaranteedIndex > unionIdx && unionGuaranteedAfter.push([guaranteedIndex, name, attribute]);\n    const allVariantsAttributes = [];\n    for (const [conditionalVariantIdx, otherUnion] of conditionalVariants) {\n      const variantAttributes = [];\n      for (const node2 of otherUnion.of)\n        variantAttributes.push(node2.attributes);\n      allVariantsAttributes.push([conditionalVariantIdx, variantAttributes]);\n    }\n    for (const node2 of union.of) {\n      matrix.push({\n        type: \"object\",\n        attributes: {\n          ...Object.fromEntries(\n            unionGuaranteedBefore.map(([, name, attribute]) => [name, attribute])\n          ),\n          ...node2.attributes,\n          ...Object.fromEntries(\n            unionGuaranteedAfter.map(([, name, attribute]) => [name, attribute])\n          )\n        }\n      });\n      for (const [outerIdx, outerAttributes] of allVariantsAttributes)\n        for (const outer of outerAttributes)\n          for (const [innerIdx, innerAttributes] of allVariantsAttributes)\n            if (outerIdx !== innerIdx)\n              for (const inner of innerAttributes) {\n                const _before = [...unionGuaranteedBefore], _after = [...unionGuaranteedAfter];\n                for (const name in outer)\n                  outer.hasOwnProperty(name) && outerIdx !== unionIdx && (outerIdx < unionIdx && _before.push([outerIdx, name, outer[name]]), outerIdx > unionIdx && _after.push([outerIdx, name, outer[name]]));\n                for (const name in inner)\n                  inner.hasOwnProperty(name) && outerIdx !== unionIdx && (innerIdx < unionIdx && _before.push([innerIdx, name, inner[name]]), innerIdx > unionIdx && _after.push([innerIdx, name, inner[name]]));\n                _before.sort(([a], [b]) => a - b), _after.sort(([a], [b]) => a - b);\n                const before = Object.fromEntries(\n                  _before.map(([, name, attribute]) => [name, attribute])\n                ), after = Object.fromEntries(\n                  _after.map(([, name, attribute]) => [name, attribute])\n                );\n                matrix.push({\n                  type: \"object\",\n                  attributes: {\n                    ...before,\n                    ...node2.attributes,\n                    ...after\n                  }\n                });\n              }\n    }\n  }\n  return optimizeUnions({\n    type: \"union\",\n    of: matrix\n  });\n}\nfunction handleOpCallNode(node, scope) {\n  $trace(\"opcall.node %O\", node);\n  const lhs = walk({ node: node.left, scope }), rhs = walk({ node: node.right, scope });\n  return mapNode(\n    lhs,\n    scope,\n    (left) => (\n      // eslint-disable-next-line complexity, max-statements\n      mapNode(rhs, scope, (right) => {\n        switch ($trace('opcall.node.concrete \"%s\" %O', node.op, { left, right }), node.op) {\n          case \"==\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : left.type !== right.type ? {\n              type: \"boolean\",\n              value: !1\n            } : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: !0\n            } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n              type: \"boolean\",\n              value: !1\n            } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"!=\": {\n            if (left.type === \"unknown\" || right.type === \"unknown\")\n              return { type: \"boolean\" };\n            if (left.type !== right.type)\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            if (left.type === \"null\")\n              return {\n                type: \"boolean\",\n                value: !1\n              };\n            if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right))\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            let value = evaluateComparison(\"==\", left, right);\n            return value !== void 0 && (value = !value), {\n              type: \"boolean\",\n              value\n            };\n          }\n          case \">\":\n          case \">=\":\n          case \"<\":\n          case \"<=\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type !== right.type ? { type: \"null\" } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? { type: \"null\" } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"in\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : right.type !== \"array\" ? isFuncCall(node.right, \"global::path\") ? { type: \"boolean\" } : { type: \"null\" } : !isPrimitiveTypeNode(left) && left.type !== \"null\" ? {\n              type: \"boolean\",\n              value: !1\n            } : mapNode(right.of, scope, (arrayTypeNode) => arrayTypeNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: arrayTypeNode.type === \"null\"\n            } : left.value === void 0 ? {\n              type: \"boolean\"\n            } : isPrimitiveTypeNode(arrayTypeNode) ? arrayTypeNode.value === void 0 ? {\n              type: \"boolean\"\n            } : {\n              type: \"boolean\",\n              value: left.value === arrayTypeNode.value\n            } : {\n              type: \"boolean\",\n              value: !1\n            });\n          case \"match\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : {\n              type: \"boolean\",\n              value: match(left, right)\n            };\n          case \"+\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"unknown\" } : left.type === \"string\" && right.type === \"string\" ? {\n              type: \"string\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"array\" && right.type === \"array\" ? {\n              type: \"array\",\n              of: {\n                type: \"union\",\n                of: [left.of, right.of]\n              }\n            } : left.type === \"object\" && right.type === \"object\" ? {\n              type: \"object\",\n              attributes: { ...left.attributes, ...right.attributes }\n            } : { type: \"null\" };\n          case \"-\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value - right.value : void 0\n            } : { type: \"null\" };\n          case \"*\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value * right.value : void 0\n            } : { type: \"null\" };\n          case \"/\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value / right.value : void 0\n            } : { type: \"null\" };\n          case \"**\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value ** right.value : void 0\n            } : { type: \"null\" };\n          case \"%\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value % right.value : void 0\n            } : { type: \"null\" };\n          default:\n            return {\n              type: \"unknown\"\n            };\n        }\n      })\n    )\n  );\n}\nfunction handleSelectNode(node, scope) {\n  const values = [];\n  let guaranteed = !1;\n  for (const alternative of node.alternatives) {\n    const conditionValue = walk({ node: alternative.condition, scope }), conditionScope = resolveFilter(alternative.condition, scope);\n    conditionScope.type === \"union\" && conditionScope.of.length > 0 && values.push(walk({ node: alternative.value, scope: scope.createHidden(conditionScope.of) })), conditionValue.type === \"boolean\" && conditionValue.value === !0 && (guaranteed = !0);\n  }\n  return node.fallback && !guaranteed && values.push(walk({ node: node.fallback, scope })), values.length === 0 ? { type: \"null\" } : {\n    type: \"union\",\n    of: values\n  };\n}\nfunction handleArrayCoerceNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"arrayCoerce.base %O\", base), mapArray(base, scope, (base2) => base2);\n}\nfunction handleFlatMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => {\n    const inner = walk({ node: node.expr, scope: scope.createHidden([base2.of]) });\n    return mapNode(\n      inner,\n      scope,\n      (inner2) => inner2.type === \"array\" ? inner2 : { type: \"array\", of: inner2 },\n      (nodes) => {\n        const inner2 = [];\n        for (const node2 of nodes) {\n          if (node2.type === \"unknown\") return { type: \"array\", of: node2 };\n          if (node2.type !== \"array\") throw new Error(`Unexpected type: ${node2.type}`);\n          inner2.push(node2.of);\n        }\n        return {\n          type: \"array\",\n          of: optimizeUnions({ type: \"union\", of: inner2 })\n        };\n      }\n    );\n  });\n}\nfunction handleMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"map.base %O\", base), mapArray(base, scope, (base2) => ({\n    type: \"array\",\n    of: walk({ node: node.expr, scope: scope.createHidden([base2.of]) })\n  }));\n}\nfunction handleProjectionNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"projection.base %O\", base), mapObject(\n    base,\n    scope,\n    (base2) => walk({ node: node.expr, scope: scope.createNested([base2]) })\n  );\n}\nfunction createFilterScope(base, scope) {\n  return base.type === \"array\" ? base.of.type === \"union\" ? scope.createNested(base.of.of) : scope.createNested([base.of]) : scope.createNested([base]);\n}\nfunction handleFilterNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"filter.base %O\", base), mapNode(base, scope, (base2) => {\n    if ($trace(\"filter.resolving %O\", base2), base2.type === \"null\")\n      return base2;\n    const resolved = resolveFilter(node.expr, createFilterScope(base2, scope));\n    return $trace(\"filter.resolved %O\", resolved), {\n      type: \"array\",\n      of: resolved\n    };\n  });\n}\nfunction handleAccessAttributeNode(node, scope) {\n  let attributeBase = scope.value;\n  return node.base && (attributeBase = walk({ node: node.base, scope })), $trace(\"accessAttribute.base %s %O\", node.name, attributeBase), handleAccessAttributeBase(attributeBase, node.name, scope);\n}\nfunction handleAccessAttributeBase(base, name, scope) {\n  return mapObject(base, scope, (base2) => {\n    $trace('Looking for attribute \"%s\" in object %O', name, base2);\n    const attribute = base2.attributes[name];\n    return attribute !== void 0 ? ($debug(`accessAttribute.attribute found ${name} %O`, attribute), attribute.optional ? nullUnion(attribute.value) : attribute.value) : base2.rest ? handleAccessAttributeBase(base2.rest, name, scope) : ($warn(`attribute \"${name}\" not found in object`), { type: \"null\" });\n  });\n}\nfunction handleAccessElementNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"accessElement.base %O\", base), mapArray(base, scope, (base2) => nullUnion(base2.of));\n}\nfunction handleArrayNode(node, scope) {\n  const of = [];\n  for (const el of node.elements) {\n    const node2 = walk({ node: el.value, scope });\n    node2 !== null && of.push(node2);\n  }\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of\n    }\n  };\n}\nfunction handleValueNode(node, scope) {\n  if (node.value === null)\n    return { type: \"null\" };\n  switch (typeof node.value) {\n    case \"string\":\n      return {\n        type: \"string\",\n        value: node.value\n      };\n    case \"number\":\n      return {\n        type: \"number\",\n        value: node.value\n      };\n    case \"boolean\":\n      return {\n        type: \"boolean\",\n        value: node.value\n      };\n    case \"object\":\n      return node.value === null ? { type: \"null\" } : Array.isArray(node.value) ? {\n        type: \"array\",\n        of: {\n          type: \"union\",\n          of: node.value.map((value) => walk({ node: { type: \"Value\", value }, scope }))\n        }\n      } : {\n        type: \"object\",\n        attributes: Object.fromEntries(\n          Object.entries(node.value).map(([key, value]) => [\n            key,\n            {\n              type: \"objectAttribute\",\n              value: walk({ node: { type: \"Value\", value }, scope })\n            }\n          ])\n        )\n      };\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction handleSlice(node, scope) {\n  $trace(\"slice.node %O\", node);\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => base2);\n}\nfunction handleParentNode({ n }, scope) {\n  $trace(\"handle.parent.currentScope %d %O\", n, scope);\n  let current = scope;\n  for (let i = 0; i < n; i++) {\n    for (; current != null && current.isHidden; )\n      current = current.parent;\n    current = current == null ? void 0 : current.parent;\n  }\n  return $trace(\"handle.parent.newScope %d %O\", n, current), current ? current.value.of.length === 0 ? { type: \"null\" } : current.value : { type: \"null\" };\n}\nfunction handleNotNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : base2.type === \"boolean\" ? base2.value !== void 0 ? { type: \"boolean\", value: base2.value === !1 } : { type: \"boolean\" } : { type: \"null\" });\n}\nfunction handleNegNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2.value !== void 0 ? { type: \"number\", value: -base2.value } : base2);\n}\nfunction handlePosNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2);\n}\nfunction handleEverythingNode(_, scope) {\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of: scope.context.schema.filter((obj) => obj.type === \"document\").map((doc) => ({\n        type: \"object\",\n        attributes: doc.attributes\n      }))\n    }\n  };\n}\nfunction handleAndNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nfunction handleOrNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nconst OVERRIDE_TYPE_SYMBOL = Symbol(\"groq-js.type\");\nfunction walk({ node, scope }) {\n  if (OVERRIDE_TYPE_SYMBOL in node)\n    return node[OVERRIDE_TYPE_SYMBOL];\n  switch (node.type) {\n    case \"Map\":\n      return handleMap(node, scope);\n    case \"Projection\":\n      return handleProjectionNode(node, scope);\n    case \"Filter\":\n      return handleFilterNode(node, scope);\n    case \"AccessAttribute\":\n      return optimizeUnions(handleAccessAttributeNode(node, scope));\n    case \"AccessElement\":\n      return handleAccessElementNode(node, scope);\n    case \"ArrayCoerce\":\n      return handleArrayCoerceNode(node, scope);\n    case \"FlatMap\":\n      return handleFlatMap(node, scope);\n    case \"OpCall\":\n      return handleOpCallNode(node, scope);\n    case \"And\":\n      return handleAndNode(node, scope);\n    case \"Or\":\n      return handleOrNode(node, scope);\n    case \"Select\":\n      return handleSelectNode(node, scope);\n    case \"PipeFuncCall\":\n      return walk({ node: node.base, scope });\n    case \"Deref\":\n      return handleDerefNode(node, scope);\n    case \"Object\":\n      return handleObjectNode(node, scope);\n    case \"Value\":\n      return handleValueNode(node, scope);\n    case \"Array\":\n      return handleArrayNode(node, scope);\n    case \"Everything\":\n      return handleEverythingNode(node, scope);\n    case \"This\":\n      return $trace(\"this %O\", scope.value), scope.value;\n    case \"Parent\":\n      return handleParentNode(node, scope);\n    case \"FuncCall\":\n      return handleFuncCallNode(node, scope);\n    case \"Group\":\n      return walk({ node: node.base, scope });\n    case \"Not\":\n      return handleNotNode(node, scope);\n    case \"Parameter\":\n      return {\n        type: \"unknown\"\n      };\n    case \"Slice\":\n      return handleSlice(node, scope);\n    case \"Neg\":\n      return handleNegNode(node, scope);\n    case \"Pos\":\n      return handlePosNode(node, scope);\n    case \"Asc\":\n    case \"Desc\":\n    case \"Context\":\n    case \"Tuple\":\n    case \"Selector\":\n    case \"InRange\":\n      return { type: \"unknown\" };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction isPrimitiveTypeNode(node) {\n  return node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\";\n}\nfunction evaluateComparison(opcall, left, right) {\n  if (!(left.value === void 0 || right.value === void 0))\n    switch (opcall) {\n      case \"==\":\n        return left.value === right.value;\n      case \"<\":\n        return left.value < right.value;\n      case \"<=\":\n        return left.value <= right.value;\n      case \">\":\n        return left.value > right.value;\n      case \">=\":\n        return left.value >= right.value;\n      default:\n        throw new Error(`unknown comparison operator ${opcall}`);\n    }\n}\nfunction resolveFilter(expr, scope) {\n  $trace(\"resolveFilter.expr %O\", expr);\n  const filtered = scope.value.of.filter((node) => {\n    const subScope = scope.createHidden([node]), cond = walk({ node: expr, scope: subScope });\n    return booleanValue(cond, subScope).canBeTrue;\n  });\n  return $trace(\n    `resolveFilter ${expr.type === \"OpCall\" ? `${expr.type}/${expr.op}` : expr.type} %O`,\n    filtered\n  ), { type: \"union\", of: filtered };\n}\nfunction mapArray(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"array\" ? mapper(base) : { type: \"null\" });\n}\nfunction mapObject(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"object\" ? mapper(base) : { type: \"null\" });\n}\n\n//# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEI7QUFDMUIsdUhBQXVILHVEQUF1RDtBQUM5SztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILHVEQUF1RDtBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLElBQUksRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwQkFBMEIsT0FBTyxLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUcsT0FBTyxHQUFHLE9BQU8sRUFBRSxpQkFBaUI7QUFDcko7QUFDQTtBQUNBO0FBQ0EsU0FBUywyQkFBMkI7QUFDcEMsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQSx1SEFBdUgsdURBQXVEO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRywyREFBMkQsR0FBRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlDQUF5QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsbUZBQW1GLG1CQUFtQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSSxtRkFBbUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLE9BQU87QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztB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QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2QkFBNkI7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsNEJBQTRCLFVBQVUsR0FBRyxRQUFRLGVBQWU7QUFDckY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtIQUFrSCxjQUFjO0FBQ2hJO0FBQ0E7QUFDQSxtSEFBbUgsY0FBYztBQUNqSTtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydHVwLXByby8uL25vZGVfbW9kdWxlcy9ncm9xLWpzL2Rpc3QvMS5tanM/ZTJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG52YXIgX19kZWZQcm9wJDYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCQ2ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ2KG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCQ2ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wJDYob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcGF0aFJlZ0V4cChwYXR0ZXJuKSB7XG4gIGNvbnN0IHJlID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuLnNwbGl0KFwiLlwiKSlcbiAgICBwYXJ0ID09PSBcIipcIiA/IHJlLnB1c2goXCJbXi5dK1wiKSA6IHBhcnQgPT09IFwiKipcIiA/IHJlLnB1c2goXCIuKlwiKSA6IHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlLmpvaW4oXCIuXCIpfSRgKTtcbn1cbmNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ2KHRoaXMsIFwicGF0dGVyblwiKSwgX19wdWJsaWNGaWVsZCQ2KHRoaXMsIFwicGF0dGVyblJlXCIpLCB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLCB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgbWF0Y2hlcyhzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG59XG52YXIgX19kZWZQcm9wJDUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCQ1ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ1KG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCQ1ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wJDUob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5jbGFzcyBTdHJlYW1WYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRvcikge1xuICAgIF9fcHVibGljRmllbGQkNSh0aGlzLCBcInR5cGVcIiwgXCJzdHJlYW1cIiksIF9fcHVibGljRmllbGQkNSh0aGlzLCBcImdlbmVyYXRvclwiKSwgX19wdWJsaWNGaWVsZCQ1KHRoaXMsIFwidGlja2VyXCIpLCBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJpc0RvbmVcIiksIF9fcHVibGljRmllbGQkNSh0aGlzLCBcImRhdGFcIiksIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLCB0aGlzLnRpY2tlciA9IG51bGwsIHRoaXMuaXNEb25lID0gITEsIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGFzeW5jIGdldCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpXG4gICAgICByZXN1bHQucHVzaChhd2FpdCB2YWx1ZS5nZXQoKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBmb3IgKDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgeWllbGQgdGhpcy5kYXRhW2ldO1xuICAgICAgaWYgKHRoaXMuaXNEb25lKVxuICAgICAgICByZXR1cm47XG4gICAgICBhd2FpdCB0aGlzLl9uZXh0VGljaygpO1xuICAgIH1cbiAgfVxuICBfbmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMudGlja2VyKVxuICAgICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICAgIGxldCBjdXJyZW50UmVzb2x2ZXI7XG4gICAgY29uc3Qgc2V0dXBUaWNrZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRpY2tlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9LCB0aWNrID0gKCkgPT4ge1xuICAgICAgY3VycmVudFJlc29sdmVyKCksIHNldHVwVGlja2VyKCk7XG4gICAgfSwgZmV0Y2ggPSBhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMuZ2VuZXJhdG9yKCkpXG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKSwgdGljaygpO1xuICAgICAgdGhpcy5pc0RvbmUgPSAhMCwgdGljaygpO1xuICAgIH07XG4gICAgcmV0dXJuIHNldHVwVGlja2VyKCksIGZldGNoKCksIHRoaXMudGlja2VyO1xuICB9XG59XG5jb25zdCBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xuICByZXR1cm4gUkZDMzMzOV9SRUdFWC50ZXN0KHN0cikgPyBuZXcgRGF0ZShzdHIpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJGQzMzMzkoZCkge1xuICBjb25zdCB5ZWFyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENGdWxsWWVhcigpLCA0KSwgbW9udGggPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01vbnRoKCkgKyAxLCAyKSwgZGF5ID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENEYXRlKCksIDIpLCBob3VyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENIb3VycygpLCAyKSwgbWludXRlID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNaW51dGVzKCksIDIpLCBzZWNvbmQgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ1NlY29uZHMoKSwgMik7XG4gIGxldCBmcmFjdGlvbmFsU2Vjb25kID0gXCJcIjtcbiAgY29uc3QgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgcmV0dXJuIG1pbGxpcyAhPSAwICYmIChmcmFjdGlvbmFsU2Vjb25kID0gYC4ke2FkZExlYWRpbmdaZXJvKG1pbGxpcywgMyl9YCksIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH0ke2ZyYWN0aW9uYWxTZWNvbmR9WmA7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gIGZvciAoOyBzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoOyApXG4gICAgc3RyID0gYDAke3N0cn1gO1xuICByZXR1cm4gc3RyO1xufVxudmFyIF9fZGVmUHJvcCQ0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZk5vcm1hbFByb3AkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcCQ0KG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuY2xhc3MgU3RhdGljVmFsdWUge1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0eXBlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiZGF0YVwiKSwgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidHlwZVwiKSwgdGhpcy5kYXRhID0gZGF0YSwgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpXG4gICAgICByZXR1cm4gZnVuY3Rpb24qIChkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkYXRhKVxuICAgICAgICAgIHlpZWxkIGZyb21KUyhlbGVtZW50KTtcbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpdGVyYXRlIG92ZXI6ICR7dGhpcy50eXBlfWApO1xuICB9XG59XG5jb25zdCBOVUxMX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKG51bGwsIFwibnVsbFwiKSwgVFJVRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSghMCwgXCJib29sZWFuXCIpLCBGQUxTRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSghMSwgXCJib29sZWFuXCIpO1xuY2xhc3MgRGF0ZVRpbWUge1xuICBjb25zdHJ1Y3RvcihkYXRlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiZGF0ZVwiKSwgdGhpcy5kYXRlID0gZGF0ZTtcbiAgfVxuICBzdGF0aWMgcGFyc2VUb1ZhbHVlKHN0cikge1xuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICByZXR1cm4gZGF0ZSA/IG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksIFwiZGF0ZXRpbWVcIikgOiBOVUxMX1ZBTFVFO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIGFkZChzZWNzKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgIHJldHVybiBjb3B5LnNldFRpbWUoY29weS5nZXRUaW1lKCkgKyBzZWNzICogMWUzKSwgbmV3IERhdGVUaW1lKGNvcHkpO1xuICB9XG4gIGRpZmZlcmVuY2Uob3RoZXIpIHtcbiAgICByZXR1cm4gKHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKSkgLyAxZTM7XG4gIH1cbiAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZm9ybWF0UkZDMzMzOSh0aGlzLmRhdGUpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG59XG5mdW5jdGlvbiBmcm9tTnVtYmVyKG51bSkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG51bSkgPyBuZXcgU3RhdGljVmFsdWUobnVtLCBcIm51bWJlclwiKSA6IE5VTExfVkFMVUU7XG59XG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHN0ciwgXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBmcm9tRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShkdCwgXCJkYXRldGltZVwiKTtcbn1cbmZ1bmN0aW9uIGZyb21QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShwYXRoLCBcInBhdGhcIik7XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoubmV4dCA9PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XG4gIHJldHVybiBpc0l0ZXJhdG9yKHZhbCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHZhbClcbiAgICAgIHlpZWxkIGZyb21KUyh2YWx1ZSk7XG4gIH0pIDogdmFsID09IG51bGwgPyBOVUxMX1ZBTFVFIDogbmV3IFN0YXRpY1ZhbHVlKHZhbCwgZ2V0VHlwZSh2YWwpKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA+IFwidVwiID8gXCJudWxsXCIgOiBBcnJheS5pc0FycmF5KGRhdGEpID8gXCJhcnJheVwiIDogZGF0YSBpbnN0YW5jZW9mIFBhdGggPyBcInBhdGhcIiA6IGRhdGEgaW5zdGFuY2VvZiBEYXRlVGltZSA/IFwiZGF0ZXRpbWVcIiA6IHR5cGVvZiBkYXRhO1xufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIiA/IGEuZGF0YSA9PT0gYi5kYXRhIDogYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIgPyBhLmRhdGEuZXF1YWxzKGIuZGF0YSkgOiAhMTtcbn1cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2csIENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nLCBFREdFX0NIQVJTID0gLyhcXGJcXC4rfFxcLitcXGIpL2c7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICByZXR1cm4gdG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDAgPyAhMSA6IHBhdHRlcm5zLmV2ZXJ5KChwYXR0ZXJuKSA9PiBwYXR0ZXJuKHRva2VucykpO1xufVxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlMpIHx8IFtdO1xufVxuZnVuY3Rpb24gbWF0Y2hBbmFseXplUGF0dGVybih0ZXh0KSB7XG4gIHJldHVybiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KS5tYXAoKHJlKSA9PiAodG9rZW5zKSA9PiB0b2tlbnMuc29tZSgodG9rZW4pID0+IHJlLnRlc3QodG9rZW4pKSk7XG59XG5mdW5jdGlvbiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KSB7XG4gIHJldHVybiAodGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTX1dJVEhfV0lMRENBUkQpIHx8IFtdKS5tYXAoXG4gICAgKHRlcm0pID0+IG5ldyBSZWdFeHAoYF4ke3Rlcm0uc2xpY2UoMCwgMTAyNCkucmVwbGFjZSgvXFwqL2csIFwiLipcIil9JGAsIFwiaVwiKVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgY2IpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGNiKHZhbHVlLmRhdGEpLCAhMDtcbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGxldCBzdWNjZXNzID0gITA7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHZhbHVlKVxuICAgICAgcGFydC50eXBlID09PSBcInN0cmluZ1wiID8gY2IocGFydC5kYXRhKSA6IHN1Y2Nlc3MgPSAhMTtcbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICByZXR1cm4gITE7XG59XG5jb25zdCBUWVBFX09SREVSID0ge1xuICBkYXRldGltZTogMSxcbiAgbnVtYmVyOiAyLFxuICBzdHJpbmc6IDMsXG4gIGJvb2xlYW46IDRcbn07XG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKSwgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBpZiAoYVR5cGUgIT09IGJUeXBlKVxuICAgIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKGFUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gdG90YWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpLCBiVHlwZSA9IGdldFR5cGUoYiksIGFUeXBlT3JkZXIgPSBUWVBFX09SREVSW2FUeXBlXSB8fCAxMDAsIGJUeXBlT3JkZXIgPSBUWVBFX09SREVSW2JUeXBlXSB8fCAxMDA7XG4gIGlmIChhVHlwZU9yZGVyICE9PSBiVHlwZU9yZGVyKVxuICAgIHJldHVybiBhVHlwZU9yZGVyIC0gYlR5cGVPcmRlcjtcbiAgbGV0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGEsIGIpO1xuICByZXR1cm4gcmVzdWx0ID09PSBudWxsICYmIChyZXN1bHQgPSAwKSwgcmVzdWx0O1xufVxuY29uc3Qgb3BlcmF0b3JzID0ge1xuICBcIj09XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIiE9XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBcIj5cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIj49XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPFwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPD1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICBpbjogYXN5bmMgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQudHlwZSA9PT0gXCJwYXRoXCIpXG4gICAgICByZXR1cm4gbGVmdC50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IHJpZ2h0LmRhdGEubWF0Y2hlcyhsZWZ0LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIGlmIChyaWdodC5pc0FycmF5KCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiByaWdodClcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpXG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBtYXRjaDogYXN5bmMgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgdG9rZW5zID0gW10sIHBhdHRlcm5zID0gW107XG4gICAgcmV0dXJuIGF3YWl0IGdhdGhlclRleHQobGVmdCwgKHBhcnQpID0+IHtcbiAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gICAgfSksIGF3YWl0IGdhdGhlclRleHQocmlnaHQsIChwYXJ0KSA9PiB7XG4gICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLmNvbmNhdChtYXRjaEFuYWx5emVQYXR0ZXJuKHBhcnQpKTtcbiAgICB9KSAmJiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiK1wiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpIDogbGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIgPyBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpIDogbGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIgPyBmcm9tSlMoeyAuLi5sZWZ0LmRhdGEsIC4uLnJpZ2h0LmRhdGEgfSkgOiBsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIgPyBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSkgOiBsZWZ0LmlzQXJyYXkoKSAmJiByaWdodC5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpXG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHJpZ2h0KVxuICAgICAgICB5aWVsZCB2YWw7XG4gICAgfSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIi1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKC1yaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcImRhdGV0aW1lXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YS5kaWZmZXJlbmNlKHJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbU51bWJlcihsZWZ0LmRhdGEgLSByaWdodC5kYXRhKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgKiBiKSxcbiAgXCIvXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAvIGIpLFxuICBcIiVcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICUgYiksXG4gIFwiKipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBNYXRoLnBvdyhhLCBiKSlcbn07XG5mdW5jdGlvbiBudW1lcmljT3BlcmF0b3IoaW1wbCkge1xuICByZXR1cm4gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGltcGwobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9O1xufVxudmFyIF9fZGVmUHJvcCQzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcCQzKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xubGV0IFNjb3BlJDEgPSBjbGFzcyBTY29wZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwicGFyYW1zXCIpLCBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJzb3VyY2VcIiksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInZhbHVlXCIpLCBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJwYXJlbnRcIiksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImNvbnRleHRcIiksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImlzSGlkZGVuXCIsICExKSwgdGhpcy5wYXJhbXMgPSBwYXJhbXMsIHRoaXMuc291cmNlID0gc291cmNlLCB0aGlzLnZhbHVlID0gdmFsdWUsIHRoaXMuY29udGV4dCA9IGNvbnRleHQsIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSGlkZGVuID8gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpIDogbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNIaWRkZW4gPSAhMCwgcmVzdWx0O1xuICB9XG59O1xuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUsIGV4ZWN1dGUgPSBldmFsdWF0ZSkge1xuICBjb25zdCBmdW5jID0gRVhFQ1VUT1JTW25vZGUudHlwZV07XG4gIHJldHVybiBmdW5jKG5vZGUsIHNjb3BlLCBleGVjdXRlKTtcbn1cbmZ1bmN0aW9uIHByb21pc2VsZXNzQXBwbHkodmFsdWUsIGNiKSB7XG4gIHJldHVybiBcInRoZW5cIiBpbiB2YWx1ZSA/IHZhbHVlLnRoZW4oY2IpIDogY2IodmFsdWUpO1xufVxuY29uc3QgRVhFQ1VUT1JTID0ge1xuICBUaGlzKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICB9LFxuICBTZWxlY3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvcnMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIEV2ZXJ5dGhpbmcoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUuc291cmNlO1xuICB9LFxuICBQYXJhbWV0ZXIoeyBuYW1lIH0sIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZyb21KUyhzY29wZS5wYXJhbXNbbmFtZV0pO1xuICB9LFxuICBDb250ZXh0KHsga2V5IH0sIHNjb3BlKSB7XG4gICAgaWYgKGtleSA9PT0gXCJiZWZvcmVcIiB8fCBrZXkgPT09IFwiYWZ0ZXJcIilcbiAgICAgIHJldHVybiBzY29wZS5jb250ZXh0W2tleV0gfHwgTlVMTF9WQUxVRTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY29udGV4dCBrZXk6ICR7a2V5fWApO1xuICB9LFxuICBQYXJlbnQoeyBuIH0sIHNjb3BlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBzY29wZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9LFxuICBPcENhbGwoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgcmV0dXJuIFwidGhlblwiIGluIGxlZnRWYWx1ZSB8fCBcInRoZW5cIiBpbiByaWdodFZhbHVlID8gKGFzeW5jICgpID0+IGZ1bmMoYXdhaXQgbGVmdFZhbHVlLCBhd2FpdCByaWdodFZhbHVlKSkoKSA6IGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgfSxcbiAgYXN5bmMgU2VsZWN0KHsgYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdGVybmF0aXZlcykge1xuICAgICAgY29uc3QgYWx0Q29uZCA9IGF3YWl0IGV4ZWN1dGUoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgaWYgKGFsdENvbmQudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYWx0Q29uZC5kYXRhID09PSAhMClcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjayA/IGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKSwgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgcmV0dXJuIHJpZ2h0Q21wID09PSBudWxsID8gTlVMTF9WQUxVRSA6IGlzSW5jbHVzaXZlID8gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUUgOiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIGJhc2VWYWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSksIGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09ICEwICYmICh5aWVsZCBlbGVtKTtcbiAgICAgIH1cbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIFByb2plY3Rpb24oeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gIH0sXG4gIEZ1bmNDYWxsKHsgZnVuYywgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKHsgZnVuYywgYmFzZSwgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoeyBiYXNlLCBuYW1lIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgcmV0dXJuIGJhc2UgJiYgKHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSkpLCB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPyBmcm9tSlModmFsdWUuZGF0YVtuYW1lXSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBY2Nlc3NFbGVtZW50KHsgYmFzZSwgaW5kZXggfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpLCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gIH0sXG4gIGFzeW5jIFNsaWNlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgYXJyYXkyID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpO1xuICAgIGxldCBsZWZ0SWR4ID0gbGVmdCwgcmlnaHRJZHggPSByaWdodDtcbiAgICByZXR1cm4gbGVmdElkeCA8IDAgJiYgKGxlZnRJZHggPSBhcnJheTIubGVuZ3RoICsgbGVmdElkeCksIHJpZ2h0SWR4IDwgMCAmJiAocmlnaHRJZHggPSBhcnJheTIubGVuZ3RoICsgcmlnaHRJZHgpLCBpc0luY2x1c2l2ZSAmJiByaWdodElkeCsrLCBsZWZ0SWR4IDwgMCAmJiAobGVmdElkeCA9IDApLCByaWdodElkeCA8IDAgJiYgKHJpZ2h0SWR4ID0gMCksIGZyb21KUyhhcnJheTIuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKTtcbiAgfSxcbiAgYXN5bmMgRGVyZWYoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkgfHwgdmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgIGlmICh0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGlmIChzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKVxuICAgICAgcmV0dXJuIGZyb21KUyhhd2FpdCBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHsgX3JlZjogaWQgfSkpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIHNjb3BlLnNvdXJjZSlcbiAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKVxuICAgICAgICByZXR1cm4gZG9jO1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBWYWx1ZSh7IHZhbHVlIH0pIHtcbiAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgfSxcbiAgR3JvdXAoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICB9LFxuICBhc3luYyBPYmplY3QoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgc3dpdGNoIChhdHRyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHJlc3VsdFthdHRyLm5hbWVdID0gYXdhaXQgdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIjoge1xuICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgY29uZC5kYXRhID09PSAhMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICB9LFxuICBBcnJheSh7IGVsZW1lbnRzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgVHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBhc3luYyBPcih7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgcmV0dXJuIGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBsZWZ0VmFsdWUuZGF0YSA9PT0gITAgfHwgcmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiByaWdodFZhbHVlLmRhdGEgPT09ICEwID8gVFJVRV9WQUxVRSA6IGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBbmQoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIHJldHVybiBsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgbGVmdFZhbHVlLmRhdGEgPT09ICExIHx8IHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmlnaHRWYWx1ZS5kYXRhID09PSAhMSA/IEZBTFNFX1ZBTFVFIDogbGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTm90KHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiID8gTlVMTF9WQUxVRSA6IGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpKTtcbiAgfSxcbiAgUG9zKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcih2YWx1ZS5kYXRhKSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgIHlpZWxkIGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgfVxuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKSwgaW5uZXJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoaW5uZXJWYWx1ZS5pc0FycmF5KCkpXG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbm5lciBvZiBpbm5lclZhbHVlKVxuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB5aWVsZCBpbm5lclZhbHVlO1xuICAgICAgfVxuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KSwgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpLCBwYXJhbXMgPSB7IC4uLm9wdGlvbnMucGFyYW1zIH0sIHNjb3BlID0gbmV3IFNjb3BlJDEoXG4gICAgcGFyYW1zLFxuICAgIGRhdGFzZXQsXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsLFxuICAgICAgZGVyZWZlcmVuY2U6IG9wdGlvbnMuZGVyZWZlcmVuY2VcbiAgICB9LFxuICAgIG51bGxcbiAgKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gITA7XG4gICAgY2FzZSBcIlBvc1wiOlxuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuY29uc3QgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUkMShcbiAge30sXG4gIE5VTExfVkFMVUUsXG4gIE5VTExfVkFMVUUsXG4gIHsgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSxcbiAgbnVsbFxuKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSA/IGNvbnN0YW50RXZhbHVhdGUobm9kZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZVwiKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gYmxvY2tUZXh0KHZhbHVlLmRhdGEpO1xuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgY29uc3QgdGV4dHMgPSBhd2FpdCBhcnJheVRleHQodmFsdWUpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oYFxuXG5gKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0ID0gW10pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgIHRleHQgIT09IG51bGwgJiYgcmVzdWx0LnB1c2godGV4dCk7XG4gICAgfSBlbHNlIGJsb2NrLmlzQXJyYXkoKSAmJiBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9IFwic3RyaW5nXCIpIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgIGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PSBcInN0cmluZ1wiICYmIChyZXN1bHQgKz0gY2hpbGQudGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpXG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSksIGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICByZXR1cm4gYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCA/IGlubmVyU2NvcmUgKyBib29zdC5kYXRhIDogMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDAgPyAwIDogbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSAhMCA/IDEgOiAwO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlKGxlZnQsIHJpZ2h0LCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHBhdHRlcm4gPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gIGxldCB0b2tlbnMgPSBbXSwgdGVybXMgPSBbXTtcbiAgaWYgKGF3YWl0IGdhdGhlclRleHQodGV4dCwgKHBhcnQpID0+IHtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICB9KSwgIWF3YWl0IGdhdGhlclRleHQocGF0dGVybiwgKHBhcnQpID0+IHtcbiAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChtYXRjaFBhdHRlcm5SZWdleChwYXJ0KSk7XG4gIH0pIHx8IHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICBsZXQgc2NvcmUgPSAwO1xuICBmb3IgKGNvbnN0IHJlIG9mIHRlcm1zKSB7XG4gICAgY29uc3QgZnJlcSA9IHRva2Vucy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcbiAgICBzY29yZSArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgfVxuICByZXR1cm4gc2NvcmU7XG59XG5mdW5jdGlvbiBoYXNSZWZlcmVuY2UodmFsdWUsIHBhdGhTZXQpIHtcbiAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZS5fcmVmKVxuICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gY291bnRVVEY4KHN0cikge1xuICBsZXQgY291bnQyID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5IHx8IGNvdW50MisrO1xuICB9XG4gIHJldHVybiBjb3VudDI7XG59XG5jb25zdCBfZ2xvYmFsID0ge307XG5fZ2xvYmFsLmFueXdoZXJlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5fZ2xvYmFsLmFueXdoZXJlLmFyaXR5ID0gMTtcbl9nbG9iYWwuY29hbGVzY2UgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bGxcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5fZ2xvYmFsLmNvdW50ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFpbm5lci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBudW0gPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpXG4gICAgbnVtKys7XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiB2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiID8gdmFsIDogdmFsLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5fZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbl9nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIHJldHVybiAoYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSkpLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xufTtcbl9nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5fZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuaWRlbnRpdHkpO1xufTtcbl9nbG9iYWwuaWRlbnRpdHkuYXJpdHkgPSAwO1xuX2dsb2JhbC5sZW5ndGggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpO1xuICBpZiAoaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIGF3YWl0IChjb25zdCBfIG9mIGlubmVyKVxuICAgICAgbnVtKys7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5fZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XG5fZ2xvYmFsLnBhdGggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSk7XG59O1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoYCR7dmFsdWUuZGF0YX1gKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5fZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5fZ2xvYmFsLnJlZmVyZW5jZXMgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBwYXRoU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHBhdGgyID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAocGF0aDIudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHBhdGhTZXQuYWRkKHBhdGgyLmRhdGEpO1xuICAgIGVsc2UgaWYgKHBhdGgyLmlzQXJyYXkoKSlcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBwYXRoMilcbiAgICAgICAgZWxlbS50eXBlID09PSBcInN0cmluZ1wiICYmIHBhdGhTZXQuYWRkKGVsZW0uZGF0YSk7XG4gIH1cbiAgaWYgKHBhdGhTZXQuc2l6ZSA9PT0gMClcbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIGNvbnN0IHNjb3BlVmFsdWUgPSBhd2FpdCBzY29wZS52YWx1ZS5nZXQoKTtcbiAgcmV0dXJuIGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5fZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSAoYykgPT4gYyA+PSAxO1xuX2dsb2JhbC5yb3VuZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBudW0gPSB2YWx1ZS5kYXRhO1xuICBsZXQgcHJlYyA9IDA7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByZWNWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICB9XG4gIHJldHVybiBwcmVjID09PSAwID8gbnVtIDwgMCA/IGZyb21OdW1iZXIoLU1hdGgucm91bmQoLW51bSkpIDogZnJvbU51bWJlcihNYXRoLnJvdW5kKG51bSkpIDogZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKTtcbn07XG5fZ2xvYmFsLnJvdW5kLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDEgJiYgY291bnQyIDw9IDI7XG5fZ2xvYmFsLm5vdyA9IGFzeW5jIGZ1bmN0aW9uKF9hcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcbn07XG5fZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG5fZ2xvYmFsLmJvb3N0ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn07XG5fZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbmNvbnN0IHN0cmluZzIgPSB7fTtcbnN0cmluZzIubG93ZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gdmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9Mb3dlckNhc2UoKSk7XG59O1xuc3RyaW5nMi5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcyLnVwcGVyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi5zcGxpdCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICByZXR1cm4gc2VwLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogc3RyLmRhdGEubGVuZ3RoID09PSAwID8gZnJvbUpTKFtdKSA6IHNlcC5kYXRhLmxlbmd0aCA9PT0gMCA/IGZyb21KUyhBcnJheS5mcm9tKHN0ci5kYXRhKSkgOiBmcm9tSlMoc3RyLmRhdGEuc3BsaXQoc2VwLmRhdGEpKTtcbn07XG5zdHJpbmcyLnNwbGl0LmFyaXR5ID0gMjtcbl9nbG9iYWwubG93ZXIgPSBzdHJpbmcyLmxvd2VyO1xuX2dsb2JhbC51cHBlciA9IHN0cmluZzIudXBwZXI7XG5zdHJpbmcyLnN0YXJ0c1dpdGggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBwcmVmaXggPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgcmV0dXJuIHByZWZpeC50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IHN0ci5kYXRhLnN0YXJ0c1dpdGgocHJlZml4LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbnN0cmluZzIuc3RhcnRzV2l0aC5hcml0eSA9IDI7XG5jb25zdCBhcnJheSA9IHt9O1xuYXJyYXkuam9pbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoc2VwLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBidWYgPSBcIlwiLCBuZWVkU2VwID0gITE7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBzd2l0Y2ggKG5lZWRTZXAgJiYgKGJ1ZiArPSBzZXAuZGF0YSksIGVsZW0udHlwZSkge1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICBidWYgKz0gYCR7ZWxlbS5kYXRhfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG5lZWRTZXAgPSAhMDtcbiAgfVxuICByZXR1cm4gZnJvbUpTKGJ1Zik7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBhcnIuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICAgIGVsZW0udHlwZSAhPT0gXCJudWxsXCIgJiYgKHlpZWxkIGVsZW0pO1xuICB9KSA6IE5VTExfVkFMVUU7XG59O1xuYXJyYXkuY29tcGFjdC5hcml0eSA9IDE7XG5hcnJheS51bmlxdWUgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlciBvZiB2YWx1ZSlcbiAgICAgIHN3aXRjaCAoaXRlci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgICBhZGRlZC5oYXMoaXRlci5kYXRhKSB8fCAoYWRkZWQuYWRkKGl0ZXIuZGF0YSksIHlpZWxkIGl0ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHlpZWxkIGl0ZXI7XG4gICAgICB9XG4gIH0pIDogTlVMTF9WQUxVRTtcbn07XG5hcnJheS51bmlxdWUuYXJpdHkgPSAxO1xuY29uc3QgcHQgPSB7fTtcbnB0LnRleHQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpLCB0ZXh0ID0gYXdhaXQgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSk7XG4gIHJldHVybiB0ZXh0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IGZyb21TdHJpbmcodGV4dCk7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG5jb25zdCBzYW5pdHkgPSB7fTtcbnNhbml0eS5wcm9qZWN0SWQgPSBhc3luYyBmdW5jdGlvbihfYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIHNjb3BlLmNvbnRleHQuc2FuaXR5ID8gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5wcm9qZWN0SWQpIDogTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uKF9hcmdzLCBzY29wZSkge1xuICByZXR1cm4gc2NvcGUuY29udGV4dC5zYW5pdHkgPyBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpIDogTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkudmVyc2lvbk9mID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBiYXNlSWQgPSB2YWx1ZS5kYXRhLCB2ZXJzaW9uSWRzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUyIG9mIHNjb3BlLnNvdXJjZSlcbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZTIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB2YWwgPSBhd2FpdCB2YWx1ZTIuZ2V0KCk7XG4gICAgICB2YWwgJiYgXCJfaWRcIiBpbiB2YWwgJiYgdmFsLl9pZC5zcGxpdChcIi5cIikubGVuZ3RoID09PSAyICYmIHZhbC5faWQuZW5kc1dpdGgoYC4ke2Jhc2VJZH1gKSAmJiBcIl92ZXJzaW9uXCIgaW4gdmFsICYmIHR5cGVvZiB2YWwuX3ZlcnNpb24gPT0gXCJvYmplY3RcIiAmJiB2ZXJzaW9uSWRzLnB1c2godmFsLl9pZCk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKHZlcnNpb25JZHMpO1xufTtcbnNhbml0eS52ZXJzaW9uT2YuYXJpdHkgPSAxO1xuc2FuaXR5LmRvY3VtZW50c09mID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBiYXNlSWQgPSB2YWx1ZS5kYXRhLCBkb2N1bWVudElkc0luQnVuZGxlID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUyIG9mIHNjb3BlLnNvdXJjZSlcbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZTIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB2YWwgPSBhd2FpdCB2YWx1ZTIuZ2V0KCk7XG4gICAgICB2YWwgJiYgXCJfaWRcIiBpbiB2YWwgJiYgdmFsLl9pZC5zcGxpdChcIi5cIikubGVuZ3RoID09PSAyICYmIHZhbC5faWQuc3RhcnRzV2l0aChgJHtiYXNlSWR9LmApICYmIFwiX3ZlcnNpb25cIiBpbiB2YWwgJiYgdHlwZW9mIHZhbC5fdmVyc2lvbiA9PSBcIm9iamVjdFwiICYmIGRvY3VtZW50SWRzSW5CdW5kbGUucHVzaCh2YWwuX2lkKTtcbiAgICB9XG4gIHJldHVybiBmcm9tSlMoZG9jdW1lbnRJZHNJbkJ1bmRsZSk7XG59O1xuc2FuaXR5LmRvY3VtZW50c09mLmFyaXR5ID0gMTtcbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBhc3luYyBmdW5jdGlvbihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAoYXdhaXQgITAsICFiYXNlLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgbWFwcGVycyA9IFtdLCBkaXJlY3Rpb25zID0gW107XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBtYXBwZXIudHlwZSA9PT0gXCJEZXNjXCIgPyAoZGlyZWN0aW9uID0gXCJkZXNjXCIsIG1hcHBlciA9IG1hcHBlci5iYXNlKSA6IG1hcHBlci50eXBlID09PSBcIkFzY1wiICYmIChtYXBwZXIgPSBtYXBwZXIuYmFzZSksIG1hcHBlcnMucHVzaChtYXBwZXIpLCBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKSwgbisrO1xuICB9XG4gIGNvbnN0IGF1eCA9IFtdO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpLCB0dXBsZSA9IFthd2FpdCB2YWx1ZS5nZXQoKSwgaWR4XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZShtYXBwZXJzW2ldLCBuZXdTY29wZSk7XG4gICAgICB0dXBsZS5wdXNoKGF3YWl0IHJlc3VsdC5nZXQoKSk7XG4gICAgfVxuICAgIGF1eC5wdXNoKHR1cGxlKSwgaWR4Kys7XG4gIH1cbiAgcmV0dXJuIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIiAmJiAoYyA9IC1jKSwgYyAhPT0gMClcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJldHVybiBhVHVwbGVbMV0gLSBiVHVwbGVbMV07XG4gIH0pLCBmcm9tSlMoYXV4Lm1hcCgodikgPT4gdlswXSkpO1xufTtcbnBpcGVGdW5jdGlvbnMub3JkZXIuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSBhc3luYyBmdW5jdGlvbihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgdW5rbm93biA9IFtdLCBzY29yZWQgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHVua25vd24ucHVzaChhd2FpdCB2YWx1ZS5nZXQoKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIGxldCB2YWx1ZVNjb3JlID0gdHlwZW9mIHZhbHVlLmRhdGEuX3Njb3JlID09IFwibnVtYmVyXCIgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncylcbiAgICAgIHZhbHVlU2NvcmUgKz0gYXdhaXQgZXZhbHVhdGVTY29yZShhcmcsIG5ld1Njb3BlLCBleGVjdXRlKTtcbiAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICB9XG4gIHJldHVybiBzY29yZWQuc29ydCgoYSwgYikgPT4gYi5fc2NvcmUgLSBhLl9zY29yZSksIGZyb21KUyhzY29yZWQpO1xufTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcbmNvbnN0IGRlbHRhID0ge307XG5kZWx0YS5vcGVyYXRpb24gPSBhc3luYyBmdW5jdGlvbihfYXJncywgc2NvcGUpIHtcbiAgY29uc3QgaGFzQmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgIT09IG51bGwsIGhhc0FmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciAhPT0gbnVsbDtcbiAgcmV0dXJuIGhhc0JlZm9yZSAmJiBoYXNBZnRlciA/IGZyb21TdHJpbmcoXCJ1cGRhdGVcIikgOiBoYXNBZnRlciA/IGZyb21TdHJpbmcoXCJjcmVhdGVcIikgOiBoYXNCZWZvcmUgPyBmcm9tU3RyaW5nKFwiZGVsZXRlXCIpIDogTlVMTF9WQUxVRTtcbn07XG5kZWx0YS5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGVsdGEuY2hhbmdlZEFueS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkQW55Lm1vZGUgPSBcImRlbHRhXCI7XG5kZWx0YS5jaGFuZ2VkT25seSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRPbmx5LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRPbmx5Lm1vZGUgPSBcImRlbHRhXCI7XG5jb25zdCBkaWZmID0ge307XG5kaWZmLmNoYW5nZWRBbnkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRBbnkuYXJpdHkgPSAzO1xuZGlmZi5jaGFuZ2VkT25seSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xuY29uc3QgbWF0aCA9IHt9O1xubWF0aC5taW4gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAobiA9PT0gdm9pZCAwIHx8IGVsZW0uZGF0YSA8IG4pICYmIChuID0gZWxlbS5kYXRhKTtcbiAgICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5taW4uYXJpdHkgPSAxO1xubWF0aC5tYXggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAobiA9PT0gdm9pZCAwIHx8IGVsZW0uZGF0YSA+IG4pICYmIChuID0gZWxlbS5kYXRhKTtcbiAgICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5tYXguYXJpdHkgPSAxO1xubWF0aC5zdW0gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBsZXQgbiA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgbiArPSBlbGVtLmRhdGE7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGguc3VtLmFyaXR5ID0gMTtcbm1hdGguYXZnID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG4gPSAwLCBjID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBuICs9IGVsZW0uZGF0YSwgYysrO1xuICAgIH1cbiAgcmV0dXJuIGMgPT09IDAgPyBOVUxMX1ZBTFVFIDogZnJvbUpTKG4gLyBjKTtcbn07XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5jb25zdCBkYXRlVGltZTIgPSB7fTtcbmRhdGVUaW1lMi5ub3cgPSBhc3luYyBmdW5jdGlvbihfYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21EYXRlVGltZShuZXcgRGF0ZVRpbWUoc2NvcGUuY29udGV4dC50aW1lc3RhbXApKTtcbn07XG5kYXRlVGltZTIubm93LmFyaXR5ID0gMDtcbmNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgc3RyaW5nOiBzdHJpbmcyLFxuICBhcnJheSxcbiAgcHQsXG4gIGRlbHRhLFxuICBkaWZmLFxuICBzYW5pdHksXG4gIG1hdGgsXG4gIGRhdGVUaW1lOiBkYXRlVGltZTJcbn07XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wJDIob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwic3RyaW5nXCIpLCBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJtYXJrc1wiKSwgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiaW5kZXhcIiksIF9fcHVibGljRmllbGQkMih0aGlzLCBcInBhcnNlT3B0aW9uc1wiKSwgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiYWxsb3dCb29zdFwiLCAhMSksIHRoaXMuc3RyaW5nID0gc3RyaW5nLCB0aGlzLm1hcmtzID0gbWFya3MsIHRoaXMuaW5kZXggPSAwLCB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbiAgfVxuICBoYXNNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xuICB9XG4gIGdldE1hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHttYXJrLm5hbWV9YCk7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbCh2aXNpdG9yLCB0aGlzLCBtYXJrKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KCksIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdLCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCgpLCB0aGlzLnN0cmluZy5zbGljZShwcmV2LnBvc2l0aW9uLCBjdXJyLnBvc2l0aW9uKTtcbiAgfVxuICBzbGljZShsZW4pIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdLnBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwb3MsIHBvcyArIGxlbik7XG4gIH1cbn1cbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvLCBOVU0gPSAvXlxcZCsvLCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiID8gcmVzdWx0IDogKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHBvcyAhPT0gc3RyLmxlbmd0aCA/IChyZXN1bHQuZmFpbFBvc2l0aW9uICYmIChwb3MgPSByZXN1bHQuZmFpbFBvc2l0aW9uIC0gMSksIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0pIDogKGRlbGV0ZSByZXN1bHQucG9zaXRpb24sIGRlbGV0ZSByZXN1bHQuZmFpbFBvc2l0aW9uLCByZXN1bHQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zLCB0b2tlbiA9IHN0cltwb3NdLCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwicG9zXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCItXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgOCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJuZWdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIihcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgc3dpdGNoIChwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pLCBzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgZm9yIChtYXJrcyA9IFt7IG5hbWU6IFwidHVwbGVcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTsgOyApIHtcbiAgICAgICAgICAgIGlmIChyaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApLCByaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcInR1cGxlX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIpXCI6IHtcbiAgICAgICAgICBwb3MrKywgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIGlmIChtYXJrcyA9IFt7IG5hbWU6IFwiYXJyYXlcIiwgcG9zaXRpb246IHBvcyB9XSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIgJiYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKTtcbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlcztcbiAgICAgICAgICBpZiAobWFya3MgPSBtYXJrcy5jb25jYXQocmVzLm1hcmtzKSwgcG9zID0gcmVzLnBvc2l0aW9uLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIsXCIgfHwgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJdXCIpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIilcbiAgICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJeXCI6IHtcbiAgICAgIGZvciAocG9zKyssIG1hcmtzID0gW107IHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiOyApXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImRibHBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyArPSAyO1xuICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwicGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiQFwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInRoaXNcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLCBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiRcIjoge1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcbiAgICAgIGlkZW50TGVuICYmIChwb3MgKz0gMSArIGlkZW50TGVuLCBtYXJrcyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInBhcmFtXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zICsgMSB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgXSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGZyYWNMZW4gJiYgKG5hbWUgPSBcImZsb2F0XCIsIHBvcyArPSAxICsgZnJhY0xlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcImVcIiB8fCBzdHJbcG9zXSA9PT0gXCJFXCIpIHtcbiAgICAgICAgICBuYW1lID0gXCJzY2lcIiwgcG9zKyssIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSAmJiBwb3MrKztcbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zICs9IGV4cExlbjtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICB7IG5hbWUsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogbmFtZSArIFwiX2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgc3dpdGNoIChwb3MgKz0gaWRlbnRMZW4sIHN0cltwb3NdKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICBjYXNlIFwiKFwiOiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiBcInRoaXNfYXR0clwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFtYXJrcylcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgbGV0IGxoc0xldmVsID0gMTIsIHRyYXY7XG4gIGxvb3A6IGZvciAoOyA7ICkge1xuICAgIGxldCBpbm5lclBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBwb3MgPSBpbm5lclBvcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgaW5uZXJQb3MpLCB0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICBmb3IgKG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInRyYXZlcnNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTsgdHJhdi50eXBlID09PSBcInN1Y2Nlc3NcIjsgKVxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKSwgcG9zID0gdHJhdi5wb3NpdGlvbiwgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgc2tpcFdTKHN0ciwgcG9zKSk7XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJbaW5uZXJQb3NdKSB7XG4gICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgIHN3aXRjaCAoc3RyW2lubmVyUG9zICsgMV0pIHtcbiAgICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiAxIHx8IGxoc0xldmVsIDw9IDEpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBhaXJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFkZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInN1YlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIqXCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcIipcIikge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDggfHwgbGhzTGV2ZWwgPD0gOCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzMiA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDgpO1xuICAgICAgICAgIGlmIChyaHMyLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJoczI7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBvd1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJoczIucG9zaXRpb24sIGxoc0xldmVsID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibXVsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIi9cIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGl2XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIiVcIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibW9kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgc3RyW25leHRQb3NdID09PSBcIj1cIiAmJiBuZXh0UG9zKys7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgNSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcInxcIikge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDIgfHwgbGhzTGV2ZWwgPCAyKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCAzKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJvclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDExIHx8IGxoc0xldmVsIDwgMTEpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICBpZiAoIWlkZW50TGVuKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9O1xuICAgICAgICAgIGlmIChwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuLCBzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIGlkZW50UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwaXBlY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAxMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiJlwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPSBcIiZcIiB8fCBsZXZlbCA+IDMgfHwgbGhzTGV2ZWwgPCAzKSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhbmRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiIVwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZFwiOiB7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRlc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSBpbm5lclBvcyArIDQsIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgMykgIT09IFwiYXNjXCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDwgNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gaW5uZXJQb3MgKyAzLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3dpdGNoIChwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKSkge1xuICAgICAgICAgIGNhc2UgXCJpblwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpO1xuICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSAhMTtcbiAgICAgICAgICAgIHN0cltwb3NdID09PSBcIihcIiAmJiAoaXNHcm91cCA9ICEwLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSk7XG4gICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3MsIHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgNSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgICAgICAgIHN0cltwb3MgKyAyXSA9PT0gXCIuXCIgPyAodHlwZSA9IFwiZXhjX3JhbmdlXCIsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKSA6IHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCA1KTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImluX3JhbmdlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiKVwiKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm1hdGNoXCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCA1KTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDUgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBmYWlsUG9zaXRpb24gPSAodHJhdiA9PSBudWxsID8gdm9pZCAwIDogdHJhdi50eXBlKSA9PT0gXCJlcnJvclwiICYmIHRyYXYucG9zaXRpb247XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcywgZmFpbFBvc2l0aW9uIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYXZlcnNhbChzdHIsIHBvcykge1xuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLlwiOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zLCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICByZXR1cm4gaWRlbnRMZW4yID8gKHBvcyArPSBpZGVudExlbjIsIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgeyBuYW1lOiBcImF0dHJfYWNjZXNzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRTdGFydCB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH0pIDogeyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICB9XG4gICAgY2FzZSBcIi1cIjpcbiAgICAgIGlmIChzdHJbcG9zICsgMV0gIT09IFwiPlwiKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwiZGVyZWZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgcmV0dXJuIGlkZW50TGVuICYmIChwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuLCBtYXJrcy5wdXNoKFxuICAgICAgICB7IG5hbWU6IFwiZGVyZWZfYXR0clwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgKSksIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcImFycmF5X3Bvc3RmaXhcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgIH07XG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3MsIHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgIHN0cltwb3MgKyAyXSA9PT0gXCIuXCIgPyAodHlwZSA9IFwiZXhjX3JhbmdlXCIsIHBvcyArPSAzKSA6IHBvcyArPSAyLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgcmV0dXJuIHJocy50eXBlID09PSBcImVycm9yXCIgPyByaHMgOiAocG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiXVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNsaWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfVxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJbcG9zXSAhPT0gXCJdXCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9IDoge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwic3F1YXJlX2JyYWNrZXRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInxcIjoge1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgfHwgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCByZXN1bHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIHx8IHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBpZiAobWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19jYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJuYW1lc3BhY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICBsZXQgbmFtZUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICBpZiAoIW5hbWVMZW4pIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIGlmIChtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogcG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyArIG5hbWVMZW4gfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pLCBzdHJbcG9zXSAhPT0gXCIoXCIpIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIHBvcysrLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICB9IGVsc2VcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgbGV0IGxhc3RQb3MgPSBwb3M7XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyksIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb24sIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIixcIiB8fCAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIilcIikpIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIHN0cltwb3NdICE9PSBcIilcIiA/IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0gOiAobWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19hcmdzX2VuZFwiLCBwb3NpdGlvbjogbGFzdFBvcyB9KSwge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qoc3RyLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW3sgbmFtZTogXCJvYmplY3RcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgZm9yIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTsgc3RyW3Bvc10gIT09IFwifVwiOyApIHtcbiAgICBsZXQgcGFpclBvcyA9IHBvcztcbiAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpXG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyksIHN0cltwb3NdICE9PSBcIn1cIiAmJiBzdHJbcG9zXSAhPT0gXCIsXCIpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRcIiwgcG9zaXRpb246IHBhaXJQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MpLCBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdF90aGlzXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gZXhwcjtcbiAgICAgIGxldCBuZXh0UG9zID0gc2tpcFdTKHN0ciwgZXhwci5wb3NpdGlvbik7XG4gICAgICBpZiAoZXhwci5tYXJrc1swXS5uYW1lID09PSBcInN0clwiICYmIHN0cltuZXh0UG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHZhbHVlO1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfcGFpclwiLCBwb3NpdGlvbjogcGFpclBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcywgdmFsdWUubWFya3MpLCBwb3MgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKSwgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICB9XG4gICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cbiAgcmV0dXJuIHN0cltwb3NdICE9PSBcIn1cIiA/IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0gOiAocG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgeyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIsIHBvcykge1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgcG9zID0gcG9zICsgMTtcbiAgY29uc3QgbWFya3MgPSBbeyBuYW1lOiBcInN0clwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBzdHI6IGZvciAoOyA7IHBvcysrKSB7XG4gICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MrKztcbiAgICAgICAgYnJlYWsgc3RyO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3BhdXNlXCIsIHBvc2l0aW9uOiBwb3MgfSksIHN0cltwb3MgKyAxXSA9PT0gXCJ1XCIgPyBzdHJbcG9zICsgMl0gPT09IFwie1wiID8gKG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAzIH0pLCBwb3MgPSBzdHIuaW5kZXhPZihcIn1cIiwgcG9zICsgMyksIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pKSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleFwiLCBwb3NpdGlvbjogcG9zICsgMiB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyA2IH0pLCBwb3MgKz0gNSkgOiAobWFya3MucHVzaCh7IG5hbWU6IFwic2luZ2xlX2VzY2FwZVwiLCBwb3NpdGlvbjogcG9zICsgMSB9KSwgcG9zICs9IDEpLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfc3RhcnRcIiwgcG9zaXRpb246IHBvcyArIDEgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiBiKGEoYmFzZSkpO1xufVxuZnVuY3Rpb24gbWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcbn1cbmZ1bmN0aW9uIGZsYXRNYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIkZsYXRNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlQXJyYXkoYnVpbGQsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICBidWlsZFxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIGZsYXRNYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb2plY3Rpb24obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuY29uc3QgRVNDQVBFX1NFUVVFTkNFID0ge1xuICBcIidcIjogXCInXCIsXG4gICdcIic6ICdcIicsXG4gIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgXCIvXCI6IFwiL1wiLFxuICBiOiBcIlxcYlwiLFxuICBmOiBcIlxcZlwiLFxuICBuOiBgXG5gLFxuICByOiBcIlxcclwiLFxuICB0OiBcIlx0XCJcbn07XG5mdW5jdGlvbiBleHBhbmRIZXgoc3RyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbmNsYXNzIEdyb3FRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJuYW1lXCIsIFwiR3JvcVF1ZXJ5RXJyb3JcIik7XG4gIH1cbn1cbmNvbnN0IEVYUFJfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJFdmVyeXRoaW5nXCIgfTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIlRoaXNcIiB9O1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiAxXG4gICAgfTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLm4gKyAxXG4gICAgfTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgdHJhdmVyc2FsTGlzdC5wdXNoKHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKSk7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgIGlmICgoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpICYmICh0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KCh2YWwpID0+IHZhbCwgdHJhdmVyc2FsKSksIHRyYXZlcnNhbCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gbmFtZSA9PT0gXCJudWxsXCIgPyB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfSA6IG5hbWUgPT09IFwidHJ1ZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMCB9IDogbmFtZSA9PT0gXCJmYWxzZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMSB9IDoge1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9LFxuICBuZWcocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBwb3MocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvc1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBhZGQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIitcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiLVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBkaXYocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi9cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiJVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBvcCA9IHAucHJvY2Vzc1N0cmluZygpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3AsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9O1xuICB9LFxuICBzdHIocCkge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbG9vcDogZm9yICg7IHAuaGFzTWFyaygpOyApIHtcbiAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOiB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHAuc2xpY2UoMSk7XG4gICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBleHBhbmRIZXgocC5wcm9jZXNzU3RyaW5nRW5kKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBtYXJrOiAke21hcmsubmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9O1xuICB9LFxuICBpbnRlZ2VyKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBvYmplY3QocCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJvYmplY3RfZW5kXCI7IClcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIk9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImFycmF5X2VuZFwiOyApIHtcbiAgICAgIGxldCBpc1NwbGF0ID0gITE7XG4gICAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIgJiYgKGlzU3BsYXQgPSAhMCwgcC5zaGlmdCgpKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICBlbGVtZW50c1xuICAgIH07XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCI7IClcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gIH0sXG4gIGZ1bmNfY2FsbChwKSB7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIlNlbGVjdFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICB9O1xuICAgICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiOyApXG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5hbHRlcm5hdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlNlbGVjdEFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHAuc2hpZnQoKSwgcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiOyApXG4gICAgICBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBuYW1lLCBhcmdzLmxlbmd0aCkgPyAocC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpLCBhcmdzLnB1c2goeyB0eXBlOiBcIlNlbGVjdG9yXCIgfSkpIDogYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICBpZiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSAmJiBwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkNvbnRleHRcIixcbiAgICAgICAga2V5OiBuYW1lXG4gICAgICB9O1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJib29zdFwiICYmICFwLmFsbG93Qm9vc3QpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0XCIpO1xuICAgIGNvbnN0IGZ1bmNzID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VdO1xuICAgIGlmICghZnVuY3MpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xuICAgIGNvbnN0IGZ1bmMgPSBmdW5jc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIGlmIChmdW5jLmFyaXR5ICE9PSB2b2lkIDAgJiYgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCksIGZ1bmMubW9kZSAhPT0gdm9pZCAwICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSlcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiICYmIChwLnNoaWZ0KCksIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpKSwgbmFtZXNwYWNlICE9PSBcImdsb2JhbFwiKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCksIGFyZ3MgPSBbXSwgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcbiAgICBmb3IgKG5hbWUgPT09IFwic2NvcmVcIiAmJiAocC5hbGxvd0Jvb3N0ID0gITApOyA7ICkge1xuICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAobmFtZSA9PT0gXCJvcmRlclwiKSB7XG4gICAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJhc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKSwgYXJncy5wdXNoKHsgdHlwZTogXCJBc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWFya05hbWUgPT09IFwiZGVzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpLCBhcmdzLnB1c2goeyB0eXBlOiBcIkRlc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKSwgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcbiAgICBjb25zdCBmdW5jID0gcGlwZUZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBwaXBlIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgcmV0dXJuIGZ1bmMuYXJpdHkgJiYgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCksIHtcbiAgICAgIHR5cGU6IFwiUGlwZUZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgYmFzZSxcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzXG4gICAgfTtcbiAgfSxcbiAgcGFpcigpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBbmRcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG9yKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3JcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTm90XCIsXG4gICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIGFzYygpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFzY1wiKTtcbiAgfSxcbiAgZGVzYygpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogcC5wYXJzZU9wdGlvbnMucGFyYW1zW25hbWVdXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxufSwgT0JKRUNUX0JVSUxERVIgPSB7XG4gIG9iamVjdF9leHByKHApIHtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZTIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiLFxuICAgICAgICBjb25kaXRpb24sXG4gICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IGV4dHJhY3RQcm9wZXJ0eUtleSh2YWx1ZSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9wYWlyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgaWYgKG5hbWUudHlwZSAhPT0gXCJWYWx1ZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdF90aGlzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZTogeyB0eXBlOiBcIlRoaXNcIiB9XG4gICAgfTtcbiAgfVxufSwgVFJBVkVSU0VfQlVJTERFUiA9IHtcbiAgc3F1YXJlX2JyYWNrZXQocCkge1xuICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIm51bWJlclwiID8gKHJpZ2h0KSA9PiB0cmF2ZXJzZUVsZW1lbnQoKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzRWxlbWVudFwiLCBiYXNlLCBpbmRleDogdmFsdWUuZGF0YSB9KSwgcmlnaHQpIDogdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIiA/IChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogdmFsdWUuZGF0YSB9KSwgcmlnaHQpIDogKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KFxuICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiRmlsdGVyXCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGV4cHJcbiAgICAgIH0pLFxuICAgICAgcmlnaHRcbiAgICApO1xuICB9LFxuICBzbGljZShwKSB7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCksIHJpZ2h0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKHJpZ2h0KTtcbiAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XG4gICAgcmV0dXJuIChyaHMpID0+IHRyYXZlcnNlQXJyYXkoXG4gICAgICAoYmFzZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJTbGljZVwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUuZGF0YSxcbiAgICAgICAgaXNJbmNsdXNpdmVcbiAgICAgIH0pLFxuICAgICAgcmhzXG4gICAgKTtcbiAgfSxcbiAgcHJvamVjdGlvbihwKSB7XG4gICAgY29uc3Qgb2JqID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKChiYXNlKSA9PiAoeyB0eXBlOiBcIlByb2plY3Rpb25cIiwgYmFzZSwgZXhwcjogb2JqIH0pLCByaWdodCk7XG4gIH0sXG4gIGF0dHJfYWNjZXNzKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZSB9KSwgcmlnaHQpO1xuICB9LFxuICBkZXJlZihwKSB7XG4gICAgbGV0IGF0dHIgPSBudWxsO1xuICAgIHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiICYmIChwLnNoaWZ0KCksIGF0dHIgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgY29uc3Qgd3JhcCA9IChiYXNlKSA9PiBhdHRyID8geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oXG4gICAgICAoYmFzZSkgPT4gd3JhcCh7XG4gICAgICAgIHR5cGU6IFwiRGVyZWZcIixcbiAgICAgICAgYmFzZVxuICAgICAgfSksXG4gICAgICByaWdodFxuICAgICk7XG4gIH0sXG4gIGFycmF5X3Bvc3RmaXgoKSB7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHsgdHlwZTogXCJBcnJheUNvZXJjZVwiLCBiYXNlIH0pLCByaWdodCk7XG4gIH1cbn0sIFNFTEVDVE9SX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICByZXR1cm4gcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpLCBudWxsO1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0aGlzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRibHBhcmVudCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGZvciAocC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgcC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpO1xuICAgIHJldHVybiBwLnNoaWZ0KCksIG51bGw7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgcmV0dXJuIHAucHJvY2Vzc1N0cmluZygpLCBudWxsO1xuICB9LFxuICBuZWcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYWRkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzdWIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG11bCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGl2KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBtb2QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvdygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgY29tcCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW5fcmFuZ2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN0cigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW50ZWdlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZmxvYXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHNjaSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb2JqZWN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhcnJheSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZ1bmNfY2FsbChwLCBtYXJrKSB7XG4gICAgY29uc3QgZnVuYyA9IEVYUFJfQlVJTERFUi5mdW5jX2NhbGwocCwgbWFyayk7XG4gICAgaWYgKGZ1bmMubmFtZSA9PT0gXCJhbnl3aGVyZVwiICYmIGZ1bmMuYXJncy5sZW5ndGggPT09IDEpIHJldHVybiBudWxsO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwaXBlY2FsbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFpcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYW5kKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbm90KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhc2MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRlc2MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhcmFtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9XG59O1xuZnVuY3Rpb24gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NBdHRyaWJ1dGVcIiAmJiAhbm9kZS5iYXNlKVxuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIilcbiAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQpIHtcbiAgaWYgKHR5cGVvZiBhcml0eSA9PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGNvdW50ICE9PSBhcml0eSlcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcbiAgICAgICAgYEluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uICR7bmFtZX0oKS4gRXhwZWN0ZWQgJHthcml0eX0sIGdvdCAke2NvdW50fS5gXG4gICAgICApO1xuICB9IGVsc2UgaWYgKGFyaXR5ICYmICFhcml0eShjb3VudCkpXG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuYCk7XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gIGNvbnN0IGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFtcImNoYW5nZWRBbnlcIiwgXCJjaGFuZ2VkT25seVwiXTtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PSBcImRpZmZcIiAmJiBhcmdDb3VudCA9PSAyICYmIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycy5pbmNsdWRlcyhmdW5jdGlvbk5hbWUpO1xufVxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHN1cGVyKGBTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiAke3Bvc2l0aW9ufWApLCBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJwb3NpdGlvblwiKSwgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibmFtZVwiLCBcIkdyb3FTeW50YXhFcnJvclwiKSwgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlJDEoaW5wdXQpO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gIHJldHVybiBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKS5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59XG5jb25zdCB7IGNvbXBhcmUgfSA9IG5ldyBJbnRsLkNvbGxhdG9yKFwiZW5cIik7XG5mdW5jdGlvbiB0eXBlTm9kZXNTb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYS50eXBlID09PSBcIm51bGxcIiA/IDEgOiBjb21wYXJlKGhhc2hGaWVsZChhKSwgaGFzaEZpZWxkKGIpKTtcbn1cbmZ1bmN0aW9uIGhhc2hGaWVsZChmaWVsZCkge1xuICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gZmllbGQudmFsdWUgIT09IHZvaWQgMCA/IGAke2ZpZWxkLnR5cGV9KCR7ZmllbGQudmFsdWV9KWAgOiBgJHtmaWVsZC50eXBlfWA7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIGZpZWxkLnR5cGU7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGQudHlwZX0oJHtoYXNoRmllbGQoZmllbGQub2YpfSlgO1xuICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuc29ydCgoW2FdLCBbYl0pID0+IGNvbXBhcmUoYSwgYikpLCBgJHtmaWVsZC50eXBlfTooJHthdHRyaWJ1dGVzLm1hcChcbiAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke2hhc2hGaWVsZCh2YWx1ZS52YWx1ZSl9KCR7dmFsdWUub3B0aW9uYWwgPyBcIm9wdGlvbmFsXCIgOiBcIm5vbi1vcHRpb25hbFwifSlgXG4gICAgICApLmpvaW4oXCIsXCIpfSk6cmVmLSR7ZmllbGQuZGVyZWZlcmVuY2VzVG99OiR7ZmllbGQucmVzdCA/IGhhc2hGaWVsZChmaWVsZC5yZXN0KSA6IFwibm8tcmVzdFwifWA7XG4gICAgfVxuICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uZmllbGQub2ZdO1xuICAgICAgcmV0dXJuIHNvcnRlZC5zb3J0KHR5cGVOb2Rlc1NvcnRlciksIGAke2ZpZWxkLnR5cGV9KCR7c29ydGVkLm1hcChoYXNoRmllbGQpLmpvaW4oXCIsXCIpfSlgO1xuICAgIH1cbiAgICBjYXNlIFwiaW5saW5lXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGQudHlwZX0oJHtmaWVsZC5uYW1lfSlgO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmllbGQudHlwZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlVHlwZU5vZGVzKHR5cGVOb2Rlcykge1xuICBjb25zdCBzZWVuVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuZXdUeXBlTm9kZXMgPSBbXSwgc29ydGVkVHlwZU5vZGVzID0gWy4uLnR5cGVOb2Rlc107XG4gIHNvcnRlZFR5cGVOb2Rlcy5zb3J0KHR5cGVOb2Rlc1NvcnRlcik7XG4gIGZvciAoY29uc3QgdHlwZU5vZGUgb2Ygc29ydGVkVHlwZU5vZGVzKSB7XG4gICAgY29uc3QgaGFzaCA9IGhhc2hGaWVsZCh0eXBlTm9kZSk7XG4gICAgaWYgKGhhc2ggPT09IG51bGwpIHtcbiAgICAgIG5ld1R5cGVOb2Rlcy5wdXNoKHR5cGVOb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzZWVuVHlwZXMuaGFzKGhhc2gpIHx8IChzZWVuVHlwZXMuYWRkKGhhc2gpLCBuZXdUeXBlTm9kZXMucHVzaCh0eXBlTm9kZSkpO1xuICB9XG4gIHJldHVybiBuZXdUeXBlTm9kZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZVVuaW9ucyhmaWVsZCkge1xuICBpZiAoZmllbGQudHlwZSA9PT0gXCJ1bmlvblwiKSB7XG4gICAgaWYgKGZpZWxkLm9mLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBmaWVsZDtcbiAgICBpZiAoZmllbGQub2YgPSByZW1vdmVEdXBsaWNhdGVUeXBlTm9kZXMoZmllbGQub2YpLCBmaWVsZC5vZi5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gb3B0aW1pemVVbmlvbnMoZmllbGQub2ZbMF0pO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGZpZWxkLm9mLmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IHN1YkZpZWxkID0gZmllbGQub2ZbaWR4XTtcbiAgICAgIGlmIChzdWJGaWVsZC50eXBlID09PSBcInVuaW9uXCIpIHtcbiAgICAgICAgZmllbGQub2Yuc3BsaWNlKGlkeCwgMSwgLi4uc3ViRmllbGQub2YpLCBpZHgtLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZC5vZltpZHhdID0gb3B0aW1pemVVbmlvbnMoc3ViRmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQub2Yuc29ydCgoYSwgYikgPT4gYS50eXBlID09PSBcIm51bGxcIiA/IDEgOiBjb21wYXJlKGhhc2hGaWVsZChhKSwgaGFzaEZpZWxkKGIpKSksIGZpZWxkO1xuICB9XG4gIGlmIChmaWVsZC50eXBlID09PSBcImFycmF5XCIpXG4gICAgcmV0dXJuIGZpZWxkLm9mID0gb3B0aW1pemVVbmlvbnMoZmllbGQub2YpLCBmaWVsZDtcbiAgaWYgKGZpZWxkLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBmb3IgKGNvbnN0IGlkeCBpbiBmaWVsZC5hdHRyaWJ1dGVzKVxuICAgICAgT2JqZWN0Lmhhc093bihmaWVsZC5hdHRyaWJ1dGVzLCBpZHgpICYmIChmaWVsZC5hdHRyaWJ1dGVzW2lkeF0udmFsdWUgPSBvcHRpbWl6ZVVuaW9ucyhmaWVsZC5hdHRyaWJ1dGVzW2lkeF0udmFsdWUpKTtcbiAgICByZXR1cm4gZmllbGQ7XG4gIH1cbiAgcmV0dXJuIGZpZWxkO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlVHlwZU5vZGUobmFtZSwgaW5BcnJheSA9ICExKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgX3JlZjoge1xuICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIF90eXBlOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IFwicmVmZXJlbmNlXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIF93ZWFrOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgIH0sXG4gICAgICBvcHRpb25hbDogITBcbiAgICB9XG4gIH07XG4gIHJldHVybiBpbkFycmF5ICYmIChhdHRyaWJ1dGVzLl9rZXkgPSB7XG4gICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgIH1cbiAgfSksIHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgZGVyZWZlcmVuY2VzVG86IG5hbWVcbiAgfTtcbn1cbmZ1bmN0aW9uIG51bGxVbmlvbihub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwidW5pb25cIiA/IHVuaW9uT2YoLi4ubm9kZS5vZiwgeyB0eXBlOiBcIm51bGxcIiB9KSA6IHVuaW9uT2Yobm9kZSwgeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIHVuaW9uT2YoLi4ubm9kZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IG5vZGVzXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlSW5saW5lKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICBjb25zdCByZXNvbHZlZElubGluZSA9IHNjb3BlLmNvbnRleHQubG9va3VwVHlwZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIHJldHVybiByZXNvbHZlSW5saW5lKHJlc29sdmVkSW5saW5lLCBzY29wZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBtYXBOb2RlKG5vZGUsIHNjb3BlLCBtYXBwZXIsIG1lcmdlVW5pb25zID0gKG5vZGVzKSA9PiBvcHRpbWl6ZVVuaW9ucyh7IHR5cGU6IFwidW5pb25cIiwgb2Y6IG5vZGVzIH0pKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJ1bmtub3duXCI6XG4gICAgICByZXR1cm4gbWFwcGVyKG5vZGUpO1xuICAgIGNhc2UgXCJ1bmlvblwiOlxuICAgICAgcmV0dXJuIG1lcmdlVW5pb25zKG5vZGUub2YubWFwKChpbm5lcikgPT4gbWFwTm9kZShpbm5lciwgc2NvcGUsIG1hcHBlciksIG1lcmdlVW5pb25zKSk7XG4gICAgY2FzZSBcImlubGluZVwiOiB7XG4gICAgICBjb25zdCByZXNvbHZlZElubGluZSA9IHJlc29sdmVJbmxpbmUobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIG1hcE5vZGUocmVzb2x2ZWRJbmxpbmUsIHNjb3BlLCBtYXBwZXIsIG1lcmdlVW5pb25zKTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlOiAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jQ2FsbChub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiR3JvdXBcIiA/IGlzRnVuY0NhbGwobm9kZS5iYXNlLCBuYW1lKSA6IG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIGAke25vZGUubmFtZXNwYWNlfTo6JHtub2RlLm5hbWV9YCA9PT0gbmFtZTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5WYWx1ZShub2RlLCBzY29wZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJ1bmtub3duXCI6XG4gICAgICByZXR1cm4geyBjYW5CZVRydWU6ICEwLCBjYW5CZUZhbHNlOiAhMCwgY2FuQmVOdWxsOiAhMCB9O1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZSA9PT0gITAgPyB7IGNhbkJlVHJ1ZTogITAsIGNhbkJlRmFsc2U6ICExLCBjYW5CZU51bGw6ICExIH0gOiBub2RlLnZhbHVlID09PSAhMSA/IHsgY2FuQmVUcnVlOiAhMSwgY2FuQmVGYWxzZTogITAsIGNhbkJlTnVsbDogITEgfSA6IHsgY2FuQmVUcnVlOiAhMCwgY2FuQmVGYWxzZTogITAsIGNhbkJlTnVsbDogITEgfTtcbiAgICBjYXNlIFwidW5pb25cIjoge1xuICAgICAgY29uc3QgdmFsdWUgPSB7IGNhbkJlVHJ1ZTogITEsIGNhbkJlRmFsc2U6ICExLCBjYW5CZU51bGw6ICExIH07XG4gICAgICBmb3IgKGNvbnN0IHN1YiBvZiBub2RlLm9mKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoMiA9IGJvb2xlYW5WYWx1ZShzdWIsIHNjb3BlKTtcbiAgICAgICAgbWF0Y2gyLmNhbkJlTnVsbCAmJiAodmFsdWUuY2FuQmVOdWxsID0gITApLCBtYXRjaDIuY2FuQmVUcnVlICYmICh2YWx1ZS5jYW5CZVRydWUgPSAhMCksIG1hdGNoMi5jYW5CZUZhbHNlICYmICh2YWx1ZS5jYW5CZUZhbHNlID0gITApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjYXNlIFwiaW5saW5lXCI6IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUlubGluZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gYm9vbGVhblZhbHVlKHJlc29sdmVkLCBzY29wZSk7XG4gICAgfVxuICAgIGNhc2UgXCJudWxsXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4geyBjYW5CZVRydWU6ICExLCBjYW5CZUZhbHNlOiAhMSwgY2FuQmVOdWxsOiAhMCB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gbm9kZSB0eXBlICR7bm9kZS50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiBib29sZWFuT3IobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGxlZnQuY2FuQmVUcnVlICYmICFsZWZ0LmNhbkJlRmFsc2UgJiYgIWxlZnQuY2FuQmVOdWxsID8gbGVmdCA6IHJpZ2h0LmNhbkJlVHJ1ZSAmJiAhcmlnaHQuY2FuQmVGYWxzZSAmJiAhcmlnaHQuY2FuQmVOdWxsID8gcmlnaHQgOiB7XG4gICAgLy8gRWl0aGVyIHNpZGUgY2FuIGJlIHRydWUgZm9yIHRoZSBleHByZXNzaW9uIHRvIGJlIHRydWVcbiAgICBjYW5CZVRydWU6IGxlZnQuY2FuQmVUcnVlIHx8IHJpZ2h0LmNhbkJlVHJ1ZSxcbiAgICAvLyBCb3RoIHNpZGVzIG11c3QgYmUgZmFsc2UgZm9yIHRoZSBleHByZXNzaW9uIHRvIGJlIGZhbHNlXG4gICAgY2FuQmVGYWxzZTogbGVmdC5jYW5CZUZhbHNlICYmIHJpZ2h0LmNhbkJlRmFsc2UsXG4gICAgLy8gaWYgZWl0aGVyIHNpZGUgY2FuIGJlIG51bGwsIHRoZSBleHByZXNzaW9uIGNhbiBiZSBudWxsIGlmIHRoZSBvdGhlciBzaWRlIGNhbid0IG9ubHkgYmUgdHJ1ZVxuICAgIGNhbkJlTnVsbDogbGVmdC5jYW5CZU51bGwgfHwgcmlnaHQuY2FuQmVOdWxsXG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuQW5kKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0LmNhbkJlRmFsc2UgJiYgIWxlZnQuY2FuQmVUcnVlICYmICFsZWZ0LmNhbkJlTnVsbCA/IGxlZnQgOiByaWdodC5jYW5CZUZhbHNlICYmICFyaWdodC5jYW5CZVRydWUgJiYgIXJpZ2h0LmNhbkJlTnVsbCA/IHJpZ2h0IDoge1xuICAgIC8vIEJvdGggc2lkZXMgbXVzdCBiZSB0cnVlIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSB0cnVlXG4gICAgY2FuQmVUcnVlOiBsZWZ0LmNhbkJlVHJ1ZSAmJiByaWdodC5jYW5CZVRydWUsXG4gICAgLy8gaWYgZWl0aGVyIHNpZGUgY2FuIGJlIGZhbHNlLCB0aGUgZXhwcmVzc2lvbiBjYW4gYmUgZmFsc2VcbiAgICBjYW5CZUZhbHNlOiBsZWZ0LmNhbkJlRmFsc2UgfHwgcmlnaHQuY2FuQmVGYWxzZSxcbiAgICAvLyBpZiBlaXRoZXIgc2lkZSBjYW4gYmUgbnVsbCwgdGhlIGV4cHJlc3Npb24gY2FuIGJlIG51bGxcbiAgICBjYW5CZU51bGw6IGxlZnQuY2FuQmVOdWxsIHx8IHJpZ2h0LmNhbkJlTnVsbFxuICB9O1xufVxuZnVuY3Rpb24gYm9vbGVhbkludGVycHJldGF0aW9uVG9UeXBlTm9kZShib29sKSB7XG4gIHJldHVybiBib29sLmNhbkJlVHJ1ZSA/IGJvb2wuY2FuQmVGYWxzZSA/IGJvb2wuY2FuQmVOdWxsID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiBib29sLmNhbkJlTnVsbCA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITAgfSkgOiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITAgfSA6IGJvb2wuY2FuQmVGYWxzZSA/IGJvb2wuY2FuQmVOdWxsID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiAhMSB9KSA6IHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiAhMSB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xufVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5jb25zdCAkdHJhY2UkMSA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpzY29wZTp0cmFjZVwiKTtcbiR0cmFjZSQxLmxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5jbGFzcyBDb250ZXh0IHtcbiAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNjaGVtYVwiKSwgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIH1cbiAgbG9va3VwUmVmKHJlZlRvKSB7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5zY2hlbWEpXG4gICAgICBpZiAodmFsLnR5cGUgPT09IFwiZG9jdW1lbnRcIiAmJiB2YWwubmFtZSA9PT0gcmVmVG8pXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB2YWwuYXR0cmlidXRlc1xuICAgICAgICB9O1xuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIH1cbiAgbG9va3VwVHlwZURlY2xhcmF0aW9uKGFsaWFzKSB7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5zY2hlbWEpXG4gICAgICBpZiAodmFsLnR5cGUgPT09IFwidHlwZVwiICYmIHZhbC5uYW1lID09PSBhbGlhcy5uYW1lKVxuICAgICAgICByZXR1cm4gdmFsLnZhbHVlO1xuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIH1cbn1cbmNsYXNzIFNjb3BlMiB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVcIiksIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJlbnRcIiksIF9fcHVibGljRmllbGQodGhpcywgXCJjb250ZXh0XCIpLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNIaWRkZW5cIiksIHRoaXMudmFsdWUgPSB7IHR5cGU6IFwidW5pb25cIiwgb2Y6IHZhbHVlIH0sIHRoaXMucGFyZW50ID0gcGFyZW50LCB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IChwYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudC5jb250ZXh0KSB8fCBuZXcgQ29udGV4dChbXSksIHRoaXMuaXNIaWRkZW4gPSAhMTtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hpZGRlbiA/IG5ldyBTY29wZTIodmFsdWUsIHRoaXMucGFyZW50LCB0aGlzLmNvbnRleHQpIDogbmV3IFNjb3BlMih2YWx1ZSwgdGhpcywgdGhpcy5jb250ZXh0KTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5pc0hpZGRlbiA9ICEwLCByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuaW9uV2l0aG91dE51bGwodW5pb25UeXBlTm9kZSkge1xuICByZXR1cm4gdW5pb25UeXBlTm9kZS50eXBlID09PSBcInVuaW9uXCIgPyB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiB1bmlvblR5cGVOb2RlLm9mLmZpbHRlcigodHlwZSkgPT4gdHlwZS50eXBlICE9PSBcIm51bGxcIilcbiAgfSA6IHVuaW9uVHlwZU5vZGU7XG59XG5mdW5jdGlvbiBoYW5kbGVGdW5jQ2FsbE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChgJHtub2RlLm5hbWVzcGFjZX0uJHtub2RlLm5hbWV9YCkge1xuICAgIGNhc2UgXCJhcnJheS5jb21wYWN0XCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IHtcbiAgICAgICAgaWYgKGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJ1bmtub3duXCIgfSB9KTtcbiAgICAgICAgaWYgKGFyZzIudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgIGNvbnN0IG9mID0gbWFwTm9kZShhcmcyLm9mLCBzY29wZSwgKG9mMikgPT4gb2YyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgb2Y6IHVuaW9uV2l0aG91dE51bGwob2YpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LmpvaW5cIjoge1xuICAgICAgY29uc3QgYXJyYXlBcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgc2VwQXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgICAgYXJyYXlBcmcsXG4gICAgICAgIHNjb3BlLFxuICAgICAgICAoYXJyYXlBcmcyKSA9PiBtYXBOb2RlKHNlcEFyZywgc2NvcGUsIChzZXBBcmcyKSA9PiBhcnJheUFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgc2VwQXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcnJheUFyZzIudHlwZSAhPT0gXCJhcnJheVwiIHx8IHNlcEFyZzIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUoYXJyYXlBcmcyLm9mLCBzY29wZSwgKG9mKSA9PiBvZi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBvZi50eXBlICE9PSBcInN0cmluZ1wiICYmIG9mLnR5cGUgIT09IFwibnVtYmVyXCIgJiYgb2YudHlwZSAhPT0gXCJib29sZWFuXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSkpXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXkudW5pcXVlXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwidW5rbm93blwiIH0gfSkgOiBhcmcyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGFyZzIpO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmxvd2VyXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYXJnMi52YWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogYXJnMi52YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgICB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnVwcGVyXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYXJnMi52YWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogYXJnMi52YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgICB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZGF0ZVRpbWUubm93XCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiIH07XG4gICAgY2FzZSBcImdsb2JhbC5ub3dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLmRlZmluZWRcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiYm9vbGVhblwiIH07XG4gICAgY2FzZSBcImdsb2JhbC5wYXRoXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBcInN0cmluZ1wiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmNvYWxlc2NlXCI6IHtcbiAgICAgIGlmIChub2RlLmFyZ3MubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgY29uc3QgdHlwZU5vZGVzID0gW107XG4gICAgICBsZXQgY2FuQmVOdWxsID0gITA7XG4gICAgICBmb3IgKGNvbnN0IGFyZyBvZiBub2RlLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHdhbGsoeyBub2RlOiBhcmcsIHNjb3BlIH0pO1xuICAgICAgICB0eXBlTm9kZXMucHVzaCh1bmlvbldpdGhvdXROdWxsKHR5cGUpKSwgY2FuQmVOdWxsID0gdHlwZS50eXBlID09PSBcIm51bGxcIiB8fCB0eXBlLnR5cGUgPT09IFwidW5pb25cIiAmJiB0eXBlLm9mLnNvbWUoKHQpID0+IHQudHlwZSA9PT0gXCJudWxsXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbkJlTnVsbCAmJiB0eXBlTm9kZXMucHVzaCh7IHR5cGU6IFwibnVsbFwiIH0pLCB7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb2Y6IHR5cGVOb2Rlc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5jb3VudFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJhcnJheVwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmRhdGVUaW1lXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlID09PSBcInN0cmluZ1wiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwubGVuZ3RoXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogYXJnMi50eXBlID09PSBcImFycmF5XCIgfHwgYXJnMi50eXBlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnJlZmVyZW5jZXNcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiYm9vbGVhblwiIH07XG4gICAgY2FzZSBcImdsb2JhbC5yb3VuZFwiOiB7XG4gICAgICBjb25zdCBudW1Ob2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShudW1Ob2RlLCBzY29wZSwgKG51bSkgPT4ge1xuICAgICAgICBpZiAobnVtLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pO1xuICAgICAgICBpZiAobnVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgaWYgKG5vZGUuYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBjb25zdCBwcmVjaXNpb25Ob2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICAgICAgcmV0dXJuIG1hcE5vZGUocHJlY2lzaW9uTm9kZSwgc2NvcGUsIChwcmVjaXNpb24pID0+IHByZWNpc2lvbi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBwcmVjaXNpb24udHlwZSAhPT0gXCJudW1iZXJcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJudW1iZXJcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bWJlclwiIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5zdHJpbmdcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IG5vZGUyLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgbm9kZTIudHlwZSA9PT0gXCJudW1iZXJcIiB8fCBub2RlMi50eXBlID09PSBcImJvb2xlYW5cIiA/IG5vZGUyLnZhbHVlID8ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogbm9kZTIudmFsdWUudG9TdHJpbmcoKVxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJtYXRoLnN1bVwiOiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHZhbHVlcywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbm9kZTIudHlwZSAhPT0gXCJhcnJheVwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogbWFwTm9kZShub2RlMi5vZiwgc2NvcGUsIChub2RlMykgPT4gbm9kZTMudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbm9kZTMudHlwZSA9PT0gXCJudW1iZXJcIiB8fCBub2RlMy50eXBlID09PSBcIm51bGxcIiA/IHsgdHlwZTogXCJudW1iZXJcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KSk7XG4gICAgfVxuICAgIGNhc2UgXCJtYXRoLmF2Z1wiOiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHZhbHVlcywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbm9kZTIudHlwZSAhPT0gXCJhcnJheVwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogbWFwTm9kZShub2RlMi5vZiwgc2NvcGUsIChub2RlMykgPT4gbm9kZTMudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbm9kZTMudHlwZSA9PT0gXCJudW1iZXJcIiA/IHsgdHlwZTogXCJudW1iZXJcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KSk7XG4gICAgfVxuICAgIGNhc2UgXCJtYXRoLm1heFwiOlxuICAgIGNhc2UgXCJtYXRoLm1pblwiOiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHZhbHVlcywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbm9kZTIudHlwZSAhPT0gXCJhcnJheVwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogbWFwTm9kZShub2RlMi5vZiwgc2NvcGUsIChub2RlMykgPT4gbm9kZTMudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbm9kZTMudHlwZSA9PT0gXCJudW1iZXJcIiA/IG5vZGUzIDogeyB0eXBlOiBcIm51bGxcIiB9KSk7XG4gICAgfVxuICAgIGNhc2UgXCJwdC50ZXh0XCI6XG4gICAgICByZXR1cm4gbm9kZS5hcmdzLmxlbmd0aCA9PT0gMCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfTtcbiAgICBjYXNlIFwic3RyaW5nLnN0YXJ0c1dpdGhcIjoge1xuICAgICAgY29uc3Qgc3RyVHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgcHJlZml4VHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHN0clR5cGVOb2RlLCBzY29wZSwgKHN0ck5vZGUpID0+IG1hcE5vZGUocHJlZml4VHlwZU5vZGUsIHNjb3BlLCAocHJlZml4Tm9kZSkgPT4gc3RyTm9kZS50eXBlID09PSBcInVua25vd25cIiB8fCBwcmVmaXhOb2RlLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiBzdHJOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgcHJlZml4Tm9kZS50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9KSk7XG4gICAgfVxuICAgIGNhc2UgXCJzdHJpbmcuc3BsaXRcIjoge1xuICAgICAgY29uc3Qgc3RyVHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgc2VwVHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHN0clR5cGVOb2RlLCBzY29wZSwgKHN0ck5vZGUpID0+IG1hcE5vZGUoc2VwVHlwZU5vZGUsIHNjb3BlLCAoc2VwTm9kZSkgPT4gc3RyTm9kZS50eXBlID09PSBcInVua25vd25cIiB8fCBzZXBOb2RlLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSkgOiBzdHJOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgc2VwTm9kZS50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9KSk7XG4gICAgfVxuICAgIGNhc2UgXCJzYW5pdHkudmVyc2lvbk9mXCI6IHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh0eXBlTm9kZSwgc2NvcGUsICh0eXBlTm9kZTIpID0+IHR5cGVOb2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pIDogdHlwZU5vZGUyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pO1xuICAgIH1cbiAgICBjYXNlIFwic2FuaXR5LmRvY3VtZW50c09mXCI6IHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh0eXBlTm9kZSwgc2NvcGUsICh0eXBlTm9kZTIpID0+IHR5cGVOb2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pIDogdHlwZU5vZGUyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgfVxufVxuZnVuY3Rpb24gbWF0Y2gobGVmdCwgcmlnaHQpIHtcbiAgbGV0IHRva2VucyA9IFtdLCBwYXR0ZXJucyA9IFtdO1xuICBpZiAobGVmdC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGxlZnQudmFsdWUgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUobGVmdC52YWx1ZSkpO1xuICB9XG4gIGlmIChsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgIGlmIChsZWZ0Lm9mLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChsZWZ0Lm9mLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChsZWZ0Lm9mLnZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShsZWZ0Lm9mLnZhbHVlKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0Lm9mLnR5cGUgPT09IFwidW5pb25cIilcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBsZWZ0Lm9mLm9mKVxuICAgICAgICBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgbm9kZS52YWx1ZSAhPT0gdm9pZCAwICYmICh0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUobm9kZS52YWx1ZSkpKTtcbiAgfVxuICBpZiAocmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChyaWdodC52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocmlnaHQudmFsdWUpKTtcbiAgfVxuICBpZiAocmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHJpZ2h0Lm9mLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyaWdodC5vZi50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAocmlnaHQub2YudmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihyaWdodC5vZi52YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAocmlnaHQub2YudHlwZSA9PT0gXCJ1bmlvblwiKVxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHJpZ2h0Lm9mLm9mKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAobm9kZS52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4obm9kZS52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG59XG5jb25zdCAkdHJhY2UgPSBkZWJ1ZyhcInR5cGVFdmFsdWF0b3I6ZXZhbHVhdGU6dHJhY2VcIik7XG4kdHJhY2UubG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbmNvbnN0ICRkZWJ1ZyA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTpkZWJ1Z1wiKTtcbiRkZWJ1Zy5sb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuY29uc3QgJHdhcm4gPSBkZWJ1ZyhcInR5cGVFdmFsdWF0b3I6ZXZhbHVhdGU6d2FyblwiKTtcbmZ1bmN0aW9uIHR5cGVFdmFsdWF0ZShhc3QsIHNjaGVtYSkge1xuICAkZGVidWcoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5hc3QgJU9cIiwgYXN0KSwgJGRlYnVnKFwiZXZhbHVhdGVRdWVyeVR5cGUuc2NoZW1hICVPXCIsIHNjaGVtYSk7XG4gIGNvbnN0IHBhcnNlZCA9IHdhbGsoe1xuICAgIG5vZGU6IGFzdCxcbiAgICBzY29wZTogbmV3IFNjb3BlMihbXSwgdm9pZCAwLCBuZXcgQ29udGV4dChzY2hlbWEpKVxuICB9KTtcbiAgJHRyYWNlKFwiZXZhbHVhdGVRdWVyeVR5cGUucGFyc2VkICVPXCIsIHBhcnNlZCk7XG4gIGNvbnN0IG9wdGltaXplZCA9IG9wdGltaXplVW5pb25zKHBhcnNlZCk7XG4gIHJldHVybiAkZGVidWcoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5vcHRpbWl6ZWQgJU9cIiwgb3B0aW1pemVkKSwgb3B0aW1pemVkO1xufVxuZnVuY3Rpb24gbWFwRGVyZWYoYmFzZSwgc2NvcGUpIHtcbiAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJ1bmlvblwiID8ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogYmFzZS5vZi5tYXAoKG5vZGUpID0+IG1hcERlcmVmKG5vZGUsIHNjb3BlKSlcbiAgfSA6IGJhc2UudHlwZSA9PT0gXCJhcnJheVwiID8ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjogbWFwRGVyZWYoYmFzZS5vZiwgc2NvcGUpXG4gIH0gOiBiYXNlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgYmFzZS5kZXJlZmVyZW5jZXNUbyAhPT0gdm9pZCAwID8gc2NvcGUuY29udGV4dC5sb29rdXBSZWYoYmFzZS5kZXJlZmVyZW5jZXNUbykgOiB7IHR5cGU6IFwibnVsbFwiIH07XG59XG5mdW5jdGlvbiBoYW5kbGVEZXJlZk5vZGUobm9kZSwgc2NvcGUpIHtcbiAgJHRyYWNlKFwiZGVyZWYubm9kZSAlT1wiLCBub2RlKTtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICBpZiAoJHRyYWNlKFwiZGVyZWYuYmFzZSAlT1wiLCBiYXNlKSwgYmFzZS50eXBlID09PSBcIm51bGxcIiB8fCBiYXNlLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIGNvbnN0IGRlcmVmZWROb2RlID0gbWFwRGVyZWYoYmFzZSwgc2NvcGUpO1xuICByZXR1cm4gJHRyYWNlKFwiZGVyZWYuZGVyZWZlZE5vZGUgJU9cIiwgZGVyZWZlZE5vZGUpLCBkZXJlZmVkTm9kZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9iamVjdFNwbGF0Tm9kZShhdHRyLCBzY29wZSkge1xuICBjb25zdCB2YWx1ZSA9IHdhbGsoeyBub2RlOiBhdHRyLnZhbHVlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcIm9iamVjdC5zcGxhdC52YWx1ZSAlT1wiLCB2YWx1ZSksIG1hcE5vZGUodmFsdWUsIHNjb3BlLCAobm9kZSkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICBpZiAobm9kZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlczoge30gfTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGUuYXR0cmlidXRlcylcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAoYXR0cmlidXRlc1tuYW1lXSA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgaWYgKG5vZGUucmVzdCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCByZXNvbHZlZFJlc3QgPSByZXNvbHZlSW5saW5lKG5vZGUucmVzdCwgc2NvcGUpO1xuICAgICAgaWYgKHJlc29sdmVkUmVzdC50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgIGlmIChyZXNvbHZlZFJlc3QudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZXNvbHZlZFJlc3QuYXR0cmlidXRlcylcbiAgICAgICAgcmVzb2x2ZWRSZXN0LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKGF0dHJpYnV0ZXNbbmFtZV0gPSByZXNvbHZlZFJlc3QuYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwib2JqZWN0XCIsIGF0dHJpYnV0ZXMgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPYmplY3ROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGlmICgkdHJhY2UoXCJvYmplY3Qubm9kZSAlT1wiLCBub2RlKSwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgY29uc3Qgb2JqZWN0QXR0cmlidXRlcyA9IFtdLCBzcGxhdFZhcmlhbnRzID0gW10sIGNvbmRpdGlvbmFsVmFyaWFudHMgPSBbXTtcbiAgZm9yIChjb25zdCBbaWR4LCBhdHRyXSBvZiBub2RlLmF0dHJpYnV0ZXMuZW50cmllcygpKSB7XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gd2Fsayh7IG5vZGU6IGF0dHIudmFsdWUsIHNjb3BlIH0pO1xuICAgICAgb2JqZWN0QXR0cmlidXRlcy5wdXNoKFtcbiAgICAgICAgaWR4LFxuICAgICAgICBhdHRyLm5hbWUsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgICAgIHZhbHVlOiBhdHRyaWJ1dGVOb2RlXG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhdHRyLnR5cGUgPT09IFwiT2JqZWN0U3BsYXRcIikge1xuICAgICAgY29uc3QgYXR0cmlidXRlTm9kZSA9IGhhbmRsZU9iamVjdFNwbGF0Tm9kZShhdHRyLCBzY29wZSk7XG4gICAgICBzd2l0Y2ggKCR0cmFjZShcIm9iamVjdC5zcGxhdC5yZXN1bHQgJU9cIiwgYXR0cmlidXRlTm9kZSksIGF0dHJpYnV0ZU5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBhdHRyaWJ1dGVOb2RlLm9mKVxuICAgICAgICAgICAgaWYgKG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgICAgc3BsYXRWYXJpYW50cy5wdXNoKFtpZHgsIGF0dHJpYnV0ZU5vZGVdKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyLnR5cGUgPT09IFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiKSB7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBib29sZWFuVmFsdWUod2Fsayh7IG5vZGU6IGF0dHIuY29uZGl0aW9uLCBzY29wZSB9KSwgc2NvcGUpO1xuICAgICAgaWYgKCR0cmFjZShcIm9iamVjdC5jb25kaXRpb25hbC5zcGxhdC5jb25kaXRpb24gJU9cIiwgY29uZGl0aW9uKSwgY29uZGl0aW9uLmNhbkJlVHJ1ZSA9PT0gITEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYXR0cmlidXRlTm9kZSA9IGhhbmRsZU9iamVjdFNwbGF0Tm9kZShhdHRyLCBzY29wZSk7XG4gICAgICBpZiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LnJlc3VsdCAlT1wiLCBhdHRyaWJ1dGVOb2RlKSwgY29uZGl0aW9uLmNhbkJlRmFsc2UgPT09ICExICYmIGNvbmRpdGlvbi5jYW5CZU51bGwgPT09ICExKVxuICAgICAgICBzd2l0Y2ggKGF0dHJpYnV0ZU5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgc3BsYXRWYXJpYW50cy5wdXNoKFtpZHgsIGF0dHJpYnV0ZU5vZGVdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidW5pb25cIjoge1xuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBhdHRyaWJ1dGVOb2RlLm9mKVxuICAgICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICAgICAgc3BsYXRWYXJpYW50cy5wdXNoKFtpZHgsIGF0dHJpYnV0ZU5vZGVdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudCA9IG1hcE5vZGUoYXR0cmlidXRlTm9kZSwgc2NvcGUsIChhdHRyaWJ1dGVOb2RlMikgPT4gKCR0cmFjZShcIm9iamVjdC5jb25kaXRpb25hbC5zcGxhdC5yZXN1bHQuY29uY3JldGUgJU9cIiwgYXR0cmlidXRlTm9kZTIpLCBhdHRyaWJ1dGVOb2RlMi50eXBlICE9PSBcIm9iamVjdFwiID8geyB0eXBlOiBcInVua25vd25cIiB9IDoge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVOb2RlMi5hdHRyaWJ1dGVzXG4gICAgICB9KSk7XG4gICAgICBpZiAodmFyaWFudC50eXBlID09PSBcInVuaW9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiB2YXJpYW50Lm9mKVxuICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgICAgdmFyaWFudC5vZi5wdXNoKHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlczoge30gfSksIGNvbmRpdGlvbmFsVmFyaWFudHMucHVzaChbaWR4LCB2YXJpYW50XSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhcmlhbnQudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgIGNvbmRpdGlvbmFsVmFyaWFudHMucHVzaChbXG4gICAgICAgIGlkeCxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgICBvZjogW3sgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlczoge30gfSwgdmFyaWFudF1cbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9iamVjdCBhdHRyaWJ1dGUgdHlwZTogJHthdHRyLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgZ3VhcmFudGVlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgZ3VhcmFudGVlZEF0dHJpYnV0ZXMucHVzaCguLi5vYmplY3RBdHRyaWJ1dGVzKTtcbiAgZm9yIChjb25zdCBbaWR4LCBzcGxhdE5vZGVdIG9mIHNwbGF0VmFyaWFudHMpIHtcbiAgICBpZiAoc3BsYXROb2RlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzcGxhdE5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIXNwbGF0Tm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBzcGxhdE5vZGUuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgZ3VhcmFudGVlZEF0dHJpYnV0ZXMucHVzaChbaWR4LCBuYW1lLCBhdHRyaWJ1dGVdKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25kaXRpb25hbFZhcmlhbnRzLnB1c2goW2lkeCwgc3BsYXROb2RlXSk7XG4gIH1cbiAgaWYgKGd1YXJhbnRlZWRBdHRyaWJ1dGVzLnNvcnQoKFthXSwgW2JdKSA9PiBhIC0gYiksIGNvbmRpdGlvbmFsVmFyaWFudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBndWFyYW50ZWVkQXR0cmlidXRlcy5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgKVxuICAgIH07XG4gIGNvbnN0IG1hdHJpeCA9IFtdO1xuICBmb3IgKGNvbnN0IFt1bmlvbklkeCwgdW5pb25dIG9mIGNvbmRpdGlvbmFsVmFyaWFudHMpIHtcbiAgICBjb25zdCB1bmlvbkd1YXJhbnRlZWRCZWZvcmUgPSBbXSwgdW5pb25HdWFyYW50ZWVkQWZ0ZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0gb2YgZ3VhcmFudGVlZEF0dHJpYnV0ZXMpXG4gICAgICBndWFyYW50ZWVkSW5kZXggPCB1bmlvbklkeCAmJiB1bmlvbkd1YXJhbnRlZWRCZWZvcmUucHVzaChbZ3VhcmFudGVlZEluZGV4LCBuYW1lLCBhdHRyaWJ1dGVdKSwgZ3VhcmFudGVlZEluZGV4ID4gdW5pb25JZHggJiYgdW5pb25HdWFyYW50ZWVkQWZ0ZXIucHVzaChbZ3VhcmFudGVlZEluZGV4LCBuYW1lLCBhdHRyaWJ1dGVdKTtcbiAgICBjb25zdCBhbGxWYXJpYW50c0F0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtjb25kaXRpb25hbFZhcmlhbnRJZHgsIG90aGVyVW5pb25dIG9mIGNvbmRpdGlvbmFsVmFyaWFudHMpIHtcbiAgICAgIGNvbnN0IHZhcmlhbnRBdHRyaWJ1dGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIG90aGVyVW5pb24ub2YpXG4gICAgICAgIHZhcmlhbnRBdHRyaWJ1dGVzLnB1c2gobm9kZTIuYXR0cmlidXRlcyk7XG4gICAgICBhbGxWYXJpYW50c0F0dHJpYnV0ZXMucHVzaChbY29uZGl0aW9uYWxWYXJpYW50SWR4LCB2YXJpYW50QXR0cmlidXRlc10pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIHVuaW9uLm9mKSB7XG4gICAgICBtYXRyaXgucHVzaCh7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICB1bmlvbkd1YXJhbnRlZWRCZWZvcmUubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICApLFxuICAgICAgICAgIC4uLm5vZGUyLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgdW5pb25HdWFyYW50ZWVkQWZ0ZXIubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBbb3V0ZXJJZHgsIG91dGVyQXR0cmlidXRlc10gb2YgYWxsVmFyaWFudHNBdHRyaWJ1dGVzKVxuICAgICAgICBmb3IgKGNvbnN0IG91dGVyIG9mIG91dGVyQXR0cmlidXRlcylcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpbm5lcklkeCwgaW5uZXJBdHRyaWJ1dGVzXSBvZiBhbGxWYXJpYW50c0F0dHJpYnV0ZXMpXG4gICAgICAgICAgICBpZiAob3V0ZXJJZHggIT09IGlubmVySWR4KVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIGlubmVyQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9iZWZvcmUgPSBbLi4udW5pb25HdWFyYW50ZWVkQmVmb3JlXSwgX2FmdGVyID0gWy4uLnVuaW9uR3VhcmFudGVlZEFmdGVyXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3V0ZXIpXG4gICAgICAgICAgICAgICAgICBvdXRlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBvdXRlcklkeCAhPT0gdW5pb25JZHggJiYgKG91dGVySWR4IDwgdW5pb25JZHggJiYgX2JlZm9yZS5wdXNoKFtvdXRlcklkeCwgbmFtZSwgb3V0ZXJbbmFtZV1dKSwgb3V0ZXJJZHggPiB1bmlvbklkeCAmJiBfYWZ0ZXIucHVzaChbb3V0ZXJJZHgsIG5hbWUsIG91dGVyW25hbWVdXSkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBpbm5lcilcbiAgICAgICAgICAgICAgICAgIGlubmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIG91dGVySWR4ICE9PSB1bmlvbklkeCAmJiAoaW5uZXJJZHggPCB1bmlvbklkeCAmJiBfYmVmb3JlLnB1c2goW2lubmVySWR4LCBuYW1lLCBpbm5lcltuYW1lXV0pLCBpbm5lcklkeCA+IHVuaW9uSWR4ICYmIF9hZnRlci5wdXNoKFtpbm5lcklkeCwgbmFtZSwgaW5uZXJbbmFtZV1dKSk7XG4gICAgICAgICAgICAgICAgX2JlZm9yZS5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpLCBfYWZ0ZXIuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmUgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICBfYmVmb3JlLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICAgICAgICAgICAgKSwgYWZ0ZXIgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICBfYWZ0ZXIubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG1hdHJpeC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJlZm9yZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZTIuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uYWZ0ZXJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW1pemVVbmlvbnMoe1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogbWF0cml4XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BDYWxsTm9kZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJvcGNhbGwubm9kZSAlT1wiLCBub2RlKTtcbiAgY29uc3QgbGhzID0gd2Fsayh7IG5vZGU6IG5vZGUubGVmdCwgc2NvcGUgfSksIHJocyA9IHdhbGsoeyBub2RlOiBub2RlLnJpZ2h0LCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoXG4gICAgbGhzLFxuICAgIHNjb3BlLFxuICAgIChsZWZ0KSA9PiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHNcbiAgICAgIG1hcE5vZGUocmhzLCBzY29wZSwgKHJpZ2h0KSA9PiB7XG4gICAgICAgIHN3aXRjaCAoJHRyYWNlKCdvcGNhbGwubm9kZS5jb25jcmV0ZSBcIiVzXCIgJU8nLCBub2RlLm9wLCB7IGxlZnQsIHJpZ2h0IH0pLCBub2RlLm9wKSB7XG4gICAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJudWxsXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgIH0gOiAhaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSB8fCAhaXNQcmltaXRpdmVUeXBlTm9kZShyaWdodCkgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZXZhbHVhdGVDb21wYXJpc29uKG5vZGUub3AsIGxlZnQsIHJpZ2h0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFwiIT1cIjoge1xuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiYm9vbGVhblwiIH07XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlICE9PSByaWdodC50eXBlKVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWlzUHJpbWl0aXZlVHlwZU5vZGUobGVmdCkgfHwgIWlzUHJpbWl0aXZlVHlwZU5vZGUocmlnaHQpKVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZXZhbHVhdGVDb21wYXJpc29uKFwiPT1cIiwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2b2lkIDAgJiYgKHZhbHVlID0gIXZhbHVlKSwge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiBsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiAhaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSB8fCAhaXNQcmltaXRpdmVUeXBlTm9kZShyaWdodCkgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZXZhbHVhdGVDb21wYXJpc29uKG5vZGUub3AsIGxlZnQsIHJpZ2h0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiByaWdodC50eXBlICE9PSBcImFycmF5XCIgPyBpc0Z1bmNDYWxsKG5vZGUucmlnaHQsIFwiZ2xvYmFsOjpwYXRoXCIpID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9IDogIWlzUHJpbWl0aXZlVHlwZU5vZGUobGVmdCkgJiYgbGVmdC50eXBlICE9PSBcIm51bGxcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSA6IG1hcE5vZGUocmlnaHQub2YsIHNjb3BlLCAoYXJyYXlUeXBlTm9kZSkgPT4gYXJyYXlUeXBlTm9kZS50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bGxcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBhcnJheVR5cGVOb2RlLnR5cGUgPT09IFwibnVsbFwiXG4gICAgICAgICAgICB9IDogbGVmdC52YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgfSA6IGlzUHJpbWl0aXZlVHlwZU5vZGUoYXJyYXlUeXBlTm9kZSkgPyBhcnJheVR5cGVOb2RlLnZhbHVlID09PSB2b2lkIDAgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgPT09IGFycmF5VHlwZU5vZGUudmFsdWVcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJtYXRjaFwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2gobGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJ1bmtub3duXCIgfSA6IGxlZnQudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiByaWdodC50eXBlID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICsgcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSArIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9mOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICAgICAgICAgIG9mOiBbbGVmdC5vZiwgcmlnaHQub2ZdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiBsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogeyAuLi5sZWZ0LmF0dHJpYnV0ZXMsIC4uLnJpZ2h0LmF0dHJpYnV0ZXMgfVxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgLSByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKiByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgLyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICoqIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAlIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBoYW5kbGVTZWxlY3ROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBsZXQgZ3VhcmFudGVlZCA9ICExO1xuICBmb3IgKGNvbnN0IGFsdGVybmF0aXZlIG9mIG5vZGUuYWx0ZXJuYXRpdmVzKSB7XG4gICAgY29uc3QgY29uZGl0aW9uVmFsdWUgPSB3YWxrKHsgbm9kZTogYWx0ZXJuYXRpdmUuY29uZGl0aW9uLCBzY29wZSB9KSwgY29uZGl0aW9uU2NvcGUgPSByZXNvbHZlRmlsdGVyKGFsdGVybmF0aXZlLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgIGNvbmRpdGlvblNjb3BlLnR5cGUgPT09IFwidW5pb25cIiAmJiBjb25kaXRpb25TY29wZS5vZi5sZW5ndGggPiAwICYmIHZhbHVlcy5wdXNoKHdhbGsoeyBub2RlOiBhbHRlcm5hdGl2ZS52YWx1ZSwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihjb25kaXRpb25TY29wZS5vZikgfSkpLCBjb25kaXRpb25WYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBjb25kaXRpb25WYWx1ZS52YWx1ZSA9PT0gITAgJiYgKGd1YXJhbnRlZWQgPSAhMCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuZmFsbGJhY2sgJiYgIWd1YXJhbnRlZWQgJiYgdmFsdWVzLnB1c2god2Fsayh7IG5vZGU6IG5vZGUuZmFsbGJhY2ssIHNjb3BlIH0pKSwgdmFsdWVzLmxlbmd0aCA9PT0gMCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IHZhbHVlc1xuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQXJyYXlDb2VyY2VOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcImFycmF5Q29lcmNlLmJhc2UgJU9cIiwgYmFzZSksIG1hcEFycmF5KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZsYXRNYXAobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gd2Fsayh7IG5vZGU6IG5vZGUuZXhwciwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihbYmFzZTIub2ZdKSB9KTtcbiAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgIGlubmVyLFxuICAgICAgc2NvcGUsXG4gICAgICAoaW5uZXIyKSA9PiBpbm5lcjIudHlwZSA9PT0gXCJhcnJheVwiID8gaW5uZXIyIDogeyB0eXBlOiBcImFycmF5XCIsIG9mOiBpbm5lcjIgfSxcbiAgICAgIChub2RlcykgPT4ge1xuICAgICAgICBjb25zdCBpbm5lcjIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2RlMi50eXBlID09PSBcInVua25vd25cIikgcmV0dXJuIHsgdHlwZTogXCJhcnJheVwiLCBvZjogbm9kZTIgfTtcbiAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJhcnJheVwiKSB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZTogJHtub2RlMi50eXBlfWApO1xuICAgICAgICAgIGlubmVyMi5wdXNoKG5vZGUyLm9mKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICBvZjogb3B0aW1pemVVbmlvbnMoeyB0eXBlOiBcInVuaW9uXCIsIG9mOiBpbm5lcjIgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1hcChub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJtYXAuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHdhbGsoeyBub2RlOiBub2RlLmV4cHIsIHNjb3BlOiBzY29wZS5jcmVhdGVIaWRkZW4oW2Jhc2UyLm9mXSkgfSlcbiAgfSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlUHJvamVjdGlvbk5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwicHJvamVjdGlvbi5iYXNlICVPXCIsIGJhc2UpLCBtYXBPYmplY3QoXG4gICAgYmFzZSxcbiAgICBzY29wZSxcbiAgICAoYmFzZTIpID0+IHdhbGsoeyBub2RlOiBub2RlLmV4cHIsIHNjb3BlOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2UyXSkgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlclNjb3BlKGJhc2UsIHNjb3BlKSB7XG4gIHJldHVybiBiYXNlLnR5cGUgPT09IFwiYXJyYXlcIiA/IGJhc2Uub2YudHlwZSA9PT0gXCJ1bmlvblwiID8gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2Uub2Yub2YpIDogc2NvcGUuY3JlYXRlTmVzdGVkKFtiYXNlLm9mXSkgOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2VdKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZpbHRlck5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwiZmlsdGVyLmJhc2UgJU9cIiwgYmFzZSksIG1hcE5vZGUoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgIGlmICgkdHJhY2UoXCJmaWx0ZXIucmVzb2x2aW5nICVPXCIsIGJhc2UyKSwgYmFzZTIudHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICByZXR1cm4gYmFzZTI7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRmlsdGVyKG5vZGUuZXhwciwgY3JlYXRlRmlsdGVyU2NvcGUoYmFzZTIsIHNjb3BlKSk7XG4gICAgcmV0dXJuICR0cmFjZShcImZpbHRlci5yZXNvbHZlZCAlT1wiLCByZXNvbHZlZCksIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiByZXNvbHZlZFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzQXR0cmlidXRlTm9kZShub2RlLCBzY29wZSkge1xuICBsZXQgYXR0cmlidXRlQmFzZSA9IHNjb3BlLnZhbHVlO1xuICByZXR1cm4gbm9kZS5iYXNlICYmIChhdHRyaWJ1dGVCYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSkpLCAkdHJhY2UoXCJhY2Nlc3NBdHRyaWJ1dGUuYmFzZSAlcyAlT1wiLCBub2RlLm5hbWUsIGF0dHJpYnV0ZUJhc2UpLCBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVCYXNlKGF0dHJpYnV0ZUJhc2UsIG5vZGUubmFtZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzQXR0cmlidXRlQmFzZShiYXNlLCBuYW1lLCBzY29wZSkge1xuICByZXR1cm4gbWFwT2JqZWN0KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IHtcbiAgICAkdHJhY2UoJ0xvb2tpbmcgZm9yIGF0dHJpYnV0ZSBcIiVzXCIgaW4gb2JqZWN0ICVPJywgbmFtZSwgYmFzZTIpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGJhc2UyLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgcmV0dXJuIGF0dHJpYnV0ZSAhPT0gdm9pZCAwID8gKCRkZWJ1ZyhgYWNjZXNzQXR0cmlidXRlLmF0dHJpYnV0ZSBmb3VuZCAke25hbWV9ICVPYCwgYXR0cmlidXRlKSwgYXR0cmlidXRlLm9wdGlvbmFsID8gbnVsbFVuaW9uKGF0dHJpYnV0ZS52YWx1ZSkgOiBhdHRyaWJ1dGUudmFsdWUpIDogYmFzZTIucmVzdCA/IGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZUJhc2UoYmFzZTIucmVzdCwgbmFtZSwgc2NvcGUpIDogKCR3YXJuKGBhdHRyaWJ1dGUgXCIke25hbWV9XCIgbm90IGZvdW5kIGluIG9iamVjdGApLCB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0VsZW1lbnROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcImFjY2Vzc0VsZW1lbnQuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gbnVsbFVuaW9uKGJhc2UyLm9mKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBcnJheU5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3Qgb2YgPSBbXTtcbiAgZm9yIChjb25zdCBlbCBvZiBub2RlLmVsZW1lbnRzKSB7XG4gICAgY29uc3Qgbm9kZTIgPSB3YWxrKHsgbm9kZTogZWwudmFsdWUsIHNjb3BlIH0pO1xuICAgIG5vZGUyICE9PSBudWxsICYmIG9mLnB1c2gobm9kZTIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiB7XG4gICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICBvZlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVZhbHVlTm9kZShub2RlLCBzY29wZSkge1xuICBpZiAobm9kZS52YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICBzd2l0Y2ggKHR5cGVvZiBub2RlLnZhbHVlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcbiAgICAgIH07XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcbiAgICAgIH07XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZSA9PT0gbnVsbCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IEFycmF5LmlzQXJyYXkobm9kZS52YWx1ZSkgPyB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgb2Y6IHtcbiAgICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgICAgb2Y6IG5vZGUudmFsdWUubWFwKCh2YWx1ZSkgPT4gd2Fsayh7IG5vZGU6IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9LCBzY29wZSB9KSlcbiAgICAgICAgfVxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG5vZGUudmFsdWUpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiB3YWxrKHsgbm9kZTogeyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH0sIHNjb3BlIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSlcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2xpY2Uobm9kZSwgc2NvcGUpIHtcbiAgJHRyYWNlKFwic2xpY2Uubm9kZSAlT1wiLCBub2RlKTtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlUGFyZW50Tm9kZSh7IG4gfSwgc2NvcGUpIHtcbiAgJHRyYWNlKFwiaGFuZGxlLnBhcmVudC5jdXJyZW50U2NvcGUgJWQgJU9cIiwgbiwgc2NvcGUpO1xuICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGZvciAoOyBjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudC5pc0hpZGRlbjsgKVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIGN1cnJlbnQgPSBjdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gJHRyYWNlKFwiaGFuZGxlLnBhcmVudC5uZXdTY29wZSAlZCAlT1wiLCBuLCBjdXJyZW50KSwgY3VycmVudCA/IGN1cnJlbnQudmFsdWUub2YubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDogY3VycmVudC52YWx1ZSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogYmFzZTIudHlwZSA9PT0gXCJib29sZWFuXCIgPyBiYXNlMi52YWx1ZSAhPT0gdm9pZCAwID8geyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IGJhc2UyLnZhbHVlID09PSAhMSB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5lZ05vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBiYXNlMi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYmFzZTIudmFsdWUgIT09IHZvaWQgMCA/IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IC1iYXNlMi52YWx1ZSB9IDogYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGJhc2UyLnR5cGUgIT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVyeXRoaW5nTm9kZShfLCBzY29wZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjoge1xuICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgb2Y6IHNjb3BlLmNvbnRleHQuc2NoZW1hLmZpbHRlcigob2JqKSA9PiBvYmoudHlwZSA9PT0gXCJkb2N1bWVudFwiKS5tYXAoKGRvYykgPT4gKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczogZG9jLmF0dHJpYnV0ZXNcbiAgICAgIH0pKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFuZE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgbGVmdCA9IHdhbGsoeyBub2RlOiBub2RlLmxlZnQsIHNjb3BlIH0pLCByaWdodCA9IHdhbGsoeyBub2RlOiBub2RlLnJpZ2h0LCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoXG4gICAgbGVmdCxcbiAgICBzY29wZSxcbiAgICAobGhzKSA9PiBtYXBOb2RlKHJpZ2h0LCBzY29wZSwgKHJocykgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBib29sZWFuQW5kKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFuZGxlT3JOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGxlZnQgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmlnaHQgPSB3YWxrKHsgbm9kZTogbm9kZS5yaWdodCwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKFxuICAgIGxlZnQsXG4gICAgc2NvcGUsXG4gICAgKGxocykgPT4gbWFwTm9kZShyaWdodCwgc2NvcGUsIChyaHMpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYm9vbGVhbk9yKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuY29uc3QgT1ZFUlJJREVfVFlQRV9TWU1CT0wgPSBTeW1ib2woXCJncm9xLWpzLnR5cGVcIik7XG5mdW5jdGlvbiB3YWxrKHsgbm9kZSwgc2NvcGUgfSkge1xuICBpZiAoT1ZFUlJJREVfVFlQRV9TWU1CT0wgaW4gbm9kZSlcbiAgICByZXR1cm4gbm9kZVtPVkVSUklERV9UWVBFX1NZTUJPTF07XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU1hcChub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlByb2plY3Rpb25cIjpcbiAgICAgIHJldHVybiBoYW5kbGVQcm9qZWN0aW9uTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZpbHRlclwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUZpbHRlck5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBY2Nlc3NBdHRyaWJ1dGVcIjpcbiAgICAgIHJldHVybiBvcHRpbWl6ZVVuaW9ucyhoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVOb2RlKG5vZGUsIHNjb3BlKSk7XG4gICAgY2FzZSBcIkFjY2Vzc0VsZW1lbnRcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBY2Nlc3NFbGVtZW50Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkFycmF5Q29lcmNlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlQXJyYXlDb2VyY2VOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiRmxhdE1hcFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUZsYXRNYXAobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJPcENhbGxcIjpcbiAgICAgIHJldHVybiBoYW5kbGVPcENhbGxOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQW5kXCI6XG4gICAgICByZXR1cm4gaGFuZGxlQW5kTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIk9yXCI6XG4gICAgICByZXR1cm4gaGFuZGxlT3JOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiU2VsZWN0XCI6XG4gICAgICByZXR1cm4gaGFuZGxlU2VsZWN0Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlBpcGVGdW5jQ2FsbFwiOlxuICAgICAgcmV0dXJuIHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICAgIGNhc2UgXCJEZXJlZlwiOlxuICAgICAgcmV0dXJuIGhhbmRsZURlcmVmTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU9iamVjdE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJWYWx1ZVwiOlxuICAgICAgcmV0dXJuIGhhbmRsZVZhbHVlTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gaGFuZGxlQXJyYXlOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiRXZlcnl0aGluZ1wiOlxuICAgICAgcmV0dXJuIGhhbmRsZUV2ZXJ5dGhpbmdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiVGhpc1wiOlxuICAgICAgcmV0dXJuICR0cmFjZShcInRoaXMgJU9cIiwgc2NvcGUudmFsdWUpLCBzY29wZS52YWx1ZTtcbiAgICBjYXNlIFwiUGFyZW50XCI6XG4gICAgICByZXR1cm4gaGFuZGxlUGFyZW50Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRnVuY0NhbGxOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgICBjYXNlIFwiTm90XCI6XG4gICAgICByZXR1cm4gaGFuZGxlTm90Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1bmtub3duXCJcbiAgICAgIH07XG4gICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlU2xpY2Uobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBoYW5kbGVOZWdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgICByZXR1cm4gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkFzY1wiOlxuICAgIGNhc2UgXCJEZXNjXCI6XG4gICAgY2FzZSBcIkNvbnRleHRcIjpcbiAgICBjYXNlIFwiVHVwbGVcIjpcbiAgICBjYXNlIFwiU2VsZWN0b3JcIjpcbiAgICBjYXNlIFwiSW5SYW5nZVwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG5vZGUgdHlwZSAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgbm9kZS50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUNvbXBhcmlzb24ob3BjYWxsLCBsZWZ0LCByaWdodCkge1xuICBpZiAoIShsZWZ0LnZhbHVlID09PSB2b2lkIDAgfHwgcmlnaHQudmFsdWUgPT09IHZvaWQgMCkpXG4gICAgc3dpdGNoIChvcGNhbGwpIHtcbiAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA9PT0gcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPFwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA8IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlIDw9IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPiByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA+PSByaWdodC52YWx1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBjb21wYXJpc29uIG9wZXJhdG9yICR7b3BjYWxsfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIoZXhwciwgc2NvcGUpIHtcbiAgJHRyYWNlKFwicmVzb2x2ZUZpbHRlci5leHByICVPXCIsIGV4cHIpO1xuICBjb25zdCBmaWx0ZXJlZCA9IHNjb3BlLnZhbHVlLm9mLmZpbHRlcigobm9kZSkgPT4ge1xuICAgIGNvbnN0IHN1YlNjb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKFtub2RlXSksIGNvbmQgPSB3YWxrKHsgbm9kZTogZXhwciwgc2NvcGU6IHN1YlNjb3BlIH0pO1xuICAgIHJldHVybiBib29sZWFuVmFsdWUoY29uZCwgc3ViU2NvcGUpLmNhbkJlVHJ1ZTtcbiAgfSk7XG4gIHJldHVybiAkdHJhY2UoXG4gICAgYHJlc29sdmVGaWx0ZXIgJHtleHByLnR5cGUgPT09IFwiT3BDYWxsXCIgPyBgJHtleHByLnR5cGV9LyR7ZXhwci5vcH1gIDogZXhwci50eXBlfSAlT2AsXG4gICAgZmlsdGVyZWRcbiAgKSwgeyB0eXBlOiBcInVuaW9uXCIsIG9mOiBmaWx0ZXJlZCB9O1xufVxuZnVuY3Rpb24gbWFwQXJyYXkobm9kZSwgc2NvcGUsIG1hcHBlcikge1xuICByZXR1cm4gbWFwTm9kZShub2RlLCBzY29wZSwgKGJhc2UpID0+IGJhc2UudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBiYXNlIDogYmFzZS50eXBlID09PSBcImFycmF5XCIgPyBtYXBwZXIoYmFzZSkgOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xufVxuZnVuY3Rpb24gbWFwT2JqZWN0KG5vZGUsIHNjb3BlLCBtYXBwZXIpIHtcbiAgcmV0dXJuIG1hcE5vZGUobm9kZSwgc2NvcGUsIChiYXNlKSA9PiBiYXNlLnR5cGUgPT09IFwidW5rbm93blwiID8gYmFzZSA6IGJhc2UudHlwZSA9PT0gXCJvYmplY3RcIiA/IG1hcHBlcihiYXNlKSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG59XG5leHBvcnQge1xuICBEYXRlVGltZSxcbiAgUGF0aCxcbiAgY3JlYXRlUmVmZXJlbmNlVHlwZU5vZGUsXG4gIGV2YWx1YXRlUXVlcnkgYXMgZXZhbHVhdGUsXG4gIHBhcnNlLFxuICB0eXBlRXZhbHVhdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD0xLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;